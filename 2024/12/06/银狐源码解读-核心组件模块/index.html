<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Jentle" />
  <!-- Open Graph Description 简短摘要-->

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.css">
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: 'default'
    });
  </script>

  
      <!-- 用于搜索引擎的文章摘要 -->
      
            
                
                  <title>
                    
                      银狐源码解读--核心组件模块
                        
                              
                                    |
                                    
                                      TIPFactory
                  </title>

                  
                    <link rel="apple-touch-icon" href="/images/dog2.jpg">
                    <link rel="icon" href="/images/dog2.jpg">
                    

                      <!-- Raleway-Font -->
                      <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

                      <!-- hexo site css -->
                      <link rel="stylesheet" href="/css/main.css" />
                      <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
                      <!-- 代码块风格 -->
                      

                            <!-- jquery3.3.1 -->
                            
                                <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
                                

                                  <!-- fancybox -->
                                  
                                      <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
                                      <script defer type="text/javascript"
                                        src="/plugins/jquery.fancybox.min.js"></script>
                                      
                                        
<script src="/js/fancybox.js"></script>


                                          
                                            <!-- Global site tag (gtag.js) - Google Analytics -->
                                            <script async
                                              src="https://www.googletagmanager.com/gtag/js?id=G-2B5W7NCXEE"></script>
                                            <script>
                                              window.dataLayer = window.dataLayer || [];
                                              function gtag() { dataLayer.push(arguments); }
                                              gtag('js', new Date());

                                              gtag('config', 'G-2B5W7NCXEE');
                                            </script>
                                            


                                              
                                                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                                                

                                                  <script>
                                                    var html = document.documentElement
                                                    const colorMode = localStorage.getItem('color-mode')
                                                    if (colorMode) {
                                                      document.documentElement.setAttribute('color-mode', colorMode)
                                                    }
                                                  </script>
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="TIPFactory" type="application/atom+xml">
</head>

  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img no-lazy src="/images/dog.gif" alt="">
      
    </a>
    <div class="nickname"><a href="/">打工人的自留地</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">银狐源码解读--核心组件模块</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2025-01-23 16:32:31
        </span>
        
      </div>
      <div class="markdown-body">
        <p>[toC]</p>
<h1 id="核心模块组件介绍"><a href="#核心模块组件介绍" class="headerlink" title="核心模块组件介绍"></a>核心模块组件介绍</h1><blockquote>
<p>可以在公众号获取原文，目前网站不支持mermaid，可公众号下载原始PDF!!!</p>
</blockquote>
<h2 id="HPSocket"><a href="#HPSocket" class="headerlink" title="HPSocket"></a>HPSocket</h2><p>使用的公开技术，基于于 IOCP&#x2F;EPOLL 通信模型，结合内存池、私有堆等技术，实现高效的内存管理，支持大规模、高并发的通信场景。Git地址：<a target="_blank" rel="noopener" href="https://github.com/ldcsaa/HP-Socket">https://github.com/ldcsaa/HP-Socket</a></p>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic1.png" class="" title="pic1">

<h2 id="shellcode："><a href="#shellcode：" class="headerlink" title="shellcode："></a>shellcode：</h2><ol>
<li>在 ntdll_entry 函数中，程序通过 LoadLibraryA 加载 kernel32.dll 和 ntdll.dll，并使用 GetProcAddress 获取所需的函数地址。</li>
<li>通过 mytcp 和 myudp 函数实现 TCP 和 UDP 的网络通信。程序根据 ShellCodeInfo 结构中的信息进行连接和数据传输。</li>
<li>定义了一些数据结构，如 ShellCodeInfo、func_t 等，用于存储网络通信所需的信息和函数指针。</li>
</ol>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic2.png" class="" title="pic2">

<h2 id="上线模块："><a href="#上线模块：" class="headerlink" title="上线模块："></a>上线模块：</h2><p>函数调用关系</p>
<pre class="mermaid">graph TD;
    A[_tmain] --> B[Analyze]
    A --> C[SetUnhandledExceptionFilter]
    B --> D[Getfindinfo]
    B --> E[RegOpenKeyEx]
    B --> F[RegQueryValueEx]
    C --> G[ExceptionFilter]
    G --> H[GenerateMiniDump]
    A --> I[CreateThread]
    I --> J[MainThread]
    J --> K[Socket Communication]</pre>

<p>说明</p>
<ul>
<li><strong>A</strong>: 程序入口 <code>_tmain</code>，设置异常处理器并调用 <code>Analyze</code>。</li>
<li><strong>B</strong>: <code>Analyze</code> 函数用于提取配置信息。</li>
<li><strong>C</strong>: 设置未处理异常过滤器，调用 <code>ExceptionFilter</code>。</li>
<li><strong>D</strong>: <code>Getfindinfo</code> 用于从配置中提取信息。</li>
<li><strong>E</strong> 和 <strong>F</strong>: 从注册表中读取配置信息。</li>
<li><strong>G</strong>: <code>ExceptionFilter</code> 捕获异常并调用 <code>GenerateMiniDump</code>。</li>
<li><strong>H</strong>: <code>GenerateMiniDump</code> 生成转储文件。</li>
<li><strong>I</strong>: 创建主线程，调用 <code>MainThread</code>。</li>
<li><strong>J</strong>: <code>MainThread</code> 处理网络通信。</li>
</ul>
<p>部分代码解释：</p>
<ol>
<li><p><strong>信息结构体定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Info MyInfo = &#123; ... &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>****定义一个 <code>Info</code> 结构体实例 <code>MyInfo</code>，用于存储配置信息，如 IP 地址、端口、TCP&#x2F;UDP 标志等。</li>
</ul>
</li>
<li><p><strong>全局变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">bool</span> changeip = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> m_time_con = <span class="number">0</span>;</span><br><span class="line">TCHAR szAddress[<span class="number">255</span>];  <span class="comment">//ip</span></span><br><span class="line">TCHAR szPort[<span class="number">30</span>];      <span class="comment">//端口</span></span><br><span class="line">TCHAR szPassword[<span class="number">255</span>]; <span class="comment">//通行密码</span></span><br><span class="line">BOOL IsTcp;            <span class="comment">//通信模式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>****定义全局变量，用于线程管理、IP 地址、端口、密码和通信模式的存储。</li>
</ul>
</li>
<li><p><strong><code>Getfindinfo</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Getfindinfo</span><span class="params">(TCHAR* s, <span class="type">const</span> TCHAR* f1, TCHAR* outstring, BOOL* user)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>****从给定字符串中提取特定信息（如 IP 地址和端口），并将其存储到输出参数中。</li>
</ul>
</li>
<li><p><strong><code>Analyze</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>****分析配置信息，调用 <code>Getfindinfo</code> 函数从配置字符串和注册表中提取信息。</li>
</ul>
</li>
<li><p><strong><code>MainThread</code> 函数</strong> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">MainThread</span><span class="params">(LPVOID dllMainThread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ISocketBase* socketClient;</span><br><span class="line">	<span class="keyword">if</span> (MyInfo.IsTcp == <span class="number">1</span>)</span><br><span class="line">		socketClient = <span class="keyword">new</span> <span class="built_in">CTcpSocket</span>();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		socketClient = <span class="keyword">new</span> <span class="built_in">CUdpSocket</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (socketClient-&gt;<span class="built_in">Connect</span>(MyInfo.szAddress, MyInfo.szPort))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">CRegeditManager	<span class="title">manager</span><span class="params">(socketClient)</span></span>;</span><br><span class="line">		socketClient-&gt;<span class="built_in">run_event_loop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SAFE_DELETE</span>(socketClient);</span><br><span class="line">	<span class="keyword">if</span> (MyInfo.RunDllEntryProc)</span><br><span class="line">		<span class="built_in">ExitProcess</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>****主线程函数，负责初始化网络连接，循环处理网络通信。</li>
</ul>
</li>
<li><p><strong><code>GenerateMiniDump</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GenerateMiniDump</span><span class="params">(PEXCEPTION_POINTERS pExceptionPointers)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>****生成崩溃转储文件，以便在程序异常时进行调试。</li>
</ul>
</li>
<li><p><strong><code>ExceptionFilter</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG WINAPI <span class="title">ExceptionFilter</span><span class="params">(LPEXCEPTION_POINTERS lpExceptionInfo)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>****捕获未处理的异常并调用 <code>GenerateMiniDump</code> 生成转储文件。</li>
</ul>
</li>
<li><p><strong><code>_tmain</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>****程序的入口点，设置异常处理器，隐藏控制台窗口，调用 <code>Analyze</code> 函数并创建主线程。</li>
</ul>
</li>
<li><p><strong>DLL 相关函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>****DLL 的入口点，根据不同的调用原因执行相应的操作。</li>
</ul>
</li>
</ol>
<p>上线模块中 内核管理内容</p>
<p>文件解读</p>
<ol>
<li><code>unsigned int __stdcall Loop_DllManager(void* pVoid);</code> 函数：负责加载 DLL 并管理其生命周期，包括注册表操作和进程监控。</li>
<li><code>CKernelManager::CKernelManager(ISocketBase* pClient, BOOL bpuppet);</code> 构造函数：初始化 CKernelManager 对象，设置工作线程和是否为木偶模式。</li>
<li><code>CKernelManager::~CKernelManager();</code> 析构函数：释放工作线程的句柄，清理资源。</li>
<li><code>void CKernelManager::runbin();</code> 函数：启动工作线程并在启动后断开连接。</li>
<li><code>void CKernelManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的数据，进行注册表读写和 DLL 运行。</li>
<li><code>BOOL buildremoteprocess(byte* data, int size, PROCESS_INFORMATION* pi);</code> 函数：创建远程进程并将数据写入其内存。</li>
<li><code>bool pid_is_running(DWORD pid);</code> 函数：检查指定进程 ID 是否仍在运行。</li>
<li><code>int memfind(const char* mem, const char* str, int sizem, int sizes);</code> 函数：在内存中查找指定字符串的位置。</li>
</ol>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic3.png" class="" title="pic3.png">

<h2 id="代理映射模块"><a href="#代理映射模块" class="headerlink" title="代理映射模块"></a>代理映射模块</h2><p>主要作用是实现一个网络代理插件，能够通过TCP或UDP协议与远程服务器进行通信</p>
<p><strong>函数关系调用流程图</strong></p>
<pre class="mermaid">graph TD;
    A[WinMain] --> B[SetUnhandledExceptionFilter]
    A --> C["CreateThread(MainThread)"]
    C --> D[MainThread]
    D --> E[ISocketBase::Connect]
    E --> F[CProxyManager]
    D --> G[run_event_loop]
    A --> H[DllMain]
    H --> I[Main]
    I --> D
    H --> J[run]
    J --> D</pre>

<p><strong>关键组件介绍：</strong></p>
<ul>
<li><strong>WinMain</strong>: 应用程序的入口点，设置未处理异常过滤器并创建主线程。</li>
<li><strong>MainThread</strong>: 负责初始化网络连接并处理网络通信。</li>
<li><strong>ISocketBase</strong>: 抽象基类，用于网络连接的实现（TCP或UDP）。</li>
<li><strong>CProxyManager</strong>: 管理网络代理的类。</li>
<li><strong>DllMain</strong>: DLL的入口点，处理DLL的加载和卸载。</li>
<li><strong>Main</strong>: 导出函数，用于设置代理信息并启动主线程。</li>
<li><strong>run</strong>: 导出函数，用于启动主线程以处理网络通信。</li>
</ul>
<p><strong>函数内容：</strong></p>
<ol>
<li><code>DWORD WINAPI MainThread(LPVOID dllMainThread)</code>: 主线程函数，负责初始化网络连接，循环处理网络通信。</li>
<li><code>int GenerateMiniDump(PEXCEPTION_POINTERS pExceptionPointers)</code>: 生成迷你转储文件，用于异常处理和调试。</li>
<li><code>LONG WINAPI ExceptionFilter(LPEXCEPTION_POINTERS lpExceptionInfo)</code>: 异常过滤器，处理未捕获的异常并生成转储文件。</li>
<li><code>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR szCmdLine, int iCmdShow)</code>: 应用程序入口点，设置异常处理和启动主线程。</li>
<li><code>BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</code>: DLL的入口点，处理DLL的加载和卸载。</li>
<li><code>extern &quot;C&quot; __declspec(dllexport) bool Main(TCHAR * ip, DWORD port, BOOL IsTcp, BOOL RunDllEntryProc)</code>: 导出函数，用于设置代理信息并启动主线程。</li>
<li><code>extern &quot;C&quot; __declspec(dllexport) bool run()</code>: 导出函数，用于启动主线程以处理网络通信。</li>
</ol>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>该代码实现了一个文件管理器类 CFileManager，用于处理文件的上传、下载、删除、压缩等操作，并与远程客户端进行通信。</p>
<ol>
<li><strong><code>CFileManager::CFileManager(ISocketBase* pClient)</code></strong> 函数：构造函数，初始化文件管理器，设置桌面和线程，分配内存并发送驱动器列表。</li>
<li><strong><code>CFileManager::~CFileManager()</code></strong> 函数：析构函数，清理资源，关闭文件句柄，释放内存。</li>
<li><strong><code>void CFileManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code></strong> 函数：处理接收到的数据，根据命令类型调用相应的处理函数。</li>
<li><strong><code>bool CFileManager::MakeSureDirectoryPathExists(LPCTSTR pszDirPath)</code></strong> 函数：确保指定的目录路径存在，如果不存在则创建。</li>
<li><strong><code>BOOL CFileManager::OpenFile(LPCTSTR lpFile, INT nShowCmd)</code></strong> 函数：打开指定的文件，使用注册表查找文件关联的程序。</li>
<li><strong><code>HANDLE CFileManager::ImpersonateLoggedOnUserWrapper()</code></strong> 函数：获取当前登录用户的令牌，以便进行用户模拟。</li>
<li><strong><code>UINT CFileManager::SendDriveList()</code></strong> 函数：获取并发送当前系统的驱动器列表及其属性。</li>
<li><strong><code>UINT CFileManager::SendFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的文件列表。</li>
<li><strong><code>bool CFileManager::DeleteDirectory(LPCTSTR lpszDirectory)</code></strong> 函数：删除指定的目录及其内容。</li>
<li><strong><code>void CFileManager::SendToken(BYTE token)</code></strong> 函数：发送特定的令牌，用于标识操作的状态。</li>
<li><strong><code>void CFileManager::SendNetHood()</code></strong> 函数：发送网络邻居的信息。</li>
<li><strong><code>void CFileManager::SendSearchFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的搜索文件列表。</li>
<li><strong><code>void CFileManager::CreateFolder(LPCTSTR lpszFolder)</code></strong> 函数：创建一个新的文件夹。</li>
<li><strong><code>void CFileManager::Rename(LPCTSTR lpszNewName)</code></strong> 函数：重命名文件或文件夹。</li>
<li><strong><code>void CFileManager::WriteLocalRecvFile(LPBYTE lpBuffer, UINT nSize)</code></strong> 函数：将接收到的数据写入本地文件。</li>
<li><strong><code>void CFileManager::UploadToRemote(LPBYTE lpBuffer)</code></strong> 函数：将文件上传到远程服务器。</li>
<li><strong><code>void CFileManager::StopTransfer(LPBYTE lpBuffer)</code></strong> 函数：停止文件传输。</li>
<li><strong><code>void CFileManager::StartZIP()</code></strong> 函数：开始压缩文件的操作。</li>
<li><strong><code>void CFileManager::StopZIPTheard()</code></strong> 函数：停止压缩线程。</li>
<li><strong><code>void CFileManager::SendFileInfo(LPCTSTR lpszFileName, LPCTSTR lpszFileType)</code></strong> 函数：发送文件信息。</li>
<li><strong><code>void CFileManager::encfile(char* filePath)</code></strong> 函数：对指定文件进行加密。</li>
<li><strong><code>void CFileManager::decryptfile(char* filePath)</code></strong> 函数：对指定文件进行解密。</li>
<li><strong><code>void CFileManager::FnDelPathFile(TCHAR* filePath)</code></strong> 函数：强制删除指定路径的文件。</li>
<li><strong><code>void CFileManager::SendFileData(LPBYTE lpBuffer)</code></strong> 函数：发送文件数据。</li>
<li><strong><code>void CFileManager::CreateLocalRecvFile(LPBYTE lpBuffer)</code></strong> 函数：创建本地接收文件。</li>
<li><strong><code>void CFileManager::SetTransferMode(LPBYTE lpBuffer)</code></strong> 函数：设置文件传输模式。</li>
<li><strong><code>void CFileManager::GetBotId(char* desktopName)</code></strong> 函数：获取机器的Bot ID。</li>
<li><strong><code>void CFileManager::SendFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的文件列表。</li>
<li><strong><code>void CFileManager::SendSearchDate(LPBYTE lpBuffer)</code></strong> 函数：发送搜索日期信息。</li>
<li><strong><code>void CFileManager::SendRecentFiles()</code></strong> 函数：发送最近使用的文件列表。</li>
</ol>
<p>以上是文件中各个功能模块的简要代码及其含义。每个函数的作用都与文件管理相关，涉及文件的创建、删除、传输、压缩等操作。</p>
<p>MasterEncoder.cpp实现了一个PDF文件的加密和解密功能，使用异或操作和自定义签名来保护文件内容。</p>
<pre class="mermaid">graph TD;
    A[readPDF] --> B[encodePDF]
    A --> C[decodePDF]
    B --> D[writePDF]
    C --> D
    D --> E[decode]</pre>

<p><strong>关键组件介绍：</strong></p>
<ul>
<li><strong>readPDF</strong>: 读取PDF文件并返回其内容和大小。</li>
<li><strong>encodePDF</strong>: 对PDF文件进行加密处理。</li>
<li><strong>decodePDF</strong>: 对PDF文件进行解密处理。</li>
<li><strong>writePDF</strong>: 将处理后的数据写入新的PDF文件。</li>
<li><strong>decode</strong>: 解密数据，返回解密后的内容。</li>
</ul>
<ol>
<li><code>MasterEncoder::readPDF(const string&amp; filepath, long&amp; size)</code>: 函数：读取指定路径的PDF文件，返回文件内容和大小。</li>
<li><code>MasterEncoder::writePDF(const string&amp; filePath, unsigned char* data, long size)</code>: 函数：将数据写入指定路径的PDF文件。</li>
<li><code>MasterEncoder::encodePDF(const string&amp; pdfPath, const string&amp; savePath)</code>: 函数：对PDF文件进行加密，并保存到指定路径。</li>
<li><code>MasterEncoder::decodePDF(const string&amp; pdfPath, const string&amp; savePath)</code>: 函数：对PDF文件进行解密，并保存到指定路径。</li>
<li><code>MasterEncoder::decode(const string&amp; pdfPath, long&amp; size)</code>: 函数：读取PDF文件并解密，返回解密后的数据。</li>
</ol>
<h2 id="查注册表模块"><a href="#查注册表模块" class="headerlink" title="查注册表模块"></a>查注册表模块</h2><p>一个注册表管理器类 <code>CRegeditManager</code>，用于处理与 Windows 注册表的交互，包括创建、删除、修改注册表键值等操作。</p>
<pre class="mermaid">graph LR;
    A[OnReceive] -->|接收命令| B[EnumReg]
    A -->|接收命令| C[CreateKey]
    A -->|接收命令| D[DeleteKey]
    A -->|接收命令| E[Rename]
    A -->|接收命令| F[DeleteVal]
    A -->|接收命令| G[CreatSTR]
    A -->|接收命令| H[CreatDWORD]
    A -->|接收命令| I[CreatEXSTR]

    B --> J[GetRegInfo]
    C --> K[MyCreateKey]
    D --> L[MyDeleteKey]
    E --> M[WriteValue]
    F --> N[DeleteValue]
    G --> O[WriteValue]
    H --> P[WriteValue]
    I --> Q[WriteBuf]</pre>

<p>关键组件介绍</p>
<ul>
<li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li>
<li><strong>EnumReg</strong>: 枚举注册表键，获取注册表信息。</li>
<li><strong>CreateKey</strong>: 创建新的注册表键。</li>
<li><strong>DeleteKey</strong>: 删除指定的注册表键。</li>
<li><strong>Rename</strong>: 重命名注册表键。</li>
<li><strong>DeleteVal</strong>: 删除注册表值。</li>
<li><strong>CreatSTR</strong>: 创建字符串类型的注册表值。</li>
<li><strong>CreatDWORD</strong>: 创建 DWORD 类型的注册表值。</li>
<li><strong>CreatEXSTR</strong>: 创建扩展字符串类型的注册表值。</li>
</ul>
<ol>
<li><code>CRegeditManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code> 函数：处理接收到的数据，根据不同的命令类型调用相应的处理函数。</li>
<li><code>CRegeditManager::EnumReg(BYTE bToken, LPBYTE lpBuffer)</code> 函数：枚举注册表键，获取注册表信息并发送回客户端。</li>
<li><code>CRegeditManager::CreateKey(LPBYTE lpBuffer)</code> 函数：创建新的注册表键。</li>
<li><code>CRegeditManager::DeleteKey(LPBYTE lpBuffer)</code> 函数：删除指定的注册表键。</li>
<li><code>CRegeditManager::Rename(char* buf)</code> 函数：重命名注册表键。</li>
<li><code>CRegeditManager::DeleteVal(char* buf)</code> 函数：删除指定的注册表值。</li>
<li><code>CRegeditManager::CreatSTR(char* buf)</code> 函数：创建字符串类型的注册表值。</li>
<li><code>CRegeditManager::CreatDWORD(char* buf)</code> 函数：创建 DWORD 类型的注册表值。</li>
<li><code>CRegeditManager::CreatEXSTR(char* buf)</code> 函数：创建扩展字符串类型的注册表值。</li>
<li><code>CRegeditManager::WriteValue(LPCTSTR lpValueName, LPCTSTR lpValue)</code> 函数：写入字符串类型的注册表值。</li>
<li><code>CRegeditManager::WriteBuf(LPCTSTR lpValueName, LPCTSTR lpValue)</code> 函数：写入扩展字符串类型的注册表值。</li>
<li><code>CRegeditManager::OpenKey(LPCTSTR lpSubKey)</code> 函数：打开指定的注册表键。</li>
<li><code>CRegeditManager::DeleteValue(LPCTSTR lpValueName)</code> 函数：删除指定的注册表值。</li>
<li><code>CRegeditManager::SendError()</code> 函数：发送错误信息给客户端。</li>
<li><code>CRegeditManager::SendSucceed()</code> 函数：发送成功信息给客户端。</li>
</ol>
<h2 id="注入模块"><a href="#注入模块" class="headerlink" title="注入模块"></a>注入模块</h2><h3 id="InjectManager"><a href="#InjectManager" class="headerlink" title="InjectManager"></a>InjectManager</h3><p>一个注入管理器，负责管理进程注入、文件传输和进程信息的获取。</p>
<pre class="mermaid">graph LR;
    A[开始] --> B[接收数据]
    B --> C{数据类型}
    C -->|TOKEN_HEARTBEAT| D[忽略]
    C -->|COMMAND_INJECT_PROCESS| E[发送进程列表]
    C -->|COMMAND_INJECT_FILE_INFO| F[创建接收文件]
    C -->|COMMAND_INJECT_FILE_DATA| G[写入接收文件]
    C -->|COMMAND_INJECT_REMOTEFILE_RUN| H[运行远程文件]
    C -->|COMMAND_INJECT_REMOTEFILE_DEL| I[删除文件]
    C -->|COMMAND_INJECT_SETDLL| J[设置DLL路径]
    C -->|COMMAND_INJECT_MODE| K[注入模式处理]
    C -->|其他| L[处理其他命令]
    D --> M[结束]
    E --> M
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> M
    L --> M</pre>

<ul>
<li><strong>接收数据</strong>：从客户端接收指令。</li>
<li><strong>数据类型判断</strong>：根据接收到的数据类型决定执行的操作。</li>
<li><strong>发送进程列表</strong>：获取并发送当前进程列表。</li>
<li><strong>创建接收文件</strong>：为接收文件创建本地文件。</li>
<li><strong>写入接收文件</strong>：将接收到的数据写入文件。</li>
<li><strong>运行远程文件</strong>：执行指定的远程文件。</li>
<li><strong>删除文件</strong>：删除指定的文件。</li>
<li><strong>注入模式处理</strong>：根据不同的注入模式执行相应的注入操作。</li>
</ul>
<ol>
<li><code>CInjectManager::CInjectManager(ISocketBase* pClient)</code>：构造函数，初始化注入管理器，设置标志和接收数据。</li>
<li><code>CInjectManager::~CInjectManager()</code>：析构函数，清理资源，退出BoxedAppSDK。</li>
<li><code>void CInjectManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>：处理接收到的数据，根据不同的命令执行相应的操作。</li>
<li><code>void CInjectManager::SendProcessList()</code>：获取当前进程列表并发送给客户端。</li>
<li><code>BOOL CInjectManager::DebugPrivilege(const TCHAR* PName, BOOL bEnable)</code>：调整进程的调试权限。</li>
<li><code>BOOL CInjectManager::GetProcessUserName(HANDLE hProcess, TCHAR* strProcessUser)</code>：获取指定进程的用户名。</li>
<li><code>BOOL CInjectManager::DosPathToNtPath(LPTSTR pszDosPath, LPTSTR pszNtPath)</code>：将DOS路径转换为NT路径。</li>
<li><code>bool CInjectManager::Is64BitOS()</code>：检查操作系统是否为64位。</li>
<li><code>bool CInjectManager::Is64BitPorcess(DWORD dwProcessID)</code>：检查指定进程是否为64位。</li>
<li><code>LPBYTE CInjectManager::getProcessList()</code>：获取当前系统的进程列表。</li>
<li><code>void CInjectManager::SendError(TCHAR* Terror)</code>：发送错误信息给客户端。</li>
<li><code>void CInjectManager::CreateLocalRecvFile(LPBYTE lpBuffer)</code>：创建接收文件的准备工作。</li>
<li><code>void CInjectManager::WriteLocalRecvFile(LPBYTE lpBuffer, UINT nSize)</code>：将接收到的数据写入本地文件。</li>
<li><code>void CInjectManager::WriteOk()</code>：确认文件写入成功。</li>
<li><code>void CInjectManager::WriteDllandSetPath(BOOL isx86, TCHAR* lpBuffer)</code>：写入DLL并设置路径。</li>
<li><code>void CInjectManager::RunExe(LPBYTE lpBuffer)</code>：运行指定的可执行文件。</li>
<li><code>void CInjectManager::RunExeuacArg(LPBYTE lpBuffer)</code>：运行带参数的可执行文件。</li>
<li><code>void CInjectManager::DelFile(LPBYTE lpBuffer)</code>：删除指定的文件。</li>
<li><code>void CInjectManager::Inject_dll()</code>：执行DLL注入操作。</li>
<li><code>void CInjectManager::Inject_shellcode()</code>：执行Shellcode注入操作。</li>
</ol>
<h3 id="memorymodule"><a href="#memorymodule" class="headerlink" title="memorymodule"></a>memorymodule</h3><p><em>MemoryModule.c</em></p>
<p>公开模块：<a target="_blank" rel="noopener" href="https://github.com/fancycode/MemoryModule/blob/master/MemoryModule.c">https://github.com/fancycode/MemoryModule/blob/master/MemoryModule.c</a></p>
<h3 id="注入管理"><a href="#注入管理" class="headerlink" title="注入管理"></a>注入管理</h3><p>该代码实现了一个注入管理器，主要用于通过 TCP 或 UDP 连接到指定的地址和端口，并在连接后执行相应的操作。</p>
<pre class="mermaid">graph TD;
    A[WinMain] --> B[SetUnhandledExceptionFilter]
    A --> C["CreateThread(MainThread)"]
    C --> D[MainThread]
    D --> E["Connect(Socket)"]
    E --> F[Run Event Loop]
    D --> G[ExitProcess]
    A --> H[DllMain]
    H --> I[Main]
    I --> D
    H --> J[run]
    J --> D</pre>

<ul>
<li><strong>WinMain</strong>: 应用程序的入口点，设置未处理异常过滤器并创建主线程。</li>
<li><strong>MainThread</strong>: 负责建立网络连接并处理网络通信。</li>
<li><strong>DllMain</strong>: DLL 的入口点，处理 DLL 的加载和卸载。</li>
<li><strong>Main</strong>: 用于初始化连接参数并启动主线程。</li>
<li><strong>run</strong>: 启动主线程以处理网络通信。</li>
</ul>
<ol>
<li><code>DWORD WINAPI MainThread(LPVOID dllMainThread)</code>: 主线程函数，负责初始化网络连接，循环处理网络通信。</li>
<li><code>int GenerateMiniDump(PEXCEPTION_POINTERS pExceptionPointers)</code>: 生成小型转储文件，用于异常处理和调试。</li>
<li><code>LONG WINAPI ExceptionFilter(LPEXCEPTION_POINTERS lpExceptionInfo)</code>: 异常过滤器，处理未捕获的异常并生成转储文件。</li>
<li><code>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR szCmdLine, int iCmdShow)</code>: 应用程序入口点，设置异常处理并启动主线程。</li>
<li><code>BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</code>: DLL 的入口点，处理 DLL 的加载和卸载。</li>
<li><code>extern &quot;C&quot; __declspec(dllexport) bool Main(TCHAR * ip, DWORD port, BOOL IsTcp, BOOL RunDllEntryProc)</code>: 用于初始化连接参数并启动主线程。</li>
<li><code>extern &quot;C&quot; __declspec(dllexport) bool run()</code>: 启动主线程以处理网络通信。</li>
</ol>
<h2 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h2><p>键盘记录器和剪贴板监控器，能够捕获键盘输入和剪贴板内容，并将其发送到指定的服务器。</p>
<pre class="mermaid">graph TD;
    A[主线程] --> B[键盘记录线程]
    A --> C[剪贴板监控线程]
    B --> D[获取键盘输入]
    C --> E[检查剪贴板变化]
    D --> F[发送键盘数据]
    E --> G[发送剪贴板数据]</pre>

<ul>
<li><strong>主线程</strong>：初始化程序并启动键盘记录和剪贴板监控线程。</li>
<li><strong>键盘记录线程</strong>：负责捕获键盘输入并将其发送到服务器。</li>
<li><strong>剪贴板监控线程</strong>：监控剪贴板内容的变化，并在变化时发送数据。</li>
</ul>
<ol>
<li><code>unsigned int __stdcall KeyLogger(LPVOID lparam);</code> 函数：键盘记录线程，捕获键盘输入并发送到服务器。</li>
<li><code>unsigned int __stdcall ClipboardLogger(LPVOID lparam);</code> 函数：剪贴板监控线程，检查剪贴板内容变化并发送更新。</li>
<li><code>CKeyboardManager::CKeyboardManager(ISocketBase* pClient);</code> 构造函数：初始化键盘管理器，设置线程和资源。</li>
<li><code>CKeyboardManager::~CKeyboardManager();</code> 析构函数：清理资源，关闭线程和释放内存。</li>
<li><code>void CKeyboardManager::SendOnlineDate(TCHAR* p_Buffer);</code> 函数：发送在线数据到服务器。</li>
<li><code>BOOL CKeyboardManager::IsWindowsFocusChange();</code> 函数：检查当前窗口焦点是否变化，并记录变化。</li>
<li><code>BOOL CKeyboardManager::IsClipboardChange();</code> 函数：检查剪贴板内容是否变化，并处理变化。</li>
<li><code>void CKeyboardManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的命令和数据。</li>
<li><code>void CKeyboardManager::UpdateLocalClipboard(char* buf, int len);</code> 函数：更新本地剪贴板内容。</li>
<li><code>void CKeyboardManager::SendErroe(TCHAR* data);</code> 函数：发送错误信息到服务器。</li>
</ol>
<h2 id="驱动模块"><a href="#驱动模块" class="headerlink" title="驱动模块"></a>驱动模块</h2><h3 id="内核管理"><a href="#内核管理" class="headerlink" title="内核管理"></a>内核管理</h3><p>内核管理器类 <code>CKernelManager</code>，用于处理与内核相关的命令和状态管理，包括初始化、接收命令、设置状态、注册值操作等。</p>
<pre class="mermaid">graph LR;
    A[CKernelManager] -->|OnReceive| B[COMMAND_KERNEL_INIT]
    A -->|OnReceive| C[COMMAND_KERNEL_GETSTATE]
    A -->|OnReceive| D[COMMAND_KERNEL_SETSTATE_CONTINUE]
    A -->|OnReceive| E[COMMAND_KERNEL_SETSTATE_STOP]
    A -->|OnReceive| F[COMMAND_KERNEL_RUNCOMMAND]
    A -->|OnReceive| G[COMMAND_KERNEL_DELCOMMAND]
    A -->|OnReceive| H[COMMAND_KERNEL_WRITERCOMMAND]
    A -->|OnReceive| I[COMMAND_KERNEL_BACKDOOR]
    A -->|OnReceive| J[COMMAND_KERNEL_DEL]
    A -->|OnReceive| K[COMMAND_KERNEL_INJECT]
    A -->|OnReceive| L[COMMAND_KERNEL_SETSTATE_PROCESS]</pre>

<ul>
<li><strong>CKernelManager</strong>: 主要类，负责管理内核相关的操作。</li>
<li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li>
<li><strong>各命令处理函数</strong>: 处理不同的内核命令，如初始化、获取状态、设置状态等。</li>
</ul>
<ol>
<li><code>CKernelManager::CKernelManager(ISocketBase* pClient)</code>: 构造函数，初始化内核管理器并设置初始状态。</li>
<li><code>CKernelManager::~CKernelManager()</code>: 析构函数，清理资源。</li>
<li><code>void CKernelManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的命令，根据命令类型调用相应的处理逻辑。</li>
<li><code>void CKernelManager::Initialize()</code>: 初始化内核管理器，设置必要的文件和服务。</li>
<li><code>void CKernelManager::SetRegvalue(TCHAR* name, TCHAR* val, int nSize)</code>: 设置注册表值。</li>
<li><code>void CKernelManager::GetState()</code>: 获取当前状态并返回信息。</li>
<li><code>void CKernelManager::SetState(HidActiveState state)</code>: 设置内核的活动状态。</li>
<li><code>BOOL CKernelManager::IsWindowsX64()</code>: 检查操作系统是否为64位。</li>
<li><code>void CKernelManager::SendReturnInfo(BYTE mode, TCHAR* info)</code>: 发送返回信息。</li>
<li><code>HidRegRootTypes CKernelManager::GetRegType(wstring&amp; path)</code>: 获取注册表路径的类型。</li>
<li><code>HidContext CKernelManager::GetContext()</code>: 获取当前的上下文。</li>
<li><code>void CKernelManager::runcommand(int argc, TCHAR* Command)</code>: 执行指定的命令。</li>
<li><code>void CKernelManager::delcommand(int argc, TCHAR* Command)</code>: 删除指定的命令。</li>
<li><code>void CKernelManager::writercommand(int argc, TCHAR* Command)</code>: 写入指定的命令。</li>
<li><code>bool CKernelManager::GetMultiStrValue(const wchar_t* name, std::vector&lt;std::wstring&gt;&amp; strs)</code>: 获取多字符串值。</li>
<li><code>bool CKernelManager::SetMultiStrValue(const wchar_t* name, const std::vector&lt;std::wstring&gt;&amp; strs)</code>: 设置多字符串值。</li>
<li><code>int CKernelManager::memfind(const char* mem, const char* str, int sizem, int sizes)</code>: 在内存中查找字符串。</li>
<li><code>BOOL CKernelManager::SetInternetStatus(bool enable)</code>: 设置互联网状态。</li>
</ol>
<h3 id="CloseNet-提权和伪装模块"><a href="#CloseNet-提权和伪装模块" class="headerlink" title="CloseNet 提权和伪装模块"></a>CloseNet 提权和伪装模块</h3><p>一系列与进程和权限管理相关的功能，主要用于在Windows环境中进行进程的伪装、句柄泄露和调试权限的管理。</p>
<pre class="mermaid">graph LR;
    A[EnableDebugPrivilege] --> B[MalSeclogonPPIDSpoofing]
    B --> C[FindTokenHandlesInProcess]
    B --> D[CreateProcessWithTokenW]
    B --> E[CreateProcessWithLogonW]
    A --> F[MalSeclogonLeakHandles]
    F --> G[FindProcessHandlesInTargetProcess]
    F --> H[CreateFileLock]
    F --> I[LeakLsassHandleInSeclogonWithRaceCondition]
    I --> J[ReplaceNtOpenProcess]
    I --> K[RestoreNtOpenProcess]</pre>

<ul>
<li><strong>EnableDebugPrivilege</strong>: 启用调试权限，允许后续操作进行更高权限的操作。</li>
<li><strong>MalSeclogonPPIDSpoofing</strong>: 伪装指定进程的PID，尝试使用伪装的PID创建新进程。</li>
<li><strong>FindTokenHandlesInProcess</strong>: 查找目标进程中的令牌句柄，以便后续的进程创建。</li>
<li><strong>CreateProcessWithTokenW</strong>: 使用找到的令牌句柄创建新进程。</li>
<li><strong>CreateProcessWithLogonW</strong>: 如果令牌句柄不可用，则使用登录凭据创建新进程。</li>
<li><strong>MalSeclogonLeakHandles</strong>: 泄露目标进程的句柄，进行后续的操作。</li>
<li><strong>FindProcessHandlesInTargetProcess</strong>: 查找目标进程中的句柄。</li>
<li><strong>CreateFileLock</strong>: 创建文件锁以防止其他进程访问。</li>
<li><strong>LeakLsassHandleInSeclogonWithRaceCondition</strong>: 利用竞争条件泄露lsass进程的句柄。</li>
<li><strong>ReplaceNtOpenProcess</strong>: 替换NtOpenProcess函数以返回泄露的句柄。</li>
<li><strong>RestoreNtOpenProcess</strong>: 恢复NtOpenProcess函数的原始代码。</li>
</ul>
<ol>
<li><code>BOOL SetPrivilege(HANDLE hToken, wchar_t* lpszPrivilege, BOOL bEnablePrivilege);</code> 函数：设置指定的权限，允许或禁用特定的系统权限。</li>
<li><code>void EnableDebugPrivilege(BOOL enforceCheck);</code> 函数：启用调试权限，如果强制检查失败则退出程序。</li>
<li><code>BOOL EnableImpersonatePrivilege();</code> 函数：启用模拟权限，返回是否成功。</li>
<li><code>void SpoofPidTeb(DWORD spoofedPid, PDWORD originalPid, PDWORD originalTid);</code> 函数：伪装当前线程的PID和TID。</li>
<li><code>void RestoreOriginalPidTeb(DWORD originalPid, DWORD originalTid);</code> 函数：恢复原始的PID和TID。</li>
<li><code>NTSTATUS QueryObjectTypesInfo(__out POBJECT_TYPES_INFORMATION* TypesInfo);</code> 函数：查询对象类型信息。</li>
<li><code>NTSTATUS GetTypeIndexByName(__in PCUNICODE_STRING TypeName, __out PULONG TypeIndex);</code> 函数：根据类型名称获取对象类型索引。</li>
<li><code>void FindProcessHandlesInTargetProcess(DWORD targetPid, HANDLE* handlesToLeak, PDWORD handlesToLeakCount);</code> 函数：查找目标进程中的句柄。</li>
<li><code>void FindTokenHandlesInProcess(DWORD targetPid, HANDLE* tokenHandles, PDWORD tokenHandlesLen);</code> 函数：查找目标进程中的令牌句柄。</li>
<li><code>void MalSeclogonPPIDSpoofing(int pid, wchar_t* cmdline);</code> 函数：伪装指定PID并尝试创建新进程。</li>
<li><code>BOOL FileExists(LPCTSTR szPath);</code> 函数：检查指定路径的文件是否存在。</li>
<li><code>void MalSeclogonLeakHandles(int lsassPid, wchar_t* dumpPath);</code> 函数：泄露lsass进程的句柄并创建转储文件。</li>
<li><code>void CreateFileLock(HANDLE hFile, LPOVERLAPPED overlapped);</code> 函数：创建文件锁以防止其他进程访问。</li>
<li><code>DWORD WINAPI ThreadSeclogonLock(LPVOID lpParam);</code> 函数：线程函数，用于执行伪装操作。</li>
<li><code>void LeakLsassHandleInSeclogonWithRaceCondition(DWORD lsassPid);</code> 函数：利用竞争条件泄露lsass进程的句柄。</li>
<li><code>void ReplaceNtOpenProcess(HANDLE leakedHandle, char* oldCode, int* oldCodeSize);</code> 函数：替换NtOpenProcess以返回泄露的句柄。</li>
<li><code>void RestoreNtOpenProcess(char* oldCode, int oldCodeSize);</code> 函数：恢复NtOpenProcess的原始代码。</li>
<li><code>void MalSeclogonDumpLsassFromLeakedHandles(int lsassPid, wchar_t* dumpPath, BOOL useLsassClone);</code> 函数：从泄露的句柄中转储lsass进程。</li>
<li><code>DWORD GetPidUsingFilePath(wchar_t* processBinaryPath);</code> 函数：根据进程的二进制路径获取进程ID。</li>
</ol>
<h3 id="隐藏文件-HiddenLib"><a href="#隐藏文件-HiddenLib" class="headerlink" title="隐藏文件  HiddenLib"></a>隐藏文件  HiddenLib</h3><p>该代码实现了一个隐藏库，提供了对设备的控制和管理功能，包括隐藏文件、注册表项和进程等。</p>
<pre class="mermaid">graph TD;
    A[Hid_Initialize] --> B[Hid_InitializeWithNoConnection]
    B --> C[GetProcAddress]
    A --> D[CreateFileW]
    D --> E[Hid_Destroy]
    E --> F[CloseHandle]
    A --> G[SendIoctl_HideObjectPacket]
    G --> H[DeviceIoControl]
    H --> I[SendIoctl_UnhideObjectPacket]
    I --> H</pre>

<ul>
<li><strong>Hid_Initialize</strong>: 初始化 HID 设备，确保所需的函数指针被正确加载。</li>
<li><strong>Hid_Destroy</strong>: 释放 HID 设备的资源。</li>
<li><strong>SendIoctl_HideObjectPacket</strong>: 发送 IOCTL 命令以隐藏对象。</li>
<li><strong>DeviceIoControl</strong>: 与设备驱动程序进行通信的核心函数。</li>
</ul>
<ol>
<li><code>HidStatus _API Hid_InitializeWithNoConnection();</code> 函数：初始化 HID 设备而不建立连接，加载必要的函数指针。</li>
<li><code>HidStatus _API Hid_Initialize(PHidContext pcontext, const wchar_t* deviceName);</code> 函数：初始化 HID 设备并打开设备文件。</li>
<li><code>void _API Hid_Destroy(HidContext context);</code> 函数：释放 HID 设备的资源。</li>
<li><code>bool ConvertToNtPath(const wchar_t* path, wchar_t* normalized, size_t normalizedLen);</code> 函数：将 DOS 路径转换为 NT 路径。</li>
<li><code>bool NormalizeRegistryPath(HidRegRootTypes root, const wchar_t* key, wchar_t* normalized, size_t normalizedLen);</code> 函数：标准化注册表路径。</li>
<li><code>HidStatus AllocNormalizedPath(const wchar_t* path, wchar_t** normalized);</code> 函数：分配标准化路径的内存。</li>
<li><code>HidStatus SendIoctl_HideObjectPacket(PHidContextInternal context, const wchar_t* path, unsigned short type, HidObjId* objId);</code> 函数：发送 IOCTL 命令以隐藏对象。</li>
<li><code>HidStatus SendIoctl_UnhideObjectPacket(PHidContextInternal context, unsigned short type, HidObjId objId);</code> 函数：发送 IOCTL 命令以取消隐藏对象。</li>
<li><code>HidStatus SendIoctl_AddPsObjectPacket(PHidContextInternal context, const wchar_t* path, unsigned short type, HidPsInheritTypes inheritType, bool applyForProcess, HidObjId* objId);</code> 函数：添加进程对象。</li>
<li><code>HidStatus _API Hid_SetState(HidContext context, HidActiveState state);</code> 函数：设置 HID 设备的状态。</li>
<li><code>HidStatus _API Hid_GetState(HidContext context, HidActiveState* pstate);</code> 函数：获取 HID 设备的状态。</li>
<li><code>HidStatus _API Hid_AddHiddenFile(HidContext context, const wchar_t* filePath, HidObjId* objId);</code> 函数：添加隐藏文件。</li>
<li><code>HidStatus _API Hid_RemoveHiddenFile(HidContext context, HidObjId objId);</code> 函数：移除隐藏文件。</li>
<li><code>HidStatus _API Hid_NormalizeFilePath(const wchar_t* filePath, wchar_t* normalized, size_t normalizedLen);</code> 函数：标准化文件路径。</li>
</ol>
<h2 id="远程shell管理-shellmanager"><a href="#远程shell管理-shellmanager" class="headerlink" title="远程shell管理 shellmanager"></a>远程shell管理 shellmanager</h2><p> <code>CShellManager</code> 类，负责管理与外部命令行进程的交互，包括创建管道、启动进程、读取输出和监控进程状态。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre class="mermaid">graph TD;
    A[CShellManager] -->|创建| B[管道]
    A -->|启动| C[cmd.exe]
    A -->|读取| D[输出]
    A -->|监控| E[进程状态]
    D -->|发送| F[客户端]</pre>

<ul>
<li><strong>CShellManager</strong>: 管理与命令行进程的交互。</li>
<li><strong>管道</strong>: 用于进程间通信。</li>
<li><strong>cmd.exe</strong>: 被启动的命令行进程。</li>
<li><strong>输出</strong>: 从命令行进程读取的数据。</li>
<li><strong>进程状态</strong>: 监控命令行进程的运行状态。</li>
</ul>
<ol>
<li><code>CShellManager::CShellManager(ISocketBase* pClient)</code>: 构造函数，初始化管道和启动命令行进程。</li>
<li><code>CShellManager::~CShellManager()</code>: 析构函数，清理资源，终止线程和进程。</li>
<li><code>void CShellManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的数据，发送到命令行进程。</li>
<li><code>unsigned CShellManager::ReadPipeThread(LPVOID lparam)</code>: 读取管道数据的线程函数，处理命令行进程的输出。</li>
<li><code>unsigned CShellManager::MonitorThread(LPVOID lparam)</code>: 监控命令行进程和读取线程的状态，确保它们正常运行。</li>
</ol>
<h2 id="远控CC信息交互"><a href="#远控CC信息交互" class="headerlink" title="远控CC信息交互"></a>远控CC信息交互</h2><p>聊天管理器，负责处理聊天窗口的创建、消息发送、键盘钩子设置以及与系统交互的功能。</p>
<pre class="mermaid">graph TD;
    A[CChatManager] -->|创建| B[ChatDialogProc]
    A -->|发送消息| C[OnReceive]
    A -->|设置钩子| D[SetHook]
    A -->|解除钩子| E[UnSetHook]
    B -->|处理消息| F[WM_COMMAND]
    F -->|发送按钮| G[SendMessage]
    F -->|关闭按钮| H[WM_CLOSE]</pre>

<ul>
<li><strong>CChatManager</strong>: 聊天管理器类，负责聊天窗口的管理和消息处理。</li>
<li><strong>ChatDialogProc</strong>: 聊天对话框的消息处理函数，处理用户输入和按钮点击事件。</li>
<li><strong>OnReceive</strong>: 处理接收到的消息并更新聊天记录。</li>
<li><strong>SetHook</strong>: 设置键盘钩子以拦截特定的键盘事件。</li>
<li><strong>UnSetHook</strong>: 解除键盘钩子，恢复正常的键盘操作。</li>
</ul>
<ol>
<li><code>CChatManager::CChatManager(ISocketBase* pClient);</code> 函数：构造函数，初始化聊天管理器并启动消息循环。</li>
<li><code>CChatManager::~CChatManager();</code> 函数：析构函数，清理资源并解除钩子。</li>
<li><code>DWORD WINAPI CChatManager::MessageLoopProc(LPVOID lParam);</code> 函数：消息循环处理函数，创建聊天对话框并处理消息。</li>
<li><code>INT_PTR CALLBACK CChatManager::ChatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);</code> 函数：聊天对话框的回调函数，处理对话框的消息。</li>
<li><code>void CChatManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的聊天消息并更新聊天记录。</li>
<li><code>void SetHook();</code> 函数：设置键盘钩子以拦截特定的键盘事件。</li>
<li><code>void UnSetHook();</code> 函数：解除键盘钩子，恢复正常的键盘操作。</li>
<li><code>DWORD GetWinlogonPid();</code> 函数：获取系统winlogon进程的PID。</li>
<li><code>LRESULT CALLBACK KeyBoardProc(int code, WPARAM wParam, LPARAM lParam);</code> 函数：键盘钩子的回调函数，处理键盘事件。</li>
</ol>
<h2 id="解密数据模块"><a href="#解密数据模块" class="headerlink" title="解密数据模块"></a>解密数据模块</h2><h3 id="解密浏览器数据"><a href="#解密浏览器数据" class="headerlink" title="解密浏览器数据"></a>解密浏览器数据</h3><p>该代码文件 <code>GetBrowserInfo.cpp</code> 主要用于获取不同浏览器（如 Chrome、QQ、Edge 和 Speed 360）的用户数据，包括登录信息和 cookies。它通过访问特定的文件路径和数据库来提取这些信息。</p>
<pre class="mermaid">graph LR;
    A[GetBrowserInfo] --> B[GetFullPathFromRelativeToBro]
    A --> C[GetCookies]
    A --> D[GetAllCookies]
    A --> E[GetAllData]
    A --> F[GetData]
    A --> G[Find360SPLoginDB]
    A --> H[GetMasterKey]
    A --> I[ParseEncryptedKey]</pre>

<ul>
<li><strong>GetBrowserInfo</strong>: 主类，负责初始化和管理浏览器信息的获取。</li>
<li><strong>GetFullPathFromRelativeToBro</strong>: 生成相对于浏览器目录的完整路径。</li>
<li><strong>GetCookies</strong>: 从浏览器的 cookies 数据库中提取 cookies 信息。</li>
<li><strong>GetAllCookies</strong>: 获取所有 cookies 的入口函数。</li>
<li><strong>GetAllData</strong>: 获取所有用户数据的入口函数。</li>
<li><strong>GetData</strong>: 从登录数据数据库中提取用户登录信息。</li>
<li><strong>Find360SPLoginDB</strong>: 查找 360 浏览器的登录数据库。</li>
<li><strong>GetMasterKey</strong>: 获取解密所需的主密钥。</li>
<li><strong>ParseEncryptedKey</strong>: 解析加密密钥。</li>
</ul>
<ol>
<li><code>GetBrowserInfo::GetBrowserInfo(BroType brot)</code>: 构造函数，根据浏览器类型初始化相关路径和状态。</li>
<li><code>GetBrowserInfo::~GetBrowserInfo()</code>: 析构函数，负责清理资源。</li>
<li><code>std::string GetBrowserInfo::GetFullPathFromRelativeToBro(LPCSTR relative)</code>: 生成相对于浏览器目录的完整路径。</li>
<li><code>DWORD GetBrowserInfo::GetCookies(std::vector&lt;BrowserCookies&gt; *pBroCookies)</code>: 从 cookies 数据库中提取 cookies 信息。</li>
<li><code>BOOL GetBrowserInfo::GetAllCookies(std::vector&lt;BrowserCookies&gt; *pBroCookies)</code>: 获取所有 cookies 的入口函数。</li>
<li><code>BOOL GetBrowserInfo::GetAllData(std::vector&lt;BrowserData&gt; *pBroData)</code>: 获取所有用户数据的入口函数。</li>
<li><code>DWORD GetBrowserInfo::GetData(std::vector&lt;BrowserData&gt; *pBroData)</code>: 从登录数据数据库中提取用户登录信息。</li>
<li><code>LPCSTR GetBrowserInfo::ParseEncryptedKey(LPSTR* buf)</code>: 解析加密密钥。</li>
<li><code>bool GetBrowserInfo::GetMasterKey(DATA_BLOB* pDatab)</code>: 获取解密所需的主密钥。</li>
<li><code>void GetBrowserInfo::Find360SPLoginDB(std::string lpPath)</code>: 查找 360 浏览器的登录数据库。</li>
</ol>
<h3 id="获取360浏览器数据"><a href="#获取360浏览器数据" class="headerlink" title="获取360浏览器数据"></a>获取360浏览器数据</h3><p> <code>Get360seInfo</code> 的类，主要用于从 360 浏览器的数据库中提取用户的浏览器数据，包括账户信息和密码。</p>
<pre class="mermaid">graph TD;
    A[Get360seInfo] --> B[构造函数]
    A --> C[getData]
    C --> D[Open360Database]
    D --> E[OpenLogin360Data]
    D --> F[FindLoginDB]
    E --> G[DecryptAes]
    E --> H[Last360Uncode]</pre>

<ul>
<li><strong>Get360seInfo</strong>: 主类，负责初始化和管理数据提取过程。</li>
<li><strong>构造函数</strong>: 初始化类的成员变量并获取必要的注册表信息。</li>
<li><strong>getData</strong>: 主要数据提取函数，调用数据库打开和数据读取函数。</li>
<li><strong>Open360Database</strong>: 打开 360 浏览器的数据库并读取账户信息。</li>
<li><strong>OpenLogin360Data</strong>: 处理登录数据的提取和解密。</li>
<li><strong>FindLoginDB</strong>: 查找登录数据库文件的路径。</li>
</ul>
<ol>
<li><code>Get360seInfo::Get360seInfo()</code>: 构造函数，初始化成员变量并从注册表中获取必要的信息。</li>
<li><code>Get360seInfo::~Get360seInfo()</code>: 析构函数，释放资源。</li>
<li><code>bool Get360seInfo::getData(std::vector&lt;BrowserData&gt;* pBroData)</code>: 提取浏览器数据，调用数据库打开和登录数据提取函数。</li>
<li><code>bool Get360seInfo::Open360Database(std::vector&lt;BrowserData&gt;* pBroData)</code>: 打开 360 浏览器的数据库并读取账户信息。</li>
<li><code>std::string Get360seInfo::Last360Uncode(const char* passItem)</code>: 解码密码项，处理特定格式的密码。</li>
<li><code>void Get360seInfo::FindLoginDB(std::string lpPath)</code>: 查找登录数据库文件的路径。</li>
<li><code>bool Get360seInfo::OpenLogin360Data(std::vector&lt;BrowserData&gt;* pBroData)</code>: 提取和解密登录数据。</li>
<li><code>bool Get360seInfo::EnumChromeRandstr(DWORD th32ProcessID, HANDLE h_360se)</code>: 枚举 Chrome 进程中的随机字符串。</li>
<li><code>bool Get360seInfo::EnumProcessGetRandstr()</code>: 获取 360 浏览器进程中的随机字符串。</li>
<li><code>ULONG PseudoRand(ULONG* seed)</code>: 伪随机数生成函数。</li>
<li><code>void GetBotId(char* botId)</code>: 生成一个唯一的 bot ID。</li>
</ol>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>机器管理器（CMachineManager），用于管理和监控系统中的进程、服务、网络状态等功能。</p>
<pre class="mermaid">graph LR;
    A[CMachineManager] --> B[OnReceive]
    B --> C[SendProcessList]
    B --> D[SendWindowsList]
    B --> E[SendNetStateList]
    B --> F[SendSoftWareList]
    B --> G[SendIEHistoryList]
    B --> H[SendFavoritesUrlList]
    B --> I[SendServicesList]
    B --> J[SendHostsList]
    B --> K[DeleteService]
    B --> L[MyControlService]
    B --> M[GetRoot]
    B --> N[InjectProcess]</pre>

<ul>
<li><strong>CMachineManager</strong>: 主要类，负责管理机器的各种操作。</li>
<li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li>
<li><strong>SendProcessList</strong>: 发送当前进程列表。</li>
<li><strong>SendWindowsList</strong>: 发送当前窗口列表。</li>
<li><strong>SendNetStateList</strong>: 发送网络状态列表。</li>
<li><strong>SendSoftWareList</strong>: 发送已安装软件列表。</li>
<li><strong>SendIEHistoryList</strong>: 发送IE浏览历史。</li>
<li><strong>SendFavoritesUrlList</strong>: 发送收藏夹URL列表。</li>
<li><strong>SendServicesList</strong>: 发送服务列表。</li>
<li><strong>SendHostsList</strong>: 发送hosts文件内容。</li>
<li><strong>DeleteService</strong>: 删除指定服务。</li>
<li><strong>MyControlService</strong>: 控制服务的启动、停止、暂停和继续。</li>
<li><strong>GetRoot</strong>: 获取任务调度器的根目录。</li>
</ul>
<ol>
<li><code>CMachineManager::CMachineManager(ISocketBase* pClient)</code>: 构造函数，初始化机器管理器，设置用户权限和服务。</li>
<li><code>CMachineManager::~CMachineManager()</code>: 析构函数，释放资源，反初始化COM。</li>
<li><code>void CMachineManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的数据，根据命令类型调用相应的处理函数。</li>
<li><code>void CMachineManager::SendProcessList()</code>: 发送当前进程列表。</li>
<li><code>void CMachineManager::SendWindowsList()</code>: 发送当前窗口列表。</li>
<li><code>void CMachineManager::SendNetStateList()</code>: 发送网络状态列表。</li>
<li><code>void CMachineManager::SendSoftWareList()</code>: 发送已安装软件列表。</li>
<li><code>void CMachineManager::SendIEHistoryList()</code>: 发送IE浏览历史。</li>
<li><code>void CMachineManager::SendFavoritesUrlList()</code>: 发送收藏夹URL列表。</li>
<li><code>void CMachineManager::SendServicesList(DWORD dwServiceType)</code>: 发送服务列表。</li>
<li><code>void CMachineManager::SendHostsList()</code>: 发送hosts文件内容。</li>
<li><code>void CMachineManager::DeleteService(LPBYTE lpBuffer, UINT nSize)</code>: 删除指定服务。</li>
<li><code>void CMachineManager::MyControlService(LPBYTE lpBuffer, UINT nType)</code>: 控制服务的启动、停止、暂停和继续。</li>
<li><code>void CMachineManager::GetRoot()</code>: 获取任务调度器的根目录。</li>
<li><code>BOOL CMachineManager::DebugPrivilege(const TCHAR* PName, BOOL bEnable)</code>: 调整进程的调试权限。</li>
<li><code>BOOL CMachineManager::GetProcessUserName(HANDLE hProcess, TCHAR* strProcessUser)</code>: 获取指定进程的用户名。</li>
<li><code>LPBYTE CMachineManager::getProcessList()</code>: 获取当前进程列表。</li>
<li><code>LPBYTE CMachineManager::getWindowsList()</code>: 获取当前窗口列表。</li>
<li><code>LPBYTE CMachineManager::getNetStateList()</code>: 获取网络状态列表。</li>
<li><code>LPBYTE CMachineManager::getSoftWareList()</code>: 获取已安装软件列表。</li>
<li><code>LPBYTE CMachineManager::getIEHistoryList()</code>: 获取IE浏览历史。</li>
<li><code>LPBYTE CMachineManager::getFavoritesUrlList()</code>: 获取收藏夹URL列表。</li>
<li><code>LPBYTE CMachineManager::getServicesList()</code>: 获取服务列表。</li>
<li><code>LPBYTE CMachineManager::getHostsList()</code>: 获取hosts文件内容。</li>
<li><code>void CMachineManager::injectprocess(DWORD mode, DWORD ExeIsx86, DWORD dwProcessID, byte* data, DWORD datasize, TCHAR* path)</code>: 注入进程，执行指定的操作。</li>
</ol>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/12/02/%E4%BC%AA%E9%80%A0%E8%B0%83%E7%94%A8%E6%A0%88%E6%9D%A5%E8%BF%B7%E6%83%91EDR%E5%92%8C%E6%9D%80%E8%BD%AF/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2025-01-23 16:32:31
            </span>
            
          </div>
          <div class="post-foot-prev">
            
              <a href="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">核心模块组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HPSocket"><span class="toc-text">HPSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shellcode%EF%BC%9A"><span class="toc-text">shellcode：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E7%BA%BF%E6%A8%A1%E5%9D%97%EF%BC%9A"><span class="toc-text">上线模块：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97"><span class="toc-text">代理映射模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">查注册表模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%9D%97"><span class="toc-text">注入模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InjectManager"><span class="toc-text">InjectManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memorymodule"><span class="toc-text">memorymodule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E7%AE%A1%E7%90%86"><span class="toc-text">注入管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95"><span class="toc-text">键盘记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">驱动模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86"><span class="toc-text">内核管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CloseNet-%E6%8F%90%E6%9D%83%E5%92%8C%E4%BC%AA%E8%A3%85%E6%A8%A1%E5%9D%97"><span class="toc-text">CloseNet 提权和伪装模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6-HiddenLib"><span class="toc-text">隐藏文件  HiddenLib</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8Bshell%E7%AE%A1%E7%90%86-shellmanager"><span class="toc-text">远程shell管理 shellmanager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E6%8E%A7CC%E4%BF%A1%E6%81%AF%E4%BA%A4%E4%BA%92"><span class="toc-text">远控CC信息交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9D%97"><span class="toc-text">解密数据模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%B0%E6%8D%AE"><span class="toc-text">解密浏览器数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96360%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%B0%E6%8D%AE"><span class="toc-text">获取360浏览器数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">系统管理</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'ceAjSe00zC64FzvGqcpmcNMN-gzGzoHsz',
        appKey: 'OjjBzWRjoxlhtVeii08I5cxA',
        placeholder: 'Welcome!',
        avatar: 'retro',
        lang: 'en'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
  <div class="footer">
    <div class="social">
      <ul>
        
          <li>
            
                <a title="github" target="_blank" rel="noopener" href="https://github.com/Hipepper/">
                  <i class="iconfont icon-github"></i>
                </a>
                
          </li>
          
          <li>
            
                <a title="rss" href="/atom.xml">
                  <i class="iconfont icon-rss"></i>
                </a>
                
          </li>
          
      </ul>
    </div>
    
      
        <div class="footer-more">
          
            <a target="_blank" rel="noopener" href="https://github.com/Hipepper/">Copyright © 2025 TIP Factory</a>
            
        </div>
        
      
        <div class="footer-more">
          
            <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Tip Factory | JentleTao</a>
            
        </div>
        
          
            <div class="footer-views">
              
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
                    
                      
                本文总阅读量<span id="busuanzi_value_page_pv"></span>次
                    
                      
                本站访客数<span id="busuanzi_value_site_uv"></span>人
                    
                      
            </div>
            
  </div>


  
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
    <script>
      mermaid.initialize({
        theme: 'default',
        startOnLoad: true,
        flowchart: { useMaxWidth: false }
      });
    </script>
    
      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB--%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97 + '&url=' + http%3A%2F%2Fexample.com%2F2024%2F12%2F06%2F%25E9%2593%25B6%25E7%258B%2590%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB-%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BB%2584%25E4%25BB%25B6%25E6%25A8%25A1%25E5%259D%2597%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body>
</html>
