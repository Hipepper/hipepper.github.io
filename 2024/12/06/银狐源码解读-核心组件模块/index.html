

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jentle">
  <meta name="keywords" content="">
  
    <meta name="description" content="[toC] 核心模块组件介绍 可以在公众号获取原文，目前网站不支持mermaid，可公众号下载原始PDF!!!  HPSocket使用的公开技术，基于于 IOCP&#x2F;EPOLL 通信模型，结合内存池、私有堆等技术，实现高效的内存管理，支持大规模、高并发的通信场景。Git地址：https:&#x2F;&#x2F;github.com&#x2F;ldcsaa&#x2F;HP-Socket   shellcode： 在 ntdll_e">
<meta property="og:type" content="article">
<meta property="og:title" content="银狐源码解读--核心组件模块">
<meta property="og:url" content="http://example.com/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/index.html">
<meta property="og:site_name" content="TIPFactory">
<meta property="og:description" content="[toC] 核心模块组件介绍 可以在公众号获取原文，目前网站不支持mermaid，可公众号下载原始PDF!!!  HPSocket使用的公开技术，基于于 IOCP&#x2F;EPOLL 通信模型，结合内存池、私有堆等技术，实现高效的内存管理，支持大规模、高并发的通信场景。Git地址：https:&#x2F;&#x2F;github.com&#x2F;ldcsaa&#x2F;HP-Socket   shellcode： 在 ntdll_e">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic1.png">
<meta property="og:image" content="http://example.com/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic2.png">
<meta property="og:image" content="http://example.com/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic3.png">
<meta property="article:published_time" content="2024-12-06T07:09:16.000Z">
<meta property="article:modified_time" content="2025-01-23T08:32:31.815Z">
<meta property="article:author" content="Jentle">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic1.png">
  
  
  
  <title>银狐源码解读--核心组件模块 - TIPFactory</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="TIPFactory" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="银狐源码解读--核心组件模块"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-06 15:09" pubdate>
          December 6, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.2k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          61 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">银狐源码解读--核心组件模块</h1>
            
            
              <div class="markdown-body">
                
                <p>[toC]</p>
<h1 id="核心模块组件介绍"><a href="#核心模块组件介绍" class="headerlink" title="核心模块组件介绍"></a>核心模块组件介绍</h1><blockquote>
<p>可以在公众号获取原文，目前网站不支持mermaid，可公众号下载原始PDF!!!</p>
</blockquote>
<h2 id="HPSocket"><a href="#HPSocket" class="headerlink" title="HPSocket"></a>HPSocket</h2><p>使用的公开技术，基于于 IOCP&#x2F;EPOLL 通信模型，结合内存池、私有堆等技术，实现高效的内存管理，支持大规模、高并发的通信场景。Git地址：<a target="_blank" rel="noopener" href="https://github.com/ldcsaa/HP-Socket">https://github.com/ldcsaa/HP-Socket</a></p>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" srcset="/img/loading.gif" lazyload data-original="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic1.png" class="" title="pic1">

<h2 id="shellcode："><a href="#shellcode：" class="headerlink" title="shellcode："></a>shellcode：</h2><ol>
<li>在 ntdll_entry 函数中，程序通过 LoadLibraryA 加载 kernel32.dll 和 ntdll.dll，并使用 GetProcAddress 获取所需的函数地址。</li>
<li>通过 mytcp 和 myudp 函数实现 TCP 和 UDP 的网络通信。程序根据 ShellCodeInfo 结构中的信息进行连接和数据传输。</li>
<li>定义了一些数据结构，如 ShellCodeInfo、func_t 等，用于存储网络通信所需的信息和函数指针。</li>
</ol>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" srcset="/img/loading.gif" lazyload data-original="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic2.png" class="" title="pic2">

<h2 id="上线模块："><a href="#上线模块：" class="headerlink" title="上线模块："></a>上线模块：</h2><p>函数调用关系</p>
<pre class="mermaid">graph TD;
    A[_tmain] --> B[Analyze]
    A --> C[SetUnhandledExceptionFilter]
    B --> D[Getfindinfo]
    B --> E[RegOpenKeyEx]
    B --> F[RegQueryValueEx]
    C --> G[ExceptionFilter]
    G --> H[GenerateMiniDump]
    A --> I[CreateThread]
    I --> J[MainThread]
    J --> K[Socket Communication]</pre>

<p>说明</p>
<ul>
<li><strong>A</strong>: 程序入口 <code>_tmain</code>，设置异常处理器并调用 <code>Analyze</code>。</li>
<li><strong>B</strong>: <code>Analyze</code> 函数用于提取配置信息。</li>
<li><strong>C</strong>: 设置未处理异常过滤器，调用 <code>ExceptionFilter</code>。</li>
<li><strong>D</strong>: <code>Getfindinfo</code> 用于从配置中提取信息。</li>
<li><strong>E</strong> 和 <strong>F</strong>: 从注册表中读取配置信息。</li>
<li><strong>G</strong>: <code>ExceptionFilter</code> 捕获异常并调用 <code>GenerateMiniDump</code>。</li>
<li><strong>H</strong>: <code>GenerateMiniDump</code> 生成转储文件。</li>
<li><strong>I</strong>: 创建主线程，调用 <code>MainThread</code>。</li>
<li><strong>J</strong>: <code>MainThread</code> 处理网络通信。</li>
</ul>
<p>部分代码解释：</p>
<ol>
<li><p><strong>信息结构体定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Info MyInfo = &#123; ... &#125;;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>****定义一个 <code>Info</code> 结构体实例 <code>MyInfo</code>，用于存储配置信息，如 IP 地址、端口、TCP&#x2F;UDP 标志等。</li>
</ul>
</li>
<li><p><strong>全局变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hThread = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> changeip = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> m_time_con = <span class="hljs-number">0</span>;<br>TCHAR szAddress[<span class="hljs-number">255</span>];  <span class="hljs-comment">//ip</span><br>TCHAR szPort[<span class="hljs-number">30</span>];      <span class="hljs-comment">//端口</span><br>TCHAR szPassword[<span class="hljs-number">255</span>]; <span class="hljs-comment">//通行密码</span><br>BOOL IsTcp;            <span class="hljs-comment">//通信模式</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li>****定义全局变量，用于线程管理、IP 地址、端口、密码和通信模式的存储。</li>
</ul>
</li>
<li><p><strong><code>Getfindinfo</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Getfindinfo</span><span class="hljs-params">(TCHAR* s, <span class="hljs-type">const</span> TCHAR* f1, TCHAR* outstring, BOOL* user)</span></span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>****从给定字符串中提取特定信息（如 IP 地址和端口），并将其存储到输出参数中。</li>
</ul>
</li>
<li><p><strong><code>Analyze</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Analyze</span><span class="hljs-params">()</span></span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>****分析配置信息，调用 <code>Getfindinfo</code> 函数从配置字符串和注册表中提取信息。</li>
</ul>
</li>
<li><p><strong><code>MainThread</code> 函数</strong> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">MainThread</span><span class="hljs-params">(LPVOID dllMainThread)</span></span><br><span class="hljs-function"></span>&#123;<br>	ISocketBase* socketClient;<br>	<span class="hljs-keyword">if</span> (MyInfo.IsTcp == <span class="hljs-number">1</span>)<br>		socketClient = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CTcpSocket</span>();<br>	<span class="hljs-keyword">else</span><br>		socketClient = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CUdpSocket</span>();<br><br>	<span class="hljs-keyword">if</span> (socketClient-&gt;<span class="hljs-built_in">Connect</span>(MyInfo.szAddress, MyInfo.szPort))<br>	&#123;<br>		<span class="hljs-function">CRegeditManager	<span class="hljs-title">manager</span><span class="hljs-params">(socketClient)</span></span>;<br>		socketClient-&gt;<span class="hljs-built_in">run_event_loop</span>();<br>	&#125;<br>	<span class="hljs-built_in">SAFE_DELETE</span>(socketClient);<br>	<span class="hljs-keyword">if</span> (MyInfo.RunDllEntryProc)<br>		<span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>****主线程函数，负责初始化网络连接，循环处理网络通信。</li>
</ul>
</li>
<li><p><strong><code>GenerateMiniDump</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GenerateMiniDump</span><span class="hljs-params">(PEXCEPTION_POINTERS pExceptionPointers)</span></span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>****生成崩溃转储文件，以便在程序异常时进行调试。</li>
</ul>
</li>
<li><p><strong><code>ExceptionFilter</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LONG WINAPI <span class="hljs-title">ExceptionFilter</span><span class="hljs-params">(LPEXCEPTION_POINTERS lpExceptionInfo)</span></span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>****捕获未处理的异常并调用 <code>GenerateMiniDump</code> 生成转储文件。</li>
</ul>
</li>
<li><p><strong><code>_tmain</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[]);<br><br></code></pre></td></tr></table></figure>

<ul>
<li>****程序的入口点，设置异常处理器，隐藏控制台窗口，调用 <code>Analyze</code> 函数并创建主线程。</li>
</ul>
</li>
<li><p><strong>DLL 相关函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span></span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>****DLL 的入口点，根据不同的调用原因执行相应的操作。</li>
</ul>
</li>
</ol>
<p>上线模块中 内核管理内容</p>
<p>文件解读</p>
<ol>
<li><code>unsigned int __stdcall Loop_DllManager(void* pVoid);</code> 函数：负责加载 DLL 并管理其生命周期，包括注册表操作和进程监控。</li>
<li><code>CKernelManager::CKernelManager(ISocketBase* pClient, BOOL bpuppet);</code> 构造函数：初始化 CKernelManager 对象，设置工作线程和是否为木偶模式。</li>
<li><code>CKernelManager::~CKernelManager();</code> 析构函数：释放工作线程的句柄，清理资源。</li>
<li><code>void CKernelManager::runbin();</code> 函数：启动工作线程并在启动后断开连接。</li>
<li><code>void CKernelManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的数据，进行注册表读写和 DLL 运行。</li>
<li><code>BOOL buildremoteprocess(byte* data, int size, PROCESS_INFORMATION* pi);</code> 函数：创建远程进程并将数据写入其内存。</li>
<li><code>bool pid_is_running(DWORD pid);</code> 函数：检查指定进程 ID 是否仍在运行。</li>
<li><code>int memfind(const char* mem, const char* str, int sizem, int sizes);</code> 函数：在内存中查找指定字符串的位置。</li>
</ol>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" srcset="/img/loading.gif" lazyload data-original="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic3.png" class="" title="pic3.png">

<h2 id="代理映射模块"><a href="#代理映射模块" class="headerlink" title="代理映射模块"></a>代理映射模块</h2><p>主要作用是实现一个网络代理插件，能够通过TCP或UDP协议与远程服务器进行通信</p>
<p><strong>函数关系调用流程图</strong></p>
<pre class="mermaid">graph TD;
    A[WinMain] --> B[SetUnhandledExceptionFilter]
    A --> C["CreateThread(MainThread)"]
    C --> D[MainThread]
    D --> E[ISocketBase::Connect]
    E --> F[CProxyManager]
    D --> G[run_event_loop]
    A --> H[DllMain]
    H --> I[Main]
    I --> D
    H --> J[run]
    J --> D</pre>

<p><strong>关键组件介绍：</strong></p>
<ul>
<li><strong>WinMain</strong>: 应用程序的入口点，设置未处理异常过滤器并创建主线程。</li>
<li><strong>MainThread</strong>: 负责初始化网络连接并处理网络通信。</li>
<li><strong>ISocketBase</strong>: 抽象基类，用于网络连接的实现（TCP或UDP）。</li>
<li><strong>CProxyManager</strong>: 管理网络代理的类。</li>
<li><strong>DllMain</strong>: DLL的入口点，处理DLL的加载和卸载。</li>
<li><strong>Main</strong>: 导出函数，用于设置代理信息并启动主线程。</li>
<li><strong>run</strong>: 导出函数，用于启动主线程以处理网络通信。</li>
</ul>
<p><strong>函数内容：</strong></p>
<ol>
<li><code>DWORD WINAPI MainThread(LPVOID dllMainThread)</code>: 主线程函数，负责初始化网络连接，循环处理网络通信。</li>
<li><code>int GenerateMiniDump(PEXCEPTION_POINTERS pExceptionPointers)</code>: 生成迷你转储文件，用于异常处理和调试。</li>
<li><code>LONG WINAPI ExceptionFilter(LPEXCEPTION_POINTERS lpExceptionInfo)</code>: 异常过滤器，处理未捕获的异常并生成转储文件。</li>
<li><code>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR szCmdLine, int iCmdShow)</code>: 应用程序入口点，设置异常处理和启动主线程。</li>
<li><code>BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</code>: DLL的入口点，处理DLL的加载和卸载。</li>
<li><code>extern &quot;C&quot; __declspec(dllexport) bool Main(TCHAR * ip, DWORD port, BOOL IsTcp, BOOL RunDllEntryProc)</code>: 导出函数，用于设置代理信息并启动主线程。</li>
<li><code>extern &quot;C&quot; __declspec(dllexport) bool run()</code>: 导出函数，用于启动主线程以处理网络通信。</li>
</ol>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>该代码实现了一个文件管理器类 CFileManager，用于处理文件的上传、下载、删除、压缩等操作，并与远程客户端进行通信。</p>
<ol>
<li><strong><code>CFileManager::CFileManager(ISocketBase* pClient)</code></strong> 函数：构造函数，初始化文件管理器，设置桌面和线程，分配内存并发送驱动器列表。</li>
<li><strong><code>CFileManager::~CFileManager()</code></strong> 函数：析构函数，清理资源，关闭文件句柄，释放内存。</li>
<li><strong><code>void CFileManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code></strong> 函数：处理接收到的数据，根据命令类型调用相应的处理函数。</li>
<li><strong><code>bool CFileManager::MakeSureDirectoryPathExists(LPCTSTR pszDirPath)</code></strong> 函数：确保指定的目录路径存在，如果不存在则创建。</li>
<li><strong><code>BOOL CFileManager::OpenFile(LPCTSTR lpFile, INT nShowCmd)</code></strong> 函数：打开指定的文件，使用注册表查找文件关联的程序。</li>
<li><strong><code>HANDLE CFileManager::ImpersonateLoggedOnUserWrapper()</code></strong> 函数：获取当前登录用户的令牌，以便进行用户模拟。</li>
<li><strong><code>UINT CFileManager::SendDriveList()</code></strong> 函数：获取并发送当前系统的驱动器列表及其属性。</li>
<li><strong><code>UINT CFileManager::SendFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的文件列表。</li>
<li><strong><code>bool CFileManager::DeleteDirectory(LPCTSTR lpszDirectory)</code></strong> 函数：删除指定的目录及其内容。</li>
<li><strong><code>void CFileManager::SendToken(BYTE token)</code></strong> 函数：发送特定的令牌，用于标识操作的状态。</li>
<li><strong><code>void CFileManager::SendNetHood()</code></strong> 函数：发送网络邻居的信息。</li>
<li><strong><code>void CFileManager::SendSearchFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的搜索文件列表。</li>
<li><strong><code>void CFileManager::CreateFolder(LPCTSTR lpszFolder)</code></strong> 函数：创建一个新的文件夹。</li>
<li><strong><code>void CFileManager::Rename(LPCTSTR lpszNewName)</code></strong> 函数：重命名文件或文件夹。</li>
<li><strong><code>void CFileManager::WriteLocalRecvFile(LPBYTE lpBuffer, UINT nSize)</code></strong> 函数：将接收到的数据写入本地文件。</li>
<li><strong><code>void CFileManager::UploadToRemote(LPBYTE lpBuffer)</code></strong> 函数：将文件上传到远程服务器。</li>
<li><strong><code>void CFileManager::StopTransfer(LPBYTE lpBuffer)</code></strong> 函数：停止文件传输。</li>
<li><strong><code>void CFileManager::StartZIP()</code></strong> 函数：开始压缩文件的操作。</li>
<li><strong><code>void CFileManager::StopZIPTheard()</code></strong> 函数：停止压缩线程。</li>
<li><strong><code>void CFileManager::SendFileInfo(LPCTSTR lpszFileName, LPCTSTR lpszFileType)</code></strong> 函数：发送文件信息。</li>
<li><strong><code>void CFileManager::encfile(char* filePath)</code></strong> 函数：对指定文件进行加密。</li>
<li><strong><code>void CFileManager::decryptfile(char* filePath)</code></strong> 函数：对指定文件进行解密。</li>
<li><strong><code>void CFileManager::FnDelPathFile(TCHAR* filePath)</code></strong> 函数：强制删除指定路径的文件。</li>
<li><strong><code>void CFileManager::SendFileData(LPBYTE lpBuffer)</code></strong> 函数：发送文件数据。</li>
<li><strong><code>void CFileManager::CreateLocalRecvFile(LPBYTE lpBuffer)</code></strong> 函数：创建本地接收文件。</li>
<li><strong><code>void CFileManager::SetTransferMode(LPBYTE lpBuffer)</code></strong> 函数：设置文件传输模式。</li>
<li><strong><code>void CFileManager::GetBotId(char* desktopName)</code></strong> 函数：获取机器的Bot ID。</li>
<li><strong><code>void CFileManager::SendFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的文件列表。</li>
<li><strong><code>void CFileManager::SendSearchDate(LPBYTE lpBuffer)</code></strong> 函数：发送搜索日期信息。</li>
<li><strong><code>void CFileManager::SendRecentFiles()</code></strong> 函数：发送最近使用的文件列表。</li>
</ol>
<p>以上是文件中各个功能模块的简要代码及其含义。每个函数的作用都与文件管理相关，涉及文件的创建、删除、传输、压缩等操作。</p>
<p>MasterEncoder.cpp实现了一个PDF文件的加密和解密功能，使用异或操作和自定义签名来保护文件内容。</p>
<pre class="mermaid">graph TD;
    A[readPDF] --> B[encodePDF]
    A --> C[decodePDF]
    B --> D[writePDF]
    C --> D
    D --> E[decode]</pre>

<p><strong>关键组件介绍：</strong></p>
<ul>
<li><strong>readPDF</strong>: 读取PDF文件并返回其内容和大小。</li>
<li><strong>encodePDF</strong>: 对PDF文件进行加密处理。</li>
<li><strong>decodePDF</strong>: 对PDF文件进行解密处理。</li>
<li><strong>writePDF</strong>: 将处理后的数据写入新的PDF文件。</li>
<li><strong>decode</strong>: 解密数据，返回解密后的内容。</li>
</ul>
<ol>
<li><code>MasterEncoder::readPDF(const string&amp; filepath, long&amp; size)</code>: 函数：读取指定路径的PDF文件，返回文件内容和大小。</li>
<li><code>MasterEncoder::writePDF(const string&amp; filePath, unsigned char* data, long size)</code>: 函数：将数据写入指定路径的PDF文件。</li>
<li><code>MasterEncoder::encodePDF(const string&amp; pdfPath, const string&amp; savePath)</code>: 函数：对PDF文件进行加密，并保存到指定路径。</li>
<li><code>MasterEncoder::decodePDF(const string&amp; pdfPath, const string&amp; savePath)</code>: 函数：对PDF文件进行解密，并保存到指定路径。</li>
<li><code>MasterEncoder::decode(const string&amp; pdfPath, long&amp; size)</code>: 函数：读取PDF文件并解密，返回解密后的数据。</li>
</ol>
<h2 id="查注册表模块"><a href="#查注册表模块" class="headerlink" title="查注册表模块"></a>查注册表模块</h2><p>一个注册表管理器类 <code>CRegeditManager</code>，用于处理与 Windows 注册表的交互，包括创建、删除、修改注册表键值等操作。</p>
<pre class="mermaid">graph LR;
    A[OnReceive] -->|接收命令| B[EnumReg]
    A -->|接收命令| C[CreateKey]
    A -->|接收命令| D[DeleteKey]
    A -->|接收命令| E[Rename]
    A -->|接收命令| F[DeleteVal]
    A -->|接收命令| G[CreatSTR]
    A -->|接收命令| H[CreatDWORD]
    A -->|接收命令| I[CreatEXSTR]

    B --> J[GetRegInfo]
    C --> K[MyCreateKey]
    D --> L[MyDeleteKey]
    E --> M[WriteValue]
    F --> N[DeleteValue]
    G --> O[WriteValue]
    H --> P[WriteValue]
    I --> Q[WriteBuf]</pre>

<p>关键组件介绍</p>
<ul>
<li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li>
<li><strong>EnumReg</strong>: 枚举注册表键，获取注册表信息。</li>
<li><strong>CreateKey</strong>: 创建新的注册表键。</li>
<li><strong>DeleteKey</strong>: 删除指定的注册表键。</li>
<li><strong>Rename</strong>: 重命名注册表键。</li>
<li><strong>DeleteVal</strong>: 删除注册表值。</li>
<li><strong>CreatSTR</strong>: 创建字符串类型的注册表值。</li>
<li><strong>CreatDWORD</strong>: 创建 DWORD 类型的注册表值。</li>
<li><strong>CreatEXSTR</strong>: 创建扩展字符串类型的注册表值。</li>
</ul>
<ol>
<li><code>CRegeditManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code> 函数：处理接收到的数据，根据不同的命令类型调用相应的处理函数。</li>
<li><code>CRegeditManager::EnumReg(BYTE bToken, LPBYTE lpBuffer)</code> 函数：枚举注册表键，获取注册表信息并发送回客户端。</li>
<li><code>CRegeditManager::CreateKey(LPBYTE lpBuffer)</code> 函数：创建新的注册表键。</li>
<li><code>CRegeditManager::DeleteKey(LPBYTE lpBuffer)</code> 函数：删除指定的注册表键。</li>
<li><code>CRegeditManager::Rename(char* buf)</code> 函数：重命名注册表键。</li>
<li><code>CRegeditManager::DeleteVal(char* buf)</code> 函数：删除指定的注册表值。</li>
<li><code>CRegeditManager::CreatSTR(char* buf)</code> 函数：创建字符串类型的注册表值。</li>
<li><code>CRegeditManager::CreatDWORD(char* buf)</code> 函数：创建 DWORD 类型的注册表值。</li>
<li><code>CRegeditManager::CreatEXSTR(char* buf)</code> 函数：创建扩展字符串类型的注册表值。</li>
<li><code>CRegeditManager::WriteValue(LPCTSTR lpValueName, LPCTSTR lpValue)</code> 函数：写入字符串类型的注册表值。</li>
<li><code>CRegeditManager::WriteBuf(LPCTSTR lpValueName, LPCTSTR lpValue)</code> 函数：写入扩展字符串类型的注册表值。</li>
<li><code>CRegeditManager::OpenKey(LPCTSTR lpSubKey)</code> 函数：打开指定的注册表键。</li>
<li><code>CRegeditManager::DeleteValue(LPCTSTR lpValueName)</code> 函数：删除指定的注册表值。</li>
<li><code>CRegeditManager::SendError()</code> 函数：发送错误信息给客户端。</li>
<li><code>CRegeditManager::SendSucceed()</code> 函数：发送成功信息给客户端。</li>
</ol>
<h2 id="注入模块"><a href="#注入模块" class="headerlink" title="注入模块"></a>注入模块</h2><h3 id="InjectManager"><a href="#InjectManager" class="headerlink" title="InjectManager"></a>InjectManager</h3><p>一个注入管理器，负责管理进程注入、文件传输和进程信息的获取。</p>
<pre class="mermaid">graph LR;
    A[开始] --> B[接收数据]
    B --> C{数据类型}
    C -->|TOKEN_HEARTBEAT| D[忽略]
    C -->|COMMAND_INJECT_PROCESS| E[发送进程列表]
    C -->|COMMAND_INJECT_FILE_INFO| F[创建接收文件]
    C -->|COMMAND_INJECT_FILE_DATA| G[写入接收文件]
    C -->|COMMAND_INJECT_REMOTEFILE_RUN| H[运行远程文件]
    C -->|COMMAND_INJECT_REMOTEFILE_DEL| I[删除文件]
    C -->|COMMAND_INJECT_SETDLL| J[设置DLL路径]
    C -->|COMMAND_INJECT_MODE| K[注入模式处理]
    C -->|其他| L[处理其他命令]
    D --> M[结束]
    E --> M
    F --> M
    G --> M
    H --> M
    I --> M
    J --> M
    K --> M
    L --> M</pre>

<ul>
<li><strong>接收数据</strong>：从客户端接收指令。</li>
<li><strong>数据类型判断</strong>：根据接收到的数据类型决定执行的操作。</li>
<li><strong>发送进程列表</strong>：获取并发送当前进程列表。</li>
<li><strong>创建接收文件</strong>：为接收文件创建本地文件。</li>
<li><strong>写入接收文件</strong>：将接收到的数据写入文件。</li>
<li><strong>运行远程文件</strong>：执行指定的远程文件。</li>
<li><strong>删除文件</strong>：删除指定的文件。</li>
<li><strong>注入模式处理</strong>：根据不同的注入模式执行相应的注入操作。</li>
</ul>
<ol>
<li><code>CInjectManager::CInjectManager(ISocketBase* pClient)</code>：构造函数，初始化注入管理器，设置标志和接收数据。</li>
<li><code>CInjectManager::~CInjectManager()</code>：析构函数，清理资源，退出BoxedAppSDK。</li>
<li><code>void CInjectManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>：处理接收到的数据，根据不同的命令执行相应的操作。</li>
<li><code>void CInjectManager::SendProcessList()</code>：获取当前进程列表并发送给客户端。</li>
<li><code>BOOL CInjectManager::DebugPrivilege(const TCHAR* PName, BOOL bEnable)</code>：调整进程的调试权限。</li>
<li><code>BOOL CInjectManager::GetProcessUserName(HANDLE hProcess, TCHAR* strProcessUser)</code>：获取指定进程的用户名。</li>
<li><code>BOOL CInjectManager::DosPathToNtPath(LPTSTR pszDosPath, LPTSTR pszNtPath)</code>：将DOS路径转换为NT路径。</li>
<li><code>bool CInjectManager::Is64BitOS()</code>：检查操作系统是否为64位。</li>
<li><code>bool CInjectManager::Is64BitPorcess(DWORD dwProcessID)</code>：检查指定进程是否为64位。</li>
<li><code>LPBYTE CInjectManager::getProcessList()</code>：获取当前系统的进程列表。</li>
<li><code>void CInjectManager::SendError(TCHAR* Terror)</code>：发送错误信息给客户端。</li>
<li><code>void CInjectManager::CreateLocalRecvFile(LPBYTE lpBuffer)</code>：创建接收文件的准备工作。</li>
<li><code>void CInjectManager::WriteLocalRecvFile(LPBYTE lpBuffer, UINT nSize)</code>：将接收到的数据写入本地文件。</li>
<li><code>void CInjectManager::WriteOk()</code>：确认文件写入成功。</li>
<li><code>void CInjectManager::WriteDllandSetPath(BOOL isx86, TCHAR* lpBuffer)</code>：写入DLL并设置路径。</li>
<li><code>void CInjectManager::RunExe(LPBYTE lpBuffer)</code>：运行指定的可执行文件。</li>
<li><code>void CInjectManager::RunExeuacArg(LPBYTE lpBuffer)</code>：运行带参数的可执行文件。</li>
<li><code>void CInjectManager::DelFile(LPBYTE lpBuffer)</code>：删除指定的文件。</li>
<li><code>void CInjectManager::Inject_dll()</code>：执行DLL注入操作。</li>
<li><code>void CInjectManager::Inject_shellcode()</code>：执行Shellcode注入操作。</li>
</ol>
<h3 id="memorymodule"><a href="#memorymodule" class="headerlink" title="memorymodule"></a>memorymodule</h3><p><em>MemoryModule.c</em></p>
<p>公开模块：<a target="_blank" rel="noopener" href="https://github.com/fancycode/MemoryModule/blob/master/MemoryModule.c">https://github.com/fancycode/MemoryModule/blob/master/MemoryModule.c</a></p>
<h3 id="注入管理"><a href="#注入管理" class="headerlink" title="注入管理"></a>注入管理</h3><p>该代码实现了一个注入管理器，主要用于通过 TCP 或 UDP 连接到指定的地址和端口，并在连接后执行相应的操作。</p>
<pre class="mermaid">graph TD;
    A[WinMain] --> B[SetUnhandledExceptionFilter]
    A --> C["CreateThread(MainThread)"]
    C --> D[MainThread]
    D --> E["Connect(Socket)"]
    E --> F[Run Event Loop]
    D --> G[ExitProcess]
    A --> H[DllMain]
    H --> I[Main]
    I --> D
    H --> J[run]
    J --> D</pre>

<ul>
<li><strong>WinMain</strong>: 应用程序的入口点，设置未处理异常过滤器并创建主线程。</li>
<li><strong>MainThread</strong>: 负责建立网络连接并处理网络通信。</li>
<li><strong>DllMain</strong>: DLL 的入口点，处理 DLL 的加载和卸载。</li>
<li><strong>Main</strong>: 用于初始化连接参数并启动主线程。</li>
<li><strong>run</strong>: 启动主线程以处理网络通信。</li>
</ul>
<ol>
<li><code>DWORD WINAPI MainThread(LPVOID dllMainThread)</code>: 主线程函数，负责初始化网络连接，循环处理网络通信。</li>
<li><code>int GenerateMiniDump(PEXCEPTION_POINTERS pExceptionPointers)</code>: 生成小型转储文件，用于异常处理和调试。</li>
<li><code>LONG WINAPI ExceptionFilter(LPEXCEPTION_POINTERS lpExceptionInfo)</code>: 异常过滤器，处理未捕获的异常并生成转储文件。</li>
<li><code>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR szCmdLine, int iCmdShow)</code>: 应用程序入口点，设置异常处理并启动主线程。</li>
<li><code>BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</code>: DLL 的入口点，处理 DLL 的加载和卸载。</li>
<li><code>extern &quot;C&quot; __declspec(dllexport) bool Main(TCHAR * ip, DWORD port, BOOL IsTcp, BOOL RunDllEntryProc)</code>: 用于初始化连接参数并启动主线程。</li>
<li><code>extern &quot;C&quot; __declspec(dllexport) bool run()</code>: 启动主线程以处理网络通信。</li>
</ol>
<h2 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h2><p>键盘记录器和剪贴板监控器，能够捕获键盘输入和剪贴板内容，并将其发送到指定的服务器。</p>
<pre class="mermaid">graph TD;
    A[主线程] --> B[键盘记录线程]
    A --> C[剪贴板监控线程]
    B --> D[获取键盘输入]
    C --> E[检查剪贴板变化]
    D --> F[发送键盘数据]
    E --> G[发送剪贴板数据]</pre>

<ul>
<li><strong>主线程</strong>：初始化程序并启动键盘记录和剪贴板监控线程。</li>
<li><strong>键盘记录线程</strong>：负责捕获键盘输入并将其发送到服务器。</li>
<li><strong>剪贴板监控线程</strong>：监控剪贴板内容的变化，并在变化时发送数据。</li>
</ul>
<ol>
<li><code>unsigned int __stdcall KeyLogger(LPVOID lparam);</code> 函数：键盘记录线程，捕获键盘输入并发送到服务器。</li>
<li><code>unsigned int __stdcall ClipboardLogger(LPVOID lparam);</code> 函数：剪贴板监控线程，检查剪贴板内容变化并发送更新。</li>
<li><code>CKeyboardManager::CKeyboardManager(ISocketBase* pClient);</code> 构造函数：初始化键盘管理器，设置线程和资源。</li>
<li><code>CKeyboardManager::~CKeyboardManager();</code> 析构函数：清理资源，关闭线程和释放内存。</li>
<li><code>void CKeyboardManager::SendOnlineDate(TCHAR* p_Buffer);</code> 函数：发送在线数据到服务器。</li>
<li><code>BOOL CKeyboardManager::IsWindowsFocusChange();</code> 函数：检查当前窗口焦点是否变化，并记录变化。</li>
<li><code>BOOL CKeyboardManager::IsClipboardChange();</code> 函数：检查剪贴板内容是否变化，并处理变化。</li>
<li><code>void CKeyboardManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的命令和数据。</li>
<li><code>void CKeyboardManager::UpdateLocalClipboard(char* buf, int len);</code> 函数：更新本地剪贴板内容。</li>
<li><code>void CKeyboardManager::SendErroe(TCHAR* data);</code> 函数：发送错误信息到服务器。</li>
</ol>
<h2 id="驱动模块"><a href="#驱动模块" class="headerlink" title="驱动模块"></a>驱动模块</h2><h3 id="内核管理"><a href="#内核管理" class="headerlink" title="内核管理"></a>内核管理</h3><p>内核管理器类 <code>CKernelManager</code>，用于处理与内核相关的命令和状态管理，包括初始化、接收命令、设置状态、注册值操作等。</p>
<pre class="mermaid">graph LR;
    A[CKernelManager] -->|OnReceive| B[COMMAND_KERNEL_INIT]
    A -->|OnReceive| C[COMMAND_KERNEL_GETSTATE]
    A -->|OnReceive| D[COMMAND_KERNEL_SETSTATE_CONTINUE]
    A -->|OnReceive| E[COMMAND_KERNEL_SETSTATE_STOP]
    A -->|OnReceive| F[COMMAND_KERNEL_RUNCOMMAND]
    A -->|OnReceive| G[COMMAND_KERNEL_DELCOMMAND]
    A -->|OnReceive| H[COMMAND_KERNEL_WRITERCOMMAND]
    A -->|OnReceive| I[COMMAND_KERNEL_BACKDOOR]
    A -->|OnReceive| J[COMMAND_KERNEL_DEL]
    A -->|OnReceive| K[COMMAND_KERNEL_INJECT]
    A -->|OnReceive| L[COMMAND_KERNEL_SETSTATE_PROCESS]</pre>

<ul>
<li><strong>CKernelManager</strong>: 主要类，负责管理内核相关的操作。</li>
<li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li>
<li><strong>各命令处理函数</strong>: 处理不同的内核命令，如初始化、获取状态、设置状态等。</li>
</ul>
<ol>
<li><code>CKernelManager::CKernelManager(ISocketBase* pClient)</code>: 构造函数，初始化内核管理器并设置初始状态。</li>
<li><code>CKernelManager::~CKernelManager()</code>: 析构函数，清理资源。</li>
<li><code>void CKernelManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的命令，根据命令类型调用相应的处理逻辑。</li>
<li><code>void CKernelManager::Initialize()</code>: 初始化内核管理器，设置必要的文件和服务。</li>
<li><code>void CKernelManager::SetRegvalue(TCHAR* name, TCHAR* val, int nSize)</code>: 设置注册表值。</li>
<li><code>void CKernelManager::GetState()</code>: 获取当前状态并返回信息。</li>
<li><code>void CKernelManager::SetState(HidActiveState state)</code>: 设置内核的活动状态。</li>
<li><code>BOOL CKernelManager::IsWindowsX64()</code>: 检查操作系统是否为64位。</li>
<li><code>void CKernelManager::SendReturnInfo(BYTE mode, TCHAR* info)</code>: 发送返回信息。</li>
<li><code>HidRegRootTypes CKernelManager::GetRegType(wstring&amp; path)</code>: 获取注册表路径的类型。</li>
<li><code>HidContext CKernelManager::GetContext()</code>: 获取当前的上下文。</li>
<li><code>void CKernelManager::runcommand(int argc, TCHAR* Command)</code>: 执行指定的命令。</li>
<li><code>void CKernelManager::delcommand(int argc, TCHAR* Command)</code>: 删除指定的命令。</li>
<li><code>void CKernelManager::writercommand(int argc, TCHAR* Command)</code>: 写入指定的命令。</li>
<li><code>bool CKernelManager::GetMultiStrValue(const wchar_t* name, std::vector&lt;std::wstring&gt;&amp; strs)</code>: 获取多字符串值。</li>
<li><code>bool CKernelManager::SetMultiStrValue(const wchar_t* name, const std::vector&lt;std::wstring&gt;&amp; strs)</code>: 设置多字符串值。</li>
<li><code>int CKernelManager::memfind(const char* mem, const char* str, int sizem, int sizes)</code>: 在内存中查找字符串。</li>
<li><code>BOOL CKernelManager::SetInternetStatus(bool enable)</code>: 设置互联网状态。</li>
</ol>
<h3 id="CloseNet-提权和伪装模块"><a href="#CloseNet-提权和伪装模块" class="headerlink" title="CloseNet 提权和伪装模块"></a>CloseNet 提权和伪装模块</h3><p>一系列与进程和权限管理相关的功能，主要用于在Windows环境中进行进程的伪装、句柄泄露和调试权限的管理。</p>
<pre class="mermaid">graph LR;
    A[EnableDebugPrivilege] --> B[MalSeclogonPPIDSpoofing]
    B --> C[FindTokenHandlesInProcess]
    B --> D[CreateProcessWithTokenW]
    B --> E[CreateProcessWithLogonW]
    A --> F[MalSeclogonLeakHandles]
    F --> G[FindProcessHandlesInTargetProcess]
    F --> H[CreateFileLock]
    F --> I[LeakLsassHandleInSeclogonWithRaceCondition]
    I --> J[ReplaceNtOpenProcess]
    I --> K[RestoreNtOpenProcess]</pre>

<ul>
<li><strong>EnableDebugPrivilege</strong>: 启用调试权限，允许后续操作进行更高权限的操作。</li>
<li><strong>MalSeclogonPPIDSpoofing</strong>: 伪装指定进程的PID，尝试使用伪装的PID创建新进程。</li>
<li><strong>FindTokenHandlesInProcess</strong>: 查找目标进程中的令牌句柄，以便后续的进程创建。</li>
<li><strong>CreateProcessWithTokenW</strong>: 使用找到的令牌句柄创建新进程。</li>
<li><strong>CreateProcessWithLogonW</strong>: 如果令牌句柄不可用，则使用登录凭据创建新进程。</li>
<li><strong>MalSeclogonLeakHandles</strong>: 泄露目标进程的句柄，进行后续的操作。</li>
<li><strong>FindProcessHandlesInTargetProcess</strong>: 查找目标进程中的句柄。</li>
<li><strong>CreateFileLock</strong>: 创建文件锁以防止其他进程访问。</li>
<li><strong>LeakLsassHandleInSeclogonWithRaceCondition</strong>: 利用竞争条件泄露lsass进程的句柄。</li>
<li><strong>ReplaceNtOpenProcess</strong>: 替换NtOpenProcess函数以返回泄露的句柄。</li>
<li><strong>RestoreNtOpenProcess</strong>: 恢复NtOpenProcess函数的原始代码。</li>
</ul>
<ol>
<li><code>BOOL SetPrivilege(HANDLE hToken, wchar_t* lpszPrivilege, BOOL bEnablePrivilege);</code> 函数：设置指定的权限，允许或禁用特定的系统权限。</li>
<li><code>void EnableDebugPrivilege(BOOL enforceCheck);</code> 函数：启用调试权限，如果强制检查失败则退出程序。</li>
<li><code>BOOL EnableImpersonatePrivilege();</code> 函数：启用模拟权限，返回是否成功。</li>
<li><code>void SpoofPidTeb(DWORD spoofedPid, PDWORD originalPid, PDWORD originalTid);</code> 函数：伪装当前线程的PID和TID。</li>
<li><code>void RestoreOriginalPidTeb(DWORD originalPid, DWORD originalTid);</code> 函数：恢复原始的PID和TID。</li>
<li><code>NTSTATUS QueryObjectTypesInfo(__out POBJECT_TYPES_INFORMATION* TypesInfo);</code> 函数：查询对象类型信息。</li>
<li><code>NTSTATUS GetTypeIndexByName(__in PCUNICODE_STRING TypeName, __out PULONG TypeIndex);</code> 函数：根据类型名称获取对象类型索引。</li>
<li><code>void FindProcessHandlesInTargetProcess(DWORD targetPid, HANDLE* handlesToLeak, PDWORD handlesToLeakCount);</code> 函数：查找目标进程中的句柄。</li>
<li><code>void FindTokenHandlesInProcess(DWORD targetPid, HANDLE* tokenHandles, PDWORD tokenHandlesLen);</code> 函数：查找目标进程中的令牌句柄。</li>
<li><code>void MalSeclogonPPIDSpoofing(int pid, wchar_t* cmdline);</code> 函数：伪装指定PID并尝试创建新进程。</li>
<li><code>BOOL FileExists(LPCTSTR szPath);</code> 函数：检查指定路径的文件是否存在。</li>
<li><code>void MalSeclogonLeakHandles(int lsassPid, wchar_t* dumpPath);</code> 函数：泄露lsass进程的句柄并创建转储文件。</li>
<li><code>void CreateFileLock(HANDLE hFile, LPOVERLAPPED overlapped);</code> 函数：创建文件锁以防止其他进程访问。</li>
<li><code>DWORD WINAPI ThreadSeclogonLock(LPVOID lpParam);</code> 函数：线程函数，用于执行伪装操作。</li>
<li><code>void LeakLsassHandleInSeclogonWithRaceCondition(DWORD lsassPid);</code> 函数：利用竞争条件泄露lsass进程的句柄。</li>
<li><code>void ReplaceNtOpenProcess(HANDLE leakedHandle, char* oldCode, int* oldCodeSize);</code> 函数：替换NtOpenProcess以返回泄露的句柄。</li>
<li><code>void RestoreNtOpenProcess(char* oldCode, int oldCodeSize);</code> 函数：恢复NtOpenProcess的原始代码。</li>
<li><code>void MalSeclogonDumpLsassFromLeakedHandles(int lsassPid, wchar_t* dumpPath, BOOL useLsassClone);</code> 函数：从泄露的句柄中转储lsass进程。</li>
<li><code>DWORD GetPidUsingFilePath(wchar_t* processBinaryPath);</code> 函数：根据进程的二进制路径获取进程ID。</li>
</ol>
<h3 id="隐藏文件-HiddenLib"><a href="#隐藏文件-HiddenLib" class="headerlink" title="隐藏文件  HiddenLib"></a>隐藏文件  HiddenLib</h3><p>该代码实现了一个隐藏库，提供了对设备的控制和管理功能，包括隐藏文件、注册表项和进程等。</p>
<pre class="mermaid">graph TD;
    A[Hid_Initialize] --> B[Hid_InitializeWithNoConnection]
    B --> C[GetProcAddress]
    A --> D[CreateFileW]
    D --> E[Hid_Destroy]
    E --> F[CloseHandle]
    A --> G[SendIoctl_HideObjectPacket]
    G --> H[DeviceIoControl]
    H --> I[SendIoctl_UnhideObjectPacket]
    I --> H</pre>

<ul>
<li><strong>Hid_Initialize</strong>: 初始化 HID 设备，确保所需的函数指针被正确加载。</li>
<li><strong>Hid_Destroy</strong>: 释放 HID 设备的资源。</li>
<li><strong>SendIoctl_HideObjectPacket</strong>: 发送 IOCTL 命令以隐藏对象。</li>
<li><strong>DeviceIoControl</strong>: 与设备驱动程序进行通信的核心函数。</li>
</ul>
<ol>
<li><code>HidStatus _API Hid_InitializeWithNoConnection();</code> 函数：初始化 HID 设备而不建立连接，加载必要的函数指针。</li>
<li><code>HidStatus _API Hid_Initialize(PHidContext pcontext, const wchar_t* deviceName);</code> 函数：初始化 HID 设备并打开设备文件。</li>
<li><code>void _API Hid_Destroy(HidContext context);</code> 函数：释放 HID 设备的资源。</li>
<li><code>bool ConvertToNtPath(const wchar_t* path, wchar_t* normalized, size_t normalizedLen);</code> 函数：将 DOS 路径转换为 NT 路径。</li>
<li><code>bool NormalizeRegistryPath(HidRegRootTypes root, const wchar_t* key, wchar_t* normalized, size_t normalizedLen);</code> 函数：标准化注册表路径。</li>
<li><code>HidStatus AllocNormalizedPath(const wchar_t* path, wchar_t** normalized);</code> 函数：分配标准化路径的内存。</li>
<li><code>HidStatus SendIoctl_HideObjectPacket(PHidContextInternal context, const wchar_t* path, unsigned short type, HidObjId* objId);</code> 函数：发送 IOCTL 命令以隐藏对象。</li>
<li><code>HidStatus SendIoctl_UnhideObjectPacket(PHidContextInternal context, unsigned short type, HidObjId objId);</code> 函数：发送 IOCTL 命令以取消隐藏对象。</li>
<li><code>HidStatus SendIoctl_AddPsObjectPacket(PHidContextInternal context, const wchar_t* path, unsigned short type, HidPsInheritTypes inheritType, bool applyForProcess, HidObjId* objId);</code> 函数：添加进程对象。</li>
<li><code>HidStatus _API Hid_SetState(HidContext context, HidActiveState state);</code> 函数：设置 HID 设备的状态。</li>
<li><code>HidStatus _API Hid_GetState(HidContext context, HidActiveState* pstate);</code> 函数：获取 HID 设备的状态。</li>
<li><code>HidStatus _API Hid_AddHiddenFile(HidContext context, const wchar_t* filePath, HidObjId* objId);</code> 函数：添加隐藏文件。</li>
<li><code>HidStatus _API Hid_RemoveHiddenFile(HidContext context, HidObjId objId);</code> 函数：移除隐藏文件。</li>
<li><code>HidStatus _API Hid_NormalizeFilePath(const wchar_t* filePath, wchar_t* normalized, size_t normalizedLen);</code> 函数：标准化文件路径。</li>
</ol>
<h2 id="远程shell管理-shellmanager"><a href="#远程shell管理-shellmanager" class="headerlink" title="远程shell管理 shellmanager"></a>远程shell管理 shellmanager</h2><p> <code>CShellManager</code> 类，负责管理与外部命令行进程的交互，包括创建管道、启动进程、读取输出和监控进程状态。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre class="mermaid">graph TD;
    A[CShellManager] -->|创建| B[管道]
    A -->|启动| C[cmd.exe]
    A -->|读取| D[输出]
    A -->|监控| E[进程状态]
    D -->|发送| F[客户端]</pre>

<ul>
<li><strong>CShellManager</strong>: 管理与命令行进程的交互。</li>
<li><strong>管道</strong>: 用于进程间通信。</li>
<li><strong>cmd.exe</strong>: 被启动的命令行进程。</li>
<li><strong>输出</strong>: 从命令行进程读取的数据。</li>
<li><strong>进程状态</strong>: 监控命令行进程的运行状态。</li>
</ul>
<ol>
<li><code>CShellManager::CShellManager(ISocketBase* pClient)</code>: 构造函数，初始化管道和启动命令行进程。</li>
<li><code>CShellManager::~CShellManager()</code>: 析构函数，清理资源，终止线程和进程。</li>
<li><code>void CShellManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的数据，发送到命令行进程。</li>
<li><code>unsigned CShellManager::ReadPipeThread(LPVOID lparam)</code>: 读取管道数据的线程函数，处理命令行进程的输出。</li>
<li><code>unsigned CShellManager::MonitorThread(LPVOID lparam)</code>: 监控命令行进程和读取线程的状态，确保它们正常运行。</li>
</ol>
<h2 id="远控CC信息交互"><a href="#远控CC信息交互" class="headerlink" title="远控CC信息交互"></a>远控CC信息交互</h2><p>聊天管理器，负责处理聊天窗口的创建、消息发送、键盘钩子设置以及与系统交互的功能。</p>
<pre class="mermaid">graph TD;
    A[CChatManager] -->|创建| B[ChatDialogProc]
    A -->|发送消息| C[OnReceive]
    A -->|设置钩子| D[SetHook]
    A -->|解除钩子| E[UnSetHook]
    B -->|处理消息| F[WM_COMMAND]
    F -->|发送按钮| G[SendMessage]
    F -->|关闭按钮| H[WM_CLOSE]</pre>

<ul>
<li><strong>CChatManager</strong>: 聊天管理器类，负责聊天窗口的管理和消息处理。</li>
<li><strong>ChatDialogProc</strong>: 聊天对话框的消息处理函数，处理用户输入和按钮点击事件。</li>
<li><strong>OnReceive</strong>: 处理接收到的消息并更新聊天记录。</li>
<li><strong>SetHook</strong>: 设置键盘钩子以拦截特定的键盘事件。</li>
<li><strong>UnSetHook</strong>: 解除键盘钩子，恢复正常的键盘操作。</li>
</ul>
<ol>
<li><code>CChatManager::CChatManager(ISocketBase* pClient);</code> 函数：构造函数，初始化聊天管理器并启动消息循环。</li>
<li><code>CChatManager::~CChatManager();</code> 函数：析构函数，清理资源并解除钩子。</li>
<li><code>DWORD WINAPI CChatManager::MessageLoopProc(LPVOID lParam);</code> 函数：消息循环处理函数，创建聊天对话框并处理消息。</li>
<li><code>INT_PTR CALLBACK CChatManager::ChatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);</code> 函数：聊天对话框的回调函数，处理对话框的消息。</li>
<li><code>void CChatManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的聊天消息并更新聊天记录。</li>
<li><code>void SetHook();</code> 函数：设置键盘钩子以拦截特定的键盘事件。</li>
<li><code>void UnSetHook();</code> 函数：解除键盘钩子，恢复正常的键盘操作。</li>
<li><code>DWORD GetWinlogonPid();</code> 函数：获取系统winlogon进程的PID。</li>
<li><code>LRESULT CALLBACK KeyBoardProc(int code, WPARAM wParam, LPARAM lParam);</code> 函数：键盘钩子的回调函数，处理键盘事件。</li>
</ol>
<h2 id="解密数据模块"><a href="#解密数据模块" class="headerlink" title="解密数据模块"></a>解密数据模块</h2><h3 id="解密浏览器数据"><a href="#解密浏览器数据" class="headerlink" title="解密浏览器数据"></a>解密浏览器数据</h3><p>该代码文件 <code>GetBrowserInfo.cpp</code> 主要用于获取不同浏览器（如 Chrome、QQ、Edge 和 Speed 360）的用户数据，包括登录信息和 cookies。它通过访问特定的文件路径和数据库来提取这些信息。</p>
<pre class="mermaid">graph LR;
    A[GetBrowserInfo] --> B[GetFullPathFromRelativeToBro]
    A --> C[GetCookies]
    A --> D[GetAllCookies]
    A --> E[GetAllData]
    A --> F[GetData]
    A --> G[Find360SPLoginDB]
    A --> H[GetMasterKey]
    A --> I[ParseEncryptedKey]</pre>

<ul>
<li><strong>GetBrowserInfo</strong>: 主类，负责初始化和管理浏览器信息的获取。</li>
<li><strong>GetFullPathFromRelativeToBro</strong>: 生成相对于浏览器目录的完整路径。</li>
<li><strong>GetCookies</strong>: 从浏览器的 cookies 数据库中提取 cookies 信息。</li>
<li><strong>GetAllCookies</strong>: 获取所有 cookies 的入口函数。</li>
<li><strong>GetAllData</strong>: 获取所有用户数据的入口函数。</li>
<li><strong>GetData</strong>: 从登录数据数据库中提取用户登录信息。</li>
<li><strong>Find360SPLoginDB</strong>: 查找 360 浏览器的登录数据库。</li>
<li><strong>GetMasterKey</strong>: 获取解密所需的主密钥。</li>
<li><strong>ParseEncryptedKey</strong>: 解析加密密钥。</li>
</ul>
<ol>
<li><code>GetBrowserInfo::GetBrowserInfo(BroType brot)</code>: 构造函数，根据浏览器类型初始化相关路径和状态。</li>
<li><code>GetBrowserInfo::~GetBrowserInfo()</code>: 析构函数，负责清理资源。</li>
<li><code>std::string GetBrowserInfo::GetFullPathFromRelativeToBro(LPCSTR relative)</code>: 生成相对于浏览器目录的完整路径。</li>
<li><code>DWORD GetBrowserInfo::GetCookies(std::vector&lt;BrowserCookies&gt; *pBroCookies)</code>: 从 cookies 数据库中提取 cookies 信息。</li>
<li><code>BOOL GetBrowserInfo::GetAllCookies(std::vector&lt;BrowserCookies&gt; *pBroCookies)</code>: 获取所有 cookies 的入口函数。</li>
<li><code>BOOL GetBrowserInfo::GetAllData(std::vector&lt;BrowserData&gt; *pBroData)</code>: 获取所有用户数据的入口函数。</li>
<li><code>DWORD GetBrowserInfo::GetData(std::vector&lt;BrowserData&gt; *pBroData)</code>: 从登录数据数据库中提取用户登录信息。</li>
<li><code>LPCSTR GetBrowserInfo::ParseEncryptedKey(LPSTR* buf)</code>: 解析加密密钥。</li>
<li><code>bool GetBrowserInfo::GetMasterKey(DATA_BLOB* pDatab)</code>: 获取解密所需的主密钥。</li>
<li><code>void GetBrowserInfo::Find360SPLoginDB(std::string lpPath)</code>: 查找 360 浏览器的登录数据库。</li>
</ol>
<h3 id="获取360浏览器数据"><a href="#获取360浏览器数据" class="headerlink" title="获取360浏览器数据"></a>获取360浏览器数据</h3><p> <code>Get360seInfo</code> 的类，主要用于从 360 浏览器的数据库中提取用户的浏览器数据，包括账户信息和密码。</p>
<pre class="mermaid">graph TD;
    A[Get360seInfo] --> B[构造函数]
    A --> C[getData]
    C --> D[Open360Database]
    D --> E[OpenLogin360Data]
    D --> F[FindLoginDB]
    E --> G[DecryptAes]
    E --> H[Last360Uncode]</pre>

<ul>
<li><strong>Get360seInfo</strong>: 主类，负责初始化和管理数据提取过程。</li>
<li><strong>构造函数</strong>: 初始化类的成员变量并获取必要的注册表信息。</li>
<li><strong>getData</strong>: 主要数据提取函数，调用数据库打开和数据读取函数。</li>
<li><strong>Open360Database</strong>: 打开 360 浏览器的数据库并读取账户信息。</li>
<li><strong>OpenLogin360Data</strong>: 处理登录数据的提取和解密。</li>
<li><strong>FindLoginDB</strong>: 查找登录数据库文件的路径。</li>
</ul>
<ol>
<li><code>Get360seInfo::Get360seInfo()</code>: 构造函数，初始化成员变量并从注册表中获取必要的信息。</li>
<li><code>Get360seInfo::~Get360seInfo()</code>: 析构函数，释放资源。</li>
<li><code>bool Get360seInfo::getData(std::vector&lt;BrowserData&gt;* pBroData)</code>: 提取浏览器数据，调用数据库打开和登录数据提取函数。</li>
<li><code>bool Get360seInfo::Open360Database(std::vector&lt;BrowserData&gt;* pBroData)</code>: 打开 360 浏览器的数据库并读取账户信息。</li>
<li><code>std::string Get360seInfo::Last360Uncode(const char* passItem)</code>: 解码密码项，处理特定格式的密码。</li>
<li><code>void Get360seInfo::FindLoginDB(std::string lpPath)</code>: 查找登录数据库文件的路径。</li>
<li><code>bool Get360seInfo::OpenLogin360Data(std::vector&lt;BrowserData&gt;* pBroData)</code>: 提取和解密登录数据。</li>
<li><code>bool Get360seInfo::EnumChromeRandstr(DWORD th32ProcessID, HANDLE h_360se)</code>: 枚举 Chrome 进程中的随机字符串。</li>
<li><code>bool Get360seInfo::EnumProcessGetRandstr()</code>: 获取 360 浏览器进程中的随机字符串。</li>
<li><code>ULONG PseudoRand(ULONG* seed)</code>: 伪随机数生成函数。</li>
<li><code>void GetBotId(char* botId)</code>: 生成一个唯一的 bot ID。</li>
</ol>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>机器管理器（CMachineManager），用于管理和监控系统中的进程、服务、网络状态等功能。</p>
<pre class="mermaid">graph LR;
    A[CMachineManager] --> B[OnReceive]
    B --> C[SendProcessList]
    B --> D[SendWindowsList]
    B --> E[SendNetStateList]
    B --> F[SendSoftWareList]
    B --> G[SendIEHistoryList]
    B --> H[SendFavoritesUrlList]
    B --> I[SendServicesList]
    B --> J[SendHostsList]
    B --> K[DeleteService]
    B --> L[MyControlService]
    B --> M[GetRoot]
    B --> N[InjectProcess]</pre>

<ul>
<li><strong>CMachineManager</strong>: 主要类，负责管理机器的各种操作。</li>
<li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li>
<li><strong>SendProcessList</strong>: 发送当前进程列表。</li>
<li><strong>SendWindowsList</strong>: 发送当前窗口列表。</li>
<li><strong>SendNetStateList</strong>: 发送网络状态列表。</li>
<li><strong>SendSoftWareList</strong>: 发送已安装软件列表。</li>
<li><strong>SendIEHistoryList</strong>: 发送IE浏览历史。</li>
<li><strong>SendFavoritesUrlList</strong>: 发送收藏夹URL列表。</li>
<li><strong>SendServicesList</strong>: 发送服务列表。</li>
<li><strong>SendHostsList</strong>: 发送hosts文件内容。</li>
<li><strong>DeleteService</strong>: 删除指定服务。</li>
<li><strong>MyControlService</strong>: 控制服务的启动、停止、暂停和继续。</li>
<li><strong>GetRoot</strong>: 获取任务调度器的根目录。</li>
</ul>
<ol>
<li><code>CMachineManager::CMachineManager(ISocketBase* pClient)</code>: 构造函数，初始化机器管理器，设置用户权限和服务。</li>
<li><code>CMachineManager::~CMachineManager()</code>: 析构函数，释放资源，反初始化COM。</li>
<li><code>void CMachineManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的数据，根据命令类型调用相应的处理函数。</li>
<li><code>void CMachineManager::SendProcessList()</code>: 发送当前进程列表。</li>
<li><code>void CMachineManager::SendWindowsList()</code>: 发送当前窗口列表。</li>
<li><code>void CMachineManager::SendNetStateList()</code>: 发送网络状态列表。</li>
<li><code>void CMachineManager::SendSoftWareList()</code>: 发送已安装软件列表。</li>
<li><code>void CMachineManager::SendIEHistoryList()</code>: 发送IE浏览历史。</li>
<li><code>void CMachineManager::SendFavoritesUrlList()</code>: 发送收藏夹URL列表。</li>
<li><code>void CMachineManager::SendServicesList(DWORD dwServiceType)</code>: 发送服务列表。</li>
<li><code>void CMachineManager::SendHostsList()</code>: 发送hosts文件内容。</li>
<li><code>void CMachineManager::DeleteService(LPBYTE lpBuffer, UINT nSize)</code>: 删除指定服务。</li>
<li><code>void CMachineManager::MyControlService(LPBYTE lpBuffer, UINT nType)</code>: 控制服务的启动、停止、暂停和继续。</li>
<li><code>void CMachineManager::GetRoot()</code>: 获取任务调度器的根目录。</li>
<li><code>BOOL CMachineManager::DebugPrivilege(const TCHAR* PName, BOOL bEnable)</code>: 调整进程的调试权限。</li>
<li><code>BOOL CMachineManager::GetProcessUserName(HANDLE hProcess, TCHAR* strProcessUser)</code>: 获取指定进程的用户名。</li>
<li><code>LPBYTE CMachineManager::getProcessList()</code>: 获取当前进程列表。</li>
<li><code>LPBYTE CMachineManager::getWindowsList()</code>: 获取当前窗口列表。</li>
<li><code>LPBYTE CMachineManager::getNetStateList()</code>: 获取网络状态列表。</li>
<li><code>LPBYTE CMachineManager::getSoftWareList()</code>: 获取已安装软件列表。</li>
<li><code>LPBYTE CMachineManager::getIEHistoryList()</code>: 获取IE浏览历史。</li>
<li><code>LPBYTE CMachineManager::getFavoritesUrlList()</code>: 获取收藏夹URL列表。</li>
<li><code>LPBYTE CMachineManager::getServicesList()</code>: 获取服务列表。</li>
<li><code>LPBYTE CMachineManager::getHostsList()</code>: 获取hosts文件内容。</li>
<li><code>void CMachineManager::injectprocess(DWORD mode, DWORD ExeIsx86, DWORD dwProcessID, byte* data, DWORD datasize, TCHAR* path)</code>: 注入进程，执行指定的操作。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>银狐源码解读--核心组件模块</div>
      <div>http://example.com/2024/12/06/银狐源码解读-核心组件模块/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jentle</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 6, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/" title="揭秘 “沉默山猫”（Silent Lynx）高级持续威胁组织：针对吉尔吉斯斯坦及周边国家的恶意攻击">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">揭秘 “沉默山猫”（Silent Lynx）高级持续威胁组织：针对吉尔吉斯斯坦及周边国家的恶意攻击</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/12/02/%E4%BC%AA%E9%80%A0%E8%B0%83%E7%94%A8%E6%A0%88%E6%9D%A5%E8%BF%B7%E6%83%91EDR%E5%92%8C%E6%9D%80%E8%BD%AF/" title="伪造调用栈来迷惑EDR和杀软">
                        <span class="hidden-mobile">伪造调用栈来迷惑EDR和杀软</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body>
</html>
